<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
           "http://www.w3.org/TR/html4/loose.dtd">
<html><head><title>Synopsis 5: Regexes and Rules
</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" >
<link rel="stylesheet" type="text/css" title="pod_stylesheet" href="/perl-with-historical-message.css">

<script type="text/javascript">// EVENT HANDLING

// http://therealcrisp.xs4all.nl/upload/addEvent_dean.html
// written by Dean Edwards, 2005
// with input from Tino Zijdel - crisp@xs4all.nl
// http://dean.edwards.name/weblog/2005/10/add-event/
// modified by Aankhen

var addEvent;

if (window.addEventListener) {
    addEvent = function (element, type, handler) { element.addEventListener(type, handler, (typeof arguments[3] != 'undefined') ? arguments[3] : false); };
} else {
  addEvent = function (element, type, handler) {
    // assign each event handler a unique ID
    if (!handler.$$guid) handler.$$guid = addEvent.guid++;
    // create a hash table of event types for the element
    if (!element.events) element.events = {};
    // create a hash table of event handlers for each element/event pair
    var handlers = element.events[type];
    if (!handlers) {
      handlers = element.events[type] = {};
      // store the existing event handler (if there is one)
      if (element['on' + type]) {
        handlers[0] = element['on' + type];
      }
      // assign a global event handler to do all the work
      element['on' + type] = handleEvent;
    }

    // store the event handler in the hash table
    handlers[handler.$$guid] = handler;
  }
}

// a counter used to create unique IDs
addEvent.guid = 1;

function removeEvent(element, type, handler) {
  if (element.removeEventListener)
    element.removeEventListener(type, handler, false);
  // delete the event handler from the hash table
  else if (element.events && element.events[type] && handler.$$guid)
    delete element.events[type][handler.$$guid];
}

function handleEvent(event) {
  // grab the event object (IE uses a global event object)
  event = event || fixEvent(window.event);

  var returnValue = true;

  // get a reference to the hash table of event handlers
  var handlers = this.events[event.type];

  // execute each event handler
  for (var i in handlers) {
    // don't copy object properties
    if (!Object.prototype[i]) {
      this.$$handler = handlers[i];
      if (this.$$handler(event) === false) {
        returnValue = false;
        // in accordance with DOM2-Events, all remaining event handlers on the object will be triggered, hence the absence of a `break`
      }
    }
  }

  // clean up
  if (this.$$handler) this.$$handler = null;

  return returnValue;
}

function fixEvent(event) {
  // add W3C standard event methods
  event.preventDefault = fixEvent.preventDefault;
  event.stopPropagation = fixEvent.stopPropagation;
  return event;
}

fixEvent.preventDefault = function() {
  this.returnValue = false;
};

fixEvent.stopPropagation = function() {
  this.cancelBubble = true;
};


// VISIBILITY TOGGLE

function toggle_snippet (e) {
  var matches = this.id.match(/smartlink_toggle(\d+)/);
  var num = matches[1];

  var id = 'smartlink_' + num;
  var div = document.getElementById(id);
  div.style.display = (div.style.display == 'none') ? '' : 'none';

  var text = this.firstChild;
  text.nodeValue = text.nodeValue.replace(/^- (Show|Hide)/, function (full, p1) { return "- " + ((p1 == 'Show') ? 'Hide' : 'Show') }); // this may be unnecessarily complicated, or it may not.  you get to decide. :-)

  e.stopPropagation();
  e.preventDefault();

  return false;
}

function toggle_hilite(id,url) {
    var el = document.getElementById(id);
    if(el) {
        if(el.style.display == "none") {
            el.src = url;
            el.style.display = "block";
        } else {
            el.style.display = "none";
        }
    }
    return false;
}


// LINK GENERATION
// this would be simpler if we used a library like YUI to simplify retrieval and creation of elements, but oh well

function collectionToArray(col) {
  a = new Array();
  for (i = 0; i < col.length; i++)
    a[a.length] = col[i];
  return a;
}

addEvent(window, 'load', function () {
  var divs = collectionToArray(document.getElementsByTagName('div'));

  for (var i = 0, j = divs.length; i < j; i++) {
    var curr = divs[i];
    if (curr.id && curr.id.match(/smartlink_(\d+)/)) {
      var num = RegExp.$1;

      var toBeRemoved = [ "smartlink_skip_", "smartlink_skipto_" ]; // let it be reusable since this list could conceivably grow :-)
      for (var k = 0, l = toBeRemoved.length; k < l; k++) {
        var id = toBeRemoved[k] + num;
        var elm = document.getElementById(id);
        elm.parentNode.removeChild(elm);
      }

      var p = curr.previousSibling;

      while (p.nodeType != 1) { p = p.previousSibling; } // ignore any whitespace-only nodes

      var text = p.firstChild;
      text.nodeValue = text.nodeValue.replace(/^From/, '- Show');

      var link = document.createElement('a');

      var child;
      while (child = p.firstChild) {
        link.appendChild(child);
      }

      var end = link.lastChild;
      if ((end.nodeType == 3) && (end.nodeValue.search(/:$/) > -1)) {
        end.nodeValue = end.nodeValue.replace(/:$/, ' -');
      }

      link.href = '#';
      link.id = 'smartlink_toggle' + num;
      addEvent(link, 'click', toggle_snippet);

      p.appendChild(link);
      curr.parentNode.insertBefore(p, curr);
      curr.style.display = 'none';
    }

    // explicitly jump to the page anchor (if any) since the code above messes it up
    if (location.hash && location.hash.match(/#.+/)) location.hash = RegExp.lastMatch;
  }
});
</script>
<style type="text/css">
.ok {
    color: green;
    font-weight: bold;
}
.nok {
    color: red;
    font-weight: bold;
}
.snip { margin-left: 6px; }
.snipres {
    margin-left: 6px;
    border-width: 0;
}
.smartlink_snippet {
    border: 1px solid;
    padding: 0.2em;
}
</style>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.35,
  using Pod::Simple::PullParser v3.35,
  under Perl v5.026000 at Fri Apr 19 11:48:06 2019 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
        <em>This page was generated by Text::SmartLinks v0.01 at 2019-04-19 11:48:06 GMT.<br>
        (<a href="https://github.com/perl6/specs/">syn</a> <strong>8d47115</strong>)</em>
        &nbsp; [ <a href="http://design.perl6.org/">Index of Synopses</a> ]<br>
        <a id='__top'></a>
    
<a name='___top' class='dummyTopAnchor' ></a>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#TITLE'>TITLE</a>
  <li class='indexItem indexItem1'><a href='#VERSION'>VERSION</a>
  <li class='indexItem indexItem1'><a href='#Overview'>Overview</a>
  <li class='indexItem indexItem1'><a href='#New_match_result_and_capture_variables'>New match result and capture variables</a>
  <li class='indexItem indexItem1'><a href='#Unchanged_syntactic_features'>Unchanged syntactic features</a>
  <li class='indexItem indexItem1'><a href='#Simplified_lexical_parsing_of_patterns'>Simplified lexical parsing of patterns</a>
  <li class='indexItem indexItem1'><a href='#Modifiers'>Modifiers</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Allowed_modifiers'>Allowed modifiers</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#Changed_metacharacters'>Changed metacharacters</a>
  <li class='indexItem indexItem1'><a href='#New_metacharacters'>New metacharacters</a>
  <li class='indexItem indexItem1'><a href='#Bracket_rationalization'>Bracket rationalization</a>
  <li class='indexItem indexItem1'><a href='#Variable_(non-)interpolation'>Variable (non-)interpolation</a>
  <li class='indexItem indexItem1'><a href='#Extensible_metasyntax_(%3C...%3E)'>Extensible metasyntax (&#60;...&#62;)</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Predefined_Subrules'>Predefined Subrules</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#Backslash_reform'>Backslash reform</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Character_class_shortcuts'>Character class shortcuts</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#Regexes_constitute_a_first-class_language%2C_rather_than_just_being_strings'>Regexes constitute a first-class language, rather than just being strings</a>
  <li class='indexItem indexItem1'><a href='#Backtracking_control'>Backtracking control</a>
  <li class='indexItem indexItem1'><a href='#Regex_Routines%2C_Named_and_Anonymous'>Regex Routines, Named and Anonymous</a>
  <li class='indexItem indexItem1'><a href='#Nothing_is_illegal'>Nothing is illegal</a>
  <li class='indexItem indexItem1'><a href='#Longest-token_matching'>Longest-token matching</a>
  <li class='indexItem indexItem1'><a href='#Return_values_from_matches'>Return values from matches</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Match_objects'>Match objects</a>
    <li class='indexItem indexItem2'><a href='#Subpattern_captures'>Subpattern captures</a>
    <li class='indexItem indexItem2'><a href='#Accessing_captured_subpatterns'>Accessing captured subpatterns</a>
    <li class='indexItem indexItem2'><a href='#Nested_subpattern_captures'>Nested subpattern captures</a>
    <li class='indexItem indexItem2'><a href='#Quantified_subpattern_captures'>Quantified subpattern captures</a>
    <li class='indexItem indexItem2'><a href='#Indirectly_quantified_subpattern_captures'>Indirectly quantified subpattern captures</a>
    <li class='indexItem indexItem2'><a href='#Subpattern_numbering'>Subpattern numbering</a>
    <li class='indexItem indexItem2'><a href='#Subrule_captures'>Subrule captures</a>
    <li class='indexItem indexItem2'><a href='#Accessing_captured_subrules'>Accessing captured subrules</a>
    <li class='indexItem indexItem2'><a href='#Repeated_captures_of_the_same_subrule'>Repeated captures of the same subrule</a>
    <li class='indexItem indexItem2'><a href='#Aliasing'>Aliasing</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#Named_scalar_aliasing_to_subpatterns'>Named scalar aliasing to subpatterns</a>
      <li class='indexItem indexItem3'><a href='#Named_scalar_aliases_applied_to_non-capturing_brackets'>Named scalar aliases applied to non-capturing brackets</a>
      <li class='indexItem indexItem3'><a href='#Named_scalar_aliasing_to_subrules'>Named scalar aliasing to subrules</a>
      <li class='indexItem indexItem3'><a href='#Numbered_scalar_aliasing'>Numbered scalar aliasing</a>
      <li class='indexItem indexItem3'><a href='#Scalar_aliases_applied_to_quantified_constructs'>Scalar aliases applied to quantified constructs</a>
      <li class='indexItem indexItem3'><a href='#Array_aliasing'>Array aliasing</a>
      <li class='indexItem indexItem3'><a href='#Hash_aliasing'>Hash aliasing</a>
      <li class='indexItem indexItem3'><a href='#External_aliasing'>External aliasing</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#Capturing_from_repeated_matches'>Capturing from repeated matches</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#Grammars'>Grammars</a>
  <li class='indexItem indexItem1'><a href='#Action_objects'>Action objects</a>
  <li class='indexItem indexItem1'><a href='#Syntactic_categories'>Syntactic categories</a>
  <li class='indexItem indexItem1'><a href='#Pragmas'>Pragmas</a>
  <li class='indexItem indexItem1'><a href='#Transliteration'>Transliteration</a>
  <li class='indexItem indexItem1'><a href='#Substitution'>Substitution</a>
  <li class='indexItem indexItem1'><a href='#Positional_matching%2C_fixed_width_types'>Positional matching, fixed width types</a>
  <li class='indexItem indexItem1'><a href='#Matching_against_non-strings'>Matching against non-strings</a>
  <li class='indexItem indexItem1'><a href='#When_%24%2F_is_valid'>When $/ is valid</a>
  <li class='indexItem indexItem1'><a href='#AUTHORS'>AUTHORS</a>
</ul>
</div>

<a id="line_1"></a>
<a id="line_2"></a>
<a id="line_3"></a>
<a id="line_4"></a>
<a id="line_5"></a>


<h1><a class='u' href='#___top' title='click to go to top of document'
name="TITLE"
>TITLE</a></h1>

<p>Synopsis 5: Regexes and Rules</p>

<a id="line_6"></a>
<a id="line_7"></a>
<a id="line_8"></a>
<a id="line_9"></a>


<h1><a class='u' href='#___top' title='click to go to top of document'
name="VERSION"
>VERSION</a></h1>

<pre>    Created: 24 Jun 2002</pre>

<a id="line_10"></a>
<a id="line_11"></a>
<a id="line_12"></a>


<pre>    Last Modified: 6 June 2017
    Version: 181</pre>

<a id="line_13"></a>
<a id="line_14"></a>
<a id="line_15"></a>
<a id="line_16"></a>
<a id="line_17"></a>
<a id="line_18"></a>
<a id="line_19"></a>
<a id="line_20"></a>
<a id="line_21"></a>
<a id="line_22"></a>
<a id="line_23"></a>
<a id="line_24"></a>


<p>This document summarizes Apocalypse 5, which is about the new regex syntax. We now try to call them <i>regex</i> rather than &#34;regular expressions&#34; because they haven&#39;t been regular expressions for a long time, and we think the popular term &#34;regex&#34; is in the process of becoming a technical term with a precise meaning of: &#34;something you do pattern matching with, kinda like a regular expression&#34;. On the other hand, one of the purposes of the redesign is to make portions of our patterns more amenable to analysis under traditional regular expression and parser semantics, and that involves making careful distinctions between which parts of our patterns and grammars are to be treated as declarative, and which parts as procedural.</p>

<a id="line_25"></a>
<a id="line_26"></a>
<a id="line_27"></a>


<p>In any case, when referring to recursive patterns within a grammar, the terms <i>rule</i> and <i>token</i> are generally preferred over <i>regex</i>.</p>

<a id="line_28"></a>
<a id="line_29"></a>
<a id="line_30"></a>
<a id="line_31"></a>
<a id="line_32"></a>
<a id="line_33"></a>
<a id="line_34"></a>


<h1><a class='u' href='#___top' title='click to go to top of document'
name="Overview"
>Overview</a></h1>

<p>In essence, Perl 6 natively implements Parsing Expression Grammars (PEGs) as an extension of regular expression notation. PEGs require that you provide a &#34;pecking order&#34; for ambiguous parses. Perl 6&#39;s pecking order is determined by a multi-level tie-breaking test:</p>

<a id="line_35"></a>
<a id="line_36"></a>
<a id="line_37"></a>
<a id="line_38"></a>
<a id="line_39"></a>
<a id="line_40"></a>


<pre>    1) Most-derived only/proto hides less-derived of the same name
    2) Longest token matching: food\s+ beats foo by 2 or more positions
    3) Longest literal prefix: food\w* beats foo\w* by 1 position
    4) For a given proto, multis from a more-derived grammar win
    5) Within a given compilation unit, the earlier alternative or multi wins</pre>

<a id="line_41"></a>
<a id="line_42"></a>
<a id="line_43"></a>
<a id="line_44"></a>
<a id="line_45"></a>
<a id="line_46"></a>
<a id="line_47"></a>
<a id="line_48"></a>


<p>Tiebreaker #3 will treat any initial sequence of literals as the longest literal prefix. If there is an alternation embedded in the longest token matching, those alternations can extend a literal prefix provided everything was literal up to the alternation. If all of the alternations are totally literal, then the literal can also extend beyond the end of the alternation when they rejoin. Otherwise the end of the alternation terminates all longest literal prefixes, even the branches that are totally literal. For example:</p>

<a id="line_49"></a>
<a id="line_50"></a>
<a id="line_51"></a>
<a id="line_52"></a>


<pre>    / a [ 1 | 2 ] b /   # longest literals are &#39;a1b&#39; and &#39;a2b&#39;
    / a [ 1 | 2\w ] b / # longest literals are &#39;a1 and &#39;a2&#39;
    / a &#60;[ 1 2 ]&#62; b /   # longest literal is only &#39;a&#39;</pre>

<a id="line_53"></a>
<a id="line_54"></a>
<a id="line_55"></a>


<p>Note that in this case, a character class is not treated the same as an alternation. All character classes are considered too generic to include in a longest literal string.</p>

<a id="line_56"></a>
<a id="line_57"></a>
<a id="line_58"></a>
<a id="line_59"></a>
<a id="line_60"></a>


<p>As with longest token matching, longest literal prefixes are transitive through subrules. If a subrule is a protoregex, it is treated just as alternation with <code>|</code> is, and follows the same rules about extending or terminating the longest literal prefix.</p>

<a id="line_61"></a>
<a id="line_62"></a>
<a id="line_63"></a>
<a id="line_64"></a>
<a id="line_65"></a>
<a id="line_66"></a>
<a id="line_67"></a>


<p>In addition to this pecking order, if any rule chosen under the pecking backtracks, the next best rule is chosen. That is, the pecking order determines a candidate list; just because one candidate is chosen does not mean the rest are thrown away. They may, however, be explicitly thrown away by an appropriate backtracking control (sometimes called a &#34;cut&#34; operator, but Perl 6 has several of them, depending on how much you want to cut).</p>

<a id="line_68"></a>
<a id="line_69"></a>
<a id="line_70"></a>


<p>Also, any rule chosen to execute under #1 may choose to delegate to its ancestors; PEG backtracking has no control over this.</p>

<a id="line_71"></a>
<a id="line_72"></a>
<a id="line_73"></a>
<a id="line_74"></a>
<a id="line_75"></a>
<a id="line_76"></a>
<a id="line_77"></a>
<a id="line_78"></a>


<h1><a class='u' href='#___top' title='click to go to top of document'
name="New_match_result_and_capture_variables"
>New match result and capture variables</a></h1>

<p>The underlying match object is now available via the <code>$/</code> variable, which is implicitly lexically scoped. All user access to the most recent match is through this variable, even when it doesn&#39;t look like it. The individual capture variables (such as <code>$0</code>, <code>$1</code>, etc.) are just elements of <code>$/</code>.</p>

<a id="line_79"></a>
<a id="line_80"></a>
<a id="line_81"></a>


<p>By the way, unlike in Perl 5, the numbered capture variables now start at <code>$0</code> instead of <code>$1</code>. See below.</p>

<a id="line_82"></a>
<a id="line_83"></a>
<a id="line_84"></a>


<p>In order to detect accidental use of Perl 5&#39;s unrelated <code>$/</code> variable, Perl 6&#39;s <code>$/</code> variable may not be assigned to directly.</p>

<a id="line_85"></a>
<a id="line_86"></a>
<a id="line_87"></a>
<a id="line_88"></a>
<a id="line_89"></a>


<pre>    $/ = $x;   # &#34;Unsupported use of $/ variable as input record separator&#34;
    $/ := $x;  # OK, binding
    $/ RR= $x; # OK, metaoperator
    ($/) = $x; # OK, list assignment</pre>

<a id="line_90"></a>
<a id="line_91"></a>
<a id="line_92"></a>
<a id="line_93"></a>


<h1><a class='u' href='#___top' title='click to go to top of document'
name="Unchanged_syntactic_features"
>Unchanged syntactic features</a></h1>

<p>The following regex features use the same syntax as in Perl 5:</p>

<a id="line_94"></a>
<a id="line_95"></a>
<a id="line_96"></a>
<a id="line_97"></a>
<a id="line_98"></a>
<a id="line_99"></a>


<ul>
<li>Capturing: (...)
<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-mass/rx.t#L94-L245"><code>S05-mass/rx.t</code> lines <code>94&ndash;245</code></a>
  </p>
</div>
  


<a id="line_100"></a>
<a id="line_101"></a>
<a id="line_102"></a>
<a id="line_103"></a>

</li>

<li>Repetition quantifiers: *, +, and ?
<a id="line_104"></a>
<a id="line_105"></a>
<a id="line_106"></a>
<a id="line_107"></a>

</li>

<li>Alternatives: |
<a id="line_108"></a>
<a id="line_109"></a>
<a id="line_110"></a>
<a id="line_111"></a>

</li>

<li>Backslash escape: \
<a id="line_112"></a>
<a id="line_113"></a>
<a id="line_114"></a>
<a id="line_115"></a>

</li>

<li>Minimal matching suffix: ??, *?, +?
<a id="line_116"></a>
<a id="line_117"></a>

</li>
</ul>

<a id="line_118"></a>
<a id="line_119"></a>
<a id="line_120"></a>
<a id="line_121"></a>
<a id="line_122"></a>
<a id="line_123"></a>
<a id="line_124"></a>


<p>While the syntax of <code>|</code> does not change, the default semantics do change slightly. We are attempting to concoct a pleasing mixture of declarative and procedural matching so that we can have the best of both. In short, you need not write your own tokener for a grammar because Perl will write one for you. See the section below on &#34;Longest-token matching&#34;.</p>

<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-metasyntax/longest-alternative.t#L6-L51"><code>S05-metasyntax/longest-alternative.t</code> lines <code>6&ndash;51</code></a>
  </p>
</div>
  


<a id="line_125"></a>
<a id="line_126"></a>
<a id="line_127"></a>
<a id="line_128"></a>
<a id="line_129"></a>
<a id="line_130"></a>
<a id="line_131"></a>
<a id="line_132"></a>
<a id="line_133"></a>
<a id="line_134"></a>
<a id="line_135"></a>
<a id="line_136"></a>


<h1><a class='u' href='#___top' title='click to go to top of document'
name="Simplified_lexical_parsing_of_patterns"
>Simplified lexical parsing of patterns</a></h1>

<p>Unlike traditional regular expressions, Perl 6 does not require you to memorize an arbitrary list of metacharacters. Instead it classifies characters by a simple rule. All glyphs (graphemes) whose base characters are either the underscore (<code>_</code>) or have a Unicode classification beginning with &#39;L&#39; (i.e. letters) or &#39;N&#39; (i.e. numbers) are always literal (i.e. self-matching) in regexes. They must be escaped with a <code>\</code> to make them metasyntactic (in which case that single alphanumeric character is itself metasyntactic, but any immediately following alphanumeric character is not).</p>

<a id="line_137"></a>
<a id="line_138"></a>
<a id="line_139"></a>
<a id="line_140"></a>
<a id="line_141"></a>
<a id="line_142"></a>


<p>All other glyphs--including whitespace--are exactly the opposite: they are always considered metasyntactic (i.e. non-self-matching) and must be escaped or quoted to make them literal. As is traditional, they may be individually escaped with <code>\</code>, but in Perl 6 they may be also quoted as follows.</p>

<a id="line_143"></a>
<a id="line_144"></a>
<a id="line_145"></a>
<a id="line_146"></a>
<a id="line_147"></a>
<a id="line_148"></a>


<p>Sequences of one or more glyphs of either type (i.e. any glyphs at all) may be made literal by placing them inside single quotes. (Double quotes are also allowed, with the same interpolative semantics as the current language in which the regex is lexically embedded.) Quotes create a quantifiable atom, so while</p>

<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-metasyntax/single-quotes.t#L16-L68"><code>S05-metasyntax/single-quotes.t</code> lines <code>16&ndash;68</code></a>
  </p>
</div>
  


<a id="line_149"></a>
<a id="line_150"></a>


<pre>    moose*</pre>

<a id="line_151"></a>
<a id="line_152"></a>


<p>quantifies only the &#39;e&#39; and matches &#34;mooseee&#34;, saying</p>

<a id="line_153"></a>
<a id="line_154"></a>


<pre>    &#39;moose&#39;*</pre>

<a id="line_155"></a>
<a id="line_156"></a>


<p>quantifies the whole string and would match &#34;moosemoose&#34;.</p>

<a id="line_157"></a>
<a id="line_158"></a>


<p>Here is a table that summarizes the distinctions:</p>

<a id="line_159"></a>
<a id="line_160"></a>


<pre>                 Alphanumerics        Non-alphanumerics         Mixed</pre>

<a id="line_161"></a>
<a id="line_162"></a>
<a id="line_163"></a>
<a id="line_164"></a>


<pre> Literal glyphs   a    1    _        \*  \$  \.   \\   \&#39;       K\-9\!
 Metasyntax      \a   \1   \_         *   $   .    \    &#39;      \K-\9!
 Quoted glyphs   &#39;a&#39;  &#39;1&#39;  &#39;_&#39;       &#39;*&#39; &#39;$&#39; &#39;.&#39; &#39;\\&#39; &#39;\&#39;&#39;     &#39;K-9!&#39;</pre>

<a id="line_165"></a>
<a id="line_166"></a>
<a id="line_167"></a>
<a id="line_168"></a>


<p>In other words, identifier glyphs are literal (or metasyntactic when escaped), non-identifier glyphs are metasyntactic (or literal when escaped), and single quotes make everything inside them literal.</p>

<a id="line_169"></a>
<a id="line_170"></a>
<a id="line_171"></a>
<a id="line_172"></a>
<a id="line_173"></a>
<a id="line_174"></a>
<a id="line_175"></a>
<a id="line_176"></a>


<p>Note, however, that not all non-identifier glyphs are currently meaningful as metasyntax in Perl 6 regexes (e.g. <code>\1</code> <code>\_</code> <code>-</code> <code>!</code>). It is more accurate to say that all unescaped non-identifier glyphs are <i>potential</i> metasyntax, and reserved for future use. If you use such a sequence, a helpful compile-time error is issued indicating that you either need to quote the sequence or define a new operator to recognize it.</p>

<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-metasyntax/unknown.t#L6-L47"><code>S05-metasyntax/unknown.t</code> lines <code>6&ndash;47</code></a>
  </p>
</div>
  


<a id="line_177"></a>
<a id="line_178"></a>
<a id="line_179"></a>
<a id="line_180"></a>


<p>The semicolon character is specifically reserved as a non-meaningful metacharacter; if an unquoted semicolon is seen, the compiler will complain that the regex is missing its terminator.</p>

<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-metasyntax/regex.t#L96-L286"><code>S05-metasyntax/regex.t</code> lines <code>96&ndash;286</code></a>
  </p>
</div>
  


<a id="line_181"></a>
<a id="line_182"></a>
<a id="line_183"></a>
<a id="line_184"></a>
<a id="line_185"></a>
<a id="line_186"></a>
<a id="line_187"></a>
<a id="line_188"></a>
<a id="line_189"></a>
<a id="line_190"></a>


<h1><a class='u' href='#___top' title='click to go to top of document'
name="Modifiers"
>Modifiers</a></h1>

<ul>
<li>The extended syntax (<code>/x</code>) is no longer required...it&#39;s the default. (In fact, it&#39;s pretty much mandatory--the only way to get back to the old syntax is with the <code>:Perl5</code>/<code>:P5</code> modifier.)
<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-modifier/perl5_4.t#L7-L119"><code>S05-modifier/perl5_4.t</code> lines <code>7&ndash;119</code></a>
  </p>
</div>
  


<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-modifier/perl5_2.t#L7-L119"><code>S05-modifier/perl5_2.t</code> lines <code>7&ndash;119</code></a>
  </p>
</div>
  


<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-modifier/perl5_9.t#L7-L107"><code>S05-modifier/perl5_9.t</code> lines <code>7&ndash;107</code></a>
  </p>
</div>
  


<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-modifier/perl5_1.t#L7-L119"><code>S05-modifier/perl5_1.t</code> lines <code>7&ndash;119</code></a>
  </p>
</div>
  


<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-modifier/perl5_8.t#L7-L128"><code>S05-modifier/perl5_8.t</code> lines <code>7&ndash;128</code></a>
  </p>
</div>
  


<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-modifier/perl5_5.t#L7-L125"><code>S05-modifier/perl5_5.t</code> lines <code>7&ndash;125</code></a>
  </p>
</div>
  


<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-modifier/perl5_7.t#L7-L119"><code>S05-modifier/perl5_7.t</code> lines <code>7&ndash;119</code></a>
  </p>
</div>
  


<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-modifier/perl5_6.t#L7-L130"><code>S05-modifier/perl5_6.t</code> lines <code>7&ndash;130</code></a>
  </p>
</div>
  


<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-modifier/perl5_3.t#L7-L119"><code>S05-modifier/perl5_3.t</code> lines <code>7&ndash;119</code></a>
  </p>
</div>
  


<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-modifier/perl5_0.t#L9-L113"><code>S05-modifier/perl5_0.t</code> lines <code>9&ndash;113</code></a>
  </p>
</div>
  


<a id="line_191"></a>
<a id="line_192"></a>
<a id="line_193"></a>
<a id="line_194"></a>
<a id="line_195"></a>

</li>

<li>There are no <code>/s</code> or <code>/m</code> modifiers (changes to the meta-characters replace them - see below).
<a id="line_196"></a>
<a id="line_197"></a>
<a id="line_198"></a>
<a id="line_199"></a>

</li>

<li>There is no <code>/e</code> evaluation modifier on substitutions; instead use:
<a id="line_200"></a>
<a id="line_201"></a>


<pre>     s/pattern/{ doit() }/</pre>

<a id="line_202"></a>
<a id="line_203"></a>


<p>or:</p>

<a id="line_204"></a>
<a id="line_205"></a>


<pre>     s[pattern] = doit()</pre>

<a id="line_206"></a>
<a id="line_207"></a>


<p>Instead of <code>/ee</code> say:</p>

<a id="line_208"></a>
<a id="line_209"></a>


<pre>     s/pattern/{ EVAL doit() }/</pre>

<a id="line_210"></a>
<a id="line_211"></a>


<p>or:</p>

<a id="line_212"></a>
<a id="line_213"></a>


<pre>     s[pattern] = doit().EVAL</pre>

<a id="line_214"></a>
<a id="line_215"></a>
<a id="line_216"></a>
<a id="line_217"></a>

</li>

<li>Modifiers are now placed as adverbs at the <i>start</i> of a match/substitution:
<a id="line_218"></a>
<a id="line_219"></a>


<pre>     m:g:i/\s* (\w*) \s* ,?/;</pre>

<a id="line_220"></a>
<a id="line_221"></a>
<a id="line_222"></a>
<a id="line_223"></a>
<a id="line_224"></a>


<p>Every modifier must start with its own colon. The delimiter must be separated from the final modifier by whitespace if it would otherwise be taken as an argument to the preceding modifier (which is true if and only if the next character is a left parenthesis.)</p>

<a id="line_225"></a>
<a id="line_226"></a>
<a id="line_227"></a>
<a id="line_228"></a>

</li>

<li>The single-character modifiers also have longer versions:
<a id="line_229"></a>
<a id="line_230"></a>
<a id="line_231"></a>
<a id="line_232"></a>
<a id="line_233"></a>


<pre>         :i        :ignorecase
         :m        :ignoremark
         :g        :global
         :r        :ratchet</pre>

<a id="line_234"></a>
<a id="line_235"></a>
<a id="line_236"></a>
<a id="line_237"></a>
<a id="line_238"></a>
<a id="line_239"></a>
<a id="line_240"></a>
<a id="line_241"></a>
<a id="line_242"></a>

</li>

<li>The <code>:i</code> (or <code>:ignorecase</code>) modifier causes case distinctions to be ignored in its lexical scope, but not in its dynamic scope. That is, subrules always use their own case settings. The amount of case folding depends on the current context. In byte and codepoint mode, level 1 case folding is required (as defined in TR18 section 2.4). In grapheme mode level 2 is required.
<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-modifier/ignorecase.t#L24-L138"><code>S05-modifier/ignorecase.t</code> lines <code>24&ndash;138</code></a>
  </p>
</div>
  


<a id="line_243"></a>
<a id="line_244"></a>
<a id="line_245"></a>
<a id="line_246"></a>
<a id="line_247"></a>


<p>The <code>:ii</code> (or <code>:samecase</code>) variant may be used on a substitution to change the substituted string to the same case pattern as the matched string. It implies the same pattern semantics as <code>:i</code> above, so it is not necessary to put both <code>:i</code> and <code>:ii</code>.</p>

<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-modifier/ii.t#L6-L28"><code>S05-modifier/ii.t</code> lines <code>6&ndash;28</code></a>
  </p>
</div>
  


<a id="line_248"></a>
<a id="line_249"></a>
<a id="line_250"></a>
<a id="line_251"></a>
<a id="line_252"></a>
<a id="line_253"></a>
<a id="line_254"></a>
<a id="line_255"></a>
<a id="line_256"></a>
<a id="line_257"></a>
<a id="line_258"></a>
<a id="line_259"></a>


<p>If the pattern is matched without the <code>:sigspace</code> modifier, case info is carried across on a character by character basis. If the right string is longer than the left one, the case of the final character is replicated. Titlecase is carried across if possible regardless of whether the resulting letter is at the beginning of a word or not; if there is no titlecase character available, the corresponding uppercase character is used. (This policy can be modified within a lexical scope by a language-dependent Unicode declaration to substitute titlecase according to the orthographic rules of the specified language.) Characters that carry no case information leave their corresponding replacement character unchanged.</p>

<a id="line_260"></a>
<a id="line_261"></a>
<a id="line_262"></a>
<a id="line_263"></a>
<a id="line_264"></a>
<a id="line_265"></a>
<a id="line_266"></a>
<a id="line_267"></a>
<a id="line_268"></a>
<a id="line_269"></a>


<p>If the pattern is matched with <code>:sigspace</code>, then a slightly smarter algorithm is used which attempts to determine if there is a uniform capitalization policy over each matched word, and applies the same policy to each replacement word. If there doesn&#39;t seem to be a uniform policy on the left, the policy for each word is carried over word by word, with the last pattern word replicated if necessary. If a word does not appear to have a recognizable policy, the replacement word is translated character for character as in the non-sigspace case. Recognized policies include:</p>

<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-modifier/ii.t#L29-L75"><code>S05-modifier/ii.t</code> lines <code>29&ndash;75</code></a>
  </p>
</div>
  


<a id="line_270"></a>
<a id="line_271"></a>
<a id="line_272"></a>
<a id="line_273"></a>
<a id="line_274"></a>


<pre>    lc()
    uc()
    tc()
    tclc()</pre>

<a id="line_275"></a>
<a id="line_276"></a>
<a id="line_277"></a>
<a id="line_278"></a>


<p>In any case, only the officially matched string part of the pattern match counts, so any sort of lookahead or contextual matching is not included in the analysis.</p>

<a id="line_279"></a>
<a id="line_280"></a>
<a id="line_281"></a>
<a id="line_282"></a>
<a id="line_283"></a>
<a id="line_284"></a>
<a id="line_285"></a>
<a id="line_286"></a>
<a id="line_287"></a>
<a id="line_288"></a>
<a id="line_289"></a>
<a id="line_290"></a>

</li>

<li>The <code>:m</code> (or <code>:ignoremark</code>) modifier scopes exactly like <code>:ignorecase</code> except that it ignores marks (accents and such) instead of case. It is equivalent to taking each grapheme (in both target and pattern), converting both to NFD (maximally decomposed) and then comparing the two base characters (Unicode non-mark characters) while ignoring any trailing mark characters. The mark characters are ignored only for the purpose of determining the truth of the assertion; the actual text matched includes all ignored characters, including any that follow the final base character.
<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-modifier/ignoremark.t#L14-L81"><code>S05-modifier/ignoremark.t</code> lines <code>14&ndash;81</code></a>
  </p>
</div>
  


<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-modifier/ignorecase-and-ignoremark.t#L15-L53"><code>S05-modifier/ignorecase-and-ignoremark.t</code> lines <code>15&ndash;53</code></a>
  </p>
</div>
  


<a id="line_291"></a>
<a id="line_292"></a>
<a id="line_293"></a>
<a id="line_294"></a>
<a id="line_295"></a>


<p>The <code>:mm</code> (or <code>:samemark</code>) variant may be used on a substitution to change the substituted string to the same mark/accent pattern as the matched string. It implies the same pattern semantics as <code>:m</code> above, so it is not necessary to put both <code>:m</code> and <code>:mm</code>.</p>

<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-modifier/samemark.t#L9-L43"><code>S05-modifier/samemark.t</code> lines <code>9&ndash;43</code></a>
  </p>
</div>
  


<a id="line_296"></a>
<a id="line_297"></a>
<a id="line_298"></a>
<a id="line_299"></a>
<a id="line_300"></a>
<a id="line_301"></a>


<p>Mark info is carried across on a character by character basis. If the right string is longer than the left one, the remaining characters are substituted without any modification. (Note that NFD/NFC distinctions are usually immaterial, since Perl encapsulates that in grapheme mode.) Under <code>:sigspace</code> the preceding rules are applied word by word.</p>

<a id="line_302"></a>
<a id="line_303"></a>
<a id="line_304"></a>
<a id="line_305"></a>
<a id="line_306"></a>

</li>

<li>The <code>:c</code> (or <code>:continue</code>) modifier causes the pattern to continue scanning from the specified position (defaulting to <code>($/ ?? $/.to !! 0)</code>):
<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-modifier/continue.t#L6-L55"><code>S05-modifier/continue.t</code> lines <code>6&ndash;55</code></a>
  </p>
</div>
  


<a id="line_307"></a>
<a id="line_308"></a>


<pre>     m:c($p)/ pattern /     # start scanning at position $p</pre>

<a id="line_309"></a>
<a id="line_310"></a>
<a id="line_311"></a>
<a id="line_312"></a>


<p>Note that this does not automatically anchor the pattern to the starting location. (Use <code>:p</code> for that.) The pattern you supply to <code>split</code> has an implicit <code>:c</code> modifier.</p>

<a id="line_313"></a>
<a id="line_314"></a>
<a id="line_315"></a>
<a id="line_316"></a>
<a id="line_317"></a>

</li>

<li>The <code>:p</code> (or <code>:pos</code>) modifier causes the pattern to try to match only at the specified string position:
<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-modifier/pos.t#L13-L109"><code>S05-modifier/pos.t</code> lines <code>13&ndash;109</code></a>
  </p>
</div>
  


<a id="line_318"></a>
<a id="line_319"></a>


<pre>     m:pos($p)/ pattern /  # match at position $p</pre>

<a id="line_320"></a>
<a id="line_321"></a>
<a id="line_322"></a>
<a id="line_323"></a>
<a id="line_324"></a>
<a id="line_325"></a>


<p>If the argument is omitted, it defaults to <code>($/ ?? $/.to !! 0)</code>. (Unlike in Perl 5, the string itself has no clue where its last match ended.) All subrule matches are implicitly passed their starting position. Likewise, the pattern you supply to a Perl macro&#39;s <code>is parsed</code> trait has an implicit <code>:p</code> modifier.</p>

<a id="line_326"></a>
<a id="line_327"></a>


<p>Note that</p>

<a id="line_328"></a>
<a id="line_329"></a>


<pre>     m:c($p)/pattern/</pre>

<a id="line_330"></a>
<a id="line_331"></a>


<p>is roughly equivalent to</p>

<a id="line_332"></a>
<a id="line_333"></a>


<pre>     m:p($p)/.*? &#60;( pattern )&#62; /</pre>

<a id="line_334"></a>
<a id="line_335"></a>
<a id="line_336"></a>
<a id="line_337"></a>


<p>All of <code>:g</code>, <code>:ov</code>, <code>:nth</code>, and <code>:x</code> are incompatible with <code>:p</code> and will fail, recommending use of <code>:c</code> instead. The <code>:ex</code> modifier is allowed but will produce only matches at that position.</p>

<a id="line_338"></a>
<a id="line_339"></a>
<a id="line_340"></a>
<a id="line_341"></a>
<a id="line_342"></a>
<a id="line_343"></a>
<a id="line_344"></a>
<a id="line_345"></a>
<a id="line_346"></a>
<a id="line_347"></a>
<a id="line_348"></a>

</li>

<li>The new <code>:s</code> (<code>:sigspace</code>) modifier causes certain whitespace sequences to be considered &#34;significant&#34;; they are replaced by a whitespace matching rule, <code>&#60;.ws&#62;</code>. Only whitespace sequences immediately following a matching construct (atom, quantified atom, or assertion) are eligible. Initial whitespace is ignored at the front of any regex, to make it easy to write rules that can participate in longest-token-matching alternations. Trailing space inside the regex delimiters is significant.
<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-grammar/ws.t#L5-L34"><code>S05-grammar/ws.t</code> lines <code>5&ndash;34</code></a>
  </p>
</div>
  


<a id="line_349"></a>
<a id="line_350"></a>


<p>That is,</p>

<a id="line_351"></a>
<a id="line_352"></a>


<pre>     m:s/ next cmd &#39;=&#39;   &#60;condition&#62;/</pre>

<a id="line_353"></a>
<a id="line_354"></a>


<p>is the same as:</p>

<a id="line_355"></a>
<a id="line_356"></a>


<pre>     m/ next &#60;.ws&#62; cmd &#60;.ws&#62; &#39;=&#39; &#60;.ws&#62; &#60;condition&#62;/</pre>

<a id="line_357"></a>
<a id="line_358"></a>


<p>which is effectively the same as:</p>

<a id="line_359"></a>
<a id="line_360"></a>


<pre>     m/ next \s+ cmd \s* &#39;=&#39; \s* &#60;condition&#62;/</pre>

<a id="line_361"></a>
<a id="line_362"></a>


<p>But in the case of</p>

<a id="line_363"></a>
<a id="line_364"></a>


<pre>     m:s{(a|\*) (b|\+)}</pre>

<a id="line_365"></a>
<a id="line_366"></a>


<p>or equivalently,</p>

<a id="line_367"></a>
<a id="line_368"></a>


<pre>     m { (a|\*) &#60;.ws&#62; (b|\+) }</pre>

<a id="line_369"></a>
<a id="line_370"></a>
<a id="line_371"></a>
<a id="line_372"></a>


<p><code>&#60;.ws&#62;</code> can&#39;t decide what to do until it sees the data. It still does the right thing. If not, define your own <code>ws</code> and <code>:sigspace</code> will use that.</p>

<a id="line_373"></a>
<a id="line_374"></a>
<a id="line_375"></a>
<a id="line_376"></a>
<a id="line_377"></a>
<a id="line_378"></a>


<p>Whitespace is ignored not just at the front of any rule that might participate in longest-token matching, but in the front of any alternative within an explicit alternation as well, for the same reason. If you want to match sigspace before a set of alternatives, place your whitespace outside of the brackets containing the alternation.</p>

<a id="line_379"></a>
<a id="line_380"></a>


<p>When you write</p>

<a id="line_381"></a>
<a id="line_382"></a>


<pre>    rule TOP { ^ &#60;stuff&#62; $ }</pre>

<a id="line_383"></a>
<a id="line_384"></a>


<p>this is the same as</p>

<a id="line_385"></a>
<a id="line_386"></a>


<pre>    token TOP { ^ &#60;.ws&#62; &#60;stuff&#62; &#60;.ws&#62; $ &#60;.ws&#62; }</pre>

<a id="line_387"></a>
<a id="line_388"></a>
<a id="line_389"></a>


<p>but note that the final <code>&#60;.ws&#62;</code> always matches the null string, since <code>$</code> asserts end of string. Also, if your <code>TOP</code> rule does not anchor with <code>^</code>, it might not match initial whitespace.</p>

<a id="line_390"></a>
<a id="line_391"></a>


<p>Specifically, the following constructs turn following whitespace into sigspace:</p>

<a id="line_392"></a>
<a id="line_393"></a>
<a id="line_394"></a>
<a id="line_395"></a>
<a id="line_396"></a>
<a id="line_397"></a>
<a id="line_398"></a>
<a id="line_399"></a>
<a id="line_400"></a>


<pre>    any atom or quantified atom
    $foo @bar
    &#39;a&#39; &#34;$b&#34;
    ^ $ ^^ $$
    (...) [...] &#60;...&#62; as a whole atoms
    (...)* [...]* &#60;...&#62;* as quantified atoms
    &#60;( and )&#62;
    &#171; and &#187; (but don&#39;t use &#171; that way!)</pre>

<a id="line_401"></a>
<a id="line_402"></a>


<p>and these do not:</p>

<a id="line_403"></a>
<a id="line_404"></a>
<a id="line_405"></a>
<a id="line_406"></a>
<a id="line_407"></a>
<a id="line_408"></a>
<a id="line_409"></a>


<pre>    opening ( or [
    | or ||
    &#38; or &#38;&#38;
    ** % or %%
    :foo declarations, including :my and :sigspace itself
    {...}</pre>

<a id="line_410"></a>
<a id="line_411"></a>
<a id="line_412"></a>


<p>When we say sigspace can follow either an atom or a quantified atom, we mean that it can come between an atom and its quantifier:</p>

<a id="line_413"></a>
<a id="line_414"></a>


<pre>    ms/ &#60;atom&#62; * /      # means / [&#60;atom&#62;&#60;.ws&#62;]* /</pre>

<a id="line_415"></a>
<a id="line_416"></a>
<a id="line_417"></a>


<p>(If each atom matches whitespace, then it doesn&#39;t need to match after the quantifier.)</p>

<a id="line_418"></a>
<a id="line_419"></a>
<a id="line_420"></a>
<a id="line_421"></a>
<a id="line_422"></a>
<a id="line_423"></a>
<a id="line_424"></a>
<a id="line_425"></a>


<p>In general you don&#39;t need to use <code>:sigspace</code> within grammars because the parser rules automatically handle whitespace policy for you. In this context, whitespace often includes comments, depending on how the grammar chooses to define its whitespace rule. Although the default <code>&#60;.ws&#62;</code> subrule recognizes no comment construct, any grammar is free to override the rule. The <code>&#60;.ws&#62;</code> rule is not intended to mean the same thing everywhere.</p>

<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-grammar/ws.t#L6-L34"><code>S05-grammar/ws.t</code> lines <code>6&ndash;34</code></a>
  </p>
</div>
  


<a id="line_426"></a>
<a id="line_427"></a>
<a id="line_428"></a>
<a id="line_429"></a>
<a id="line_430"></a>
<a id="line_431"></a>
<a id="line_432"></a>
<a id="line_433"></a>
<a id="line_434"></a>
<a id="line_435"></a>


<p>It&#39;s also possible to pass an argument to <code>:sigspace</code> specifying a completely different subrule to apply. This can be any rule, it doesn&#39;t have to match whitespace. When discussing this modifier, it is important to distinguish the significant whitespace in the pattern from the &#34;whitespace&#34; being matched, so we&#39;ll call the pattern&#39;s whitespace <i>sigspace</i>, and generally reserve <i>whitespace</i> to indicate whatever <code>&#60;.ws&#62;</code> matches in the current grammar. The correspondence between sigspace and whitespace is primarily metaphorical, which is why the correspondence is both useful and (potentially) confusing.</p>

<a id="line_436"></a>
<a id="line_437"></a>
<a id="line_438"></a>
<a id="line_439"></a>
<a id="line_440"></a>
<a id="line_441"></a>
<a id="line_442"></a>
<a id="line_443"></a>
<a id="line_444"></a>
<a id="line_445"></a>
<a id="line_446"></a>
<a id="line_447"></a>
<a id="line_448"></a>


<p>The <code>:ss</code> (or <code>:samespace</code>) variant may be used on substitutions to do smart space mapping in addition to smart space matching. (That is, <code>:ss</code> implies <code>:s</code>.) For each sigspace-induced call to <code>&#60;ws&#62;</code> on the left, the matched whitespace is copied over to the corresponding slot on the right, as represented by a single whitespace character in the replacement string wherever space replacement is desired. If there are more whitespace slots on the right than the left, those righthand characters remain themselves. If there are not enough whitespace slots on the right to map all the available whitespace slots from the match, the algorithm tries to minimize information loss by randomly splicing &#34;common&#34; whitespace characters out of the list of whitespace. From least valuable to most, the pecking order is:</p>

<a id="line_449"></a>
<a id="line_450"></a>
<a id="line_451"></a>
<a id="line_452"></a>
<a id="line_453"></a>
<a id="line_454"></a>


<pre>    spaces
    tabs
    all other horizontal whitespace, including Unicode
    newlines (including crlf as a unit)
    all other vertical whitespace, including Unicode</pre>

<a id="line_455"></a>
<a id="line_456"></a>
<a id="line_457"></a>
<a id="line_458"></a>
<a id="line_459"></a>


<p>The primary intent of these rules is to minimize format disruption when substitution happens across line boundaries and such. There is, of course, no guarantee that the result will be exactly what a human would do.</p>

<a id="line_460"></a>
<a id="line_461"></a>
<a id="line_462"></a>


<p>The <code>:s</code> modifier is considered sufficiently important that match variants are defined for them:</p>

<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-modifier/sigspace.t#L30-L51"><code>S05-modifier/sigspace.t</code> lines <code>30&ndash;51</code></a>
  </p>
</div>
  


<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-substitution/subst.t#L209-L264"><code>S05-substitution/subst.t</code> lines <code>209&ndash;264</code></a>
  </p>
</div>
  


<a id="line_463"></a>
<a id="line_464"></a>
<a id="line_465"></a>


<pre>    ms/match some words/                        # same as m:sigspace
    ss/match some words/replace those words/    # same as s:samespace</pre>

<a id="line_466"></a>
<a id="line_467"></a>


<p>Note that <code>ss///</code> is defined in terms of <code>:ss</code>, so:</p>

<a id="line_468"></a>
<a id="line_469"></a>
<a id="line_470"></a>


<pre>    $_ = &#34;a b\nc\td&#34;;
    ss/b c d/x y z/;</pre>

<a id="line_471"></a>
<a id="line_472"></a>


<p>ends up with a value of &#34;<code>a x\ny\tz</code>&#34;.</p>

<a id="line_473"></a>
<a id="line_474"></a>
<a id="line_475"></a>
<a id="line_476"></a>

</li>

<li>New modifiers specify Unicode level:
<a id="line_477"></a>
<a id="line_478"></a>
<a id="line_479"></a>
<a id="line_480"></a>
<a id="line_481"></a>


<pre>     m:bytes  / .**2 /       # match two bytes
     m:codes  / .**2 /       # match two codepoints
     m:graphs / .**2 /       # match two language-independent graphemes
     m:chars  / .**2 /       # match two characters at current max level</pre>

<a id="line_482"></a>
<a id="line_483"></a>
<a id="line_484"></a>
<a id="line_485"></a>
<a id="line_486"></a>
<a id="line_487"></a>
<a id="line_488"></a>
<a id="line_489"></a>
<a id="line_490"></a>
<a id="line_491"></a>


<p>There are corresponding pragmas to default to these levels. Note that the <code>:chars</code> modifier is always redundant because dot always matches characters at the highest level allowed in scope. This highest level may be identical to one of the other three levels, or it may be more specific than <code>:graphs</code> when a particular language&#39;s character rules are in use. Note that you may not specify language-dependent character processing without specifying <i>which</i> language you&#39;re depending on. [Conjecture: the <code>:chars</code> modifier could take an argument specifying which language&#39;s rules to use for this match.]</p>

<a id="line_492"></a>
<a id="line_493"></a>
<a id="line_494"></a>
<a id="line_495"></a>
<a id="line_496"></a>
<a id="line_497"></a>

</li>

<li>The new <code>:Perl5</code>/<code>:P5</code> modifier allows Perl 5 regex syntax to be used instead. (It does not go so far as to allow you to put your modifiers at the end.) For instance,
<a id="line_498"></a>
<a id="line_499"></a>


<pre>     m:P5/(?mi)^(?:[a-z]|\d){1,2}(?=\s)/</pre>

<a id="line_500"></a>
<a id="line_501"></a>


<p>is equivalent to the Perl 6 syntax:</p>

<a id="line_502"></a>
<a id="line_503"></a>


<pre>    m/ :i ^^ [ &#60;[a..z]&#62; || \d ] ** 1..2 &#60;?before \s&#62; /</pre>

<a id="line_504"></a>
<a id="line_505"></a>
<a id="line_506"></a>
<a id="line_507"></a>
<a id="line_508"></a>

</li>

<li>Any integer modifier specifies a count. What kind of count is determined by the character that follows.
<a id="line_509"></a>
<a id="line_510"></a>
<a id="line_511"></a>
<a id="line_512"></a>
<a id="line_513"></a>

</li>

<li>If followed by an <code>x</code>, it means repetition. Use <code>:x(4)</code> for the general form. So
<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-modifier/repetition-exhaustive.t#L16-L30"><code>S05-modifier/repetition-exhaustive.t</code> lines <code>16&ndash;30</code></a>
  </p>
</div>
  


<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-modifier/repetition.t#L6-L29"><code>S05-modifier/repetition.t</code> lines <code>6&ndash;29</code></a>
  </p>
</div>
  


<a id="line_514"></a>
<a id="line_515"></a>


<pre>     s:4x [ (&#60;.ident&#62;) &#39;=&#39; (\N+) $$] = &#34;$0 =&#62; $1&#34;;</pre>

<a id="line_516"></a>
<a id="line_517"></a>


<p>is the same as:</p>

<a id="line_518"></a>
<a id="line_519"></a>


<pre>     s:x(4) [ (&#60;.ident&#62;) &#39;=&#39; (\N+) $$] = &#34;$0 =&#62; $1&#34;;</pre>

<a id="line_520"></a>
<a id="line_521"></a>


<p>which is almost the same as:</p>

<a id="line_522"></a>
<a id="line_523"></a>


<pre>     s:c[ (&#60;.ident&#62;) &#39;=&#39; (\N+) $$] = &#34;$0 =&#62; $1&#34; for 1..4;</pre>

<a id="line_524"></a>
<a id="line_525"></a>
<a id="line_526"></a>
<a id="line_527"></a>


<p>except that the string is unchanged unless all four matches are found. However, ranges are allowed, so you can say <code>:x(1..4)</code> to change anywhere from one to four matches.</p>

<a id="line_528"></a>
<a id="line_529"></a>
<a id="line_530"></a>
<a id="line_531"></a>
<a id="line_532"></a>

</li>

<li>If the number is followed by an <code>st</code>, <code>nd</code>, <code>rd</code>, or <code>th</code>, it means find the <i>N</i>th occurrence. Use <code>:nth(3)</code> for the general form. So
<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-modifier/counted.t#L13-L259"><code>S05-modifier/counted.t</code> lines <code>13&ndash;259</code></a>
  </p>
</div>
  


<a id="line_533"></a>
<a id="line_534"></a>


<pre>     s:3rd/(\d+)/@data[$0]/;</pre>

<a id="line_535"></a>
<a id="line_536"></a>


<p>is the same as</p>

<a id="line_537"></a>
<a id="line_538"></a>


<pre>     s:nth(3)/(\d+)/@data[$0]/;</pre>

<a id="line_539"></a>
<a id="line_540"></a>


<p>which is the same as:</p>

<a id="line_541"></a>
<a id="line_542"></a>


<pre>     m/(\d+)/ &#38;&#38; m:c/(\d+)/ &#38;&#38; s:c/(\d+)/@data[$0]/;</pre>

<a id="line_543"></a>
<a id="line_544"></a>
<a id="line_545"></a>
<a id="line_546"></a>


<p>The argument to <code>:nth</code> is allowed to be a list of integers, but such a list should be monotonically increasing. (Values which are less than or equal to any previous value will be ignored.) So:</p>

<a id="line_547"></a>


<a id="line_548"></a>
<a id="line_549"></a>
<a id="line_550"></a>


<pre>    :nth(2,4,6...*)    # return only even matches
    :nth(1,1,*+*...*)  # match only at 1,2,3,5,8,13...</pre>

<a id="line_551"></a>
<a id="line_552"></a>
<a id="line_553"></a>


<p>This option is no longer required to support smartmatching. You can grep a list of integers if you really need that capability:</p>

<a id="line_554"></a>
<a id="line_555"></a>


<pre>    :nth(grep *.oracle, 1..*)</pre>

<a id="line_556"></a>
<a id="line_557"></a>
<a id="line_558"></a>
<a id="line_559"></a>
<a id="line_560"></a>
<a id="line_561"></a>


<p>If both <code>:nth</code> and <code>:x</code> are present, the matching routine looks for submatches that match with <code>:nth</code>. If the number of post-nth matches is compatible with the constraint in <code>:x</code>, the whole match succeeds with the highest possible number of submatches. The combination of <code>:nth</code> and <code>:x</code> typically only makes sense if <code>:nth</code> is not a single scalar.</p>

<a id="line_562"></a>
<a id="line_563"></a>
<a id="line_564"></a>
<a id="line_565"></a>
<a id="line_566"></a>
<a id="line_567"></a>
<a id="line_568"></a>
<a id="line_569"></a>
<a id="line_570"></a>

</li>

<li>With the new <code>:ov</code> (<code>:overlap</code>) modifier, the current regex will match at all possible character positions (including overlapping) and return all matches in list context, or a disjunction of matches in item context. The first match at any position is returned. The matches are guaranteed to be returned in left-to-right order with respect to the starting positions.
<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-modifier/overlapping.t#L16-L67"><code>S05-modifier/overlapping.t</code> lines <code>16&ndash;67</code></a>
  </p>
</div>
  


<a id="line_571"></a>
<a id="line_572"></a>


<pre>     $str = &#34;abracadabra&#34;;</pre>

<a id="line_573"></a>
<a id="line_574"></a>
<a id="line_575"></a>
<a id="line_576"></a>


<pre>     if $str ~~ m:overlap/ a (.*) a / {
         @substrings = slice @();    # bracadabr cadabr dabr br
     }</pre>

<a id="line_577"></a>
<a id="line_578"></a>
<a id="line_579"></a>
<a id="line_580"></a>
<a id="line_581"></a>
<a id="line_582"></a>

</li>

<li>With the new <code>:ex</code> (<code>:exhaustive</code>) modifier, the current regex will match every possible way (including overlapping) and return a list of all matches.
<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-modifier/exhaustive.t#L10-L147"><code>S05-modifier/exhaustive.t</code> lines <code>10&ndash;147</code></a>
  </p>
</div>
  


<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-modifier/repetition-exhaustive.t#L17-L30"><code>S05-modifier/repetition-exhaustive.t</code> lines <code>17&ndash;30</code></a>
  </p>
</div>
  


<a id="line_583"></a>
<a id="line_584"></a>
<a id="line_585"></a>
<a id="line_586"></a>
<a id="line_587"></a>
<a id="line_588"></a>
<a id="line_589"></a>
<a id="line_590"></a>


<p>The matches are guaranteed to be returned in left-to-right order with respect to the starting positions. The order within each starting position is not guaranteed and may depend on the nature of both the pattern and the matching engine. (Conjecture: or we could enforce backtracking engine semantics. Or we could guarantee no order at all unless the pattern starts with &#34;::&#34; or some such to suppress DFAish solutions.)</p>

<a id="line_591"></a>
<a id="line_592"></a>


<pre>     $str = &#34;abracadabra&#34;;</pre>

<a id="line_593"></a>
<a id="line_594"></a>
<a id="line_595"></a>
<a id="line_596"></a>


<pre>     if $str ~~ m:exhaustive/ a (.*?) a / {
         say &#34;@()&#34;;    # br brac bracad bracadabr c cad cadabr d dabr br
     }</pre>

<a id="line_597"></a>
<a id="line_598"></a>
<a id="line_599"></a>


<p>Note that the <code>~~</code> above can return as soon as the first match is found, and the rest of the matches may be performed lazily by <code>@()</code>.</p>

<a id="line_600"></a>
<a id="line_601"></a>
<a id="line_602"></a>
<a id="line_603"></a>
<a id="line_604"></a>
<a id="line_605"></a>
<a id="line_606"></a>
<a id="line_607"></a>
<a id="line_608"></a>
<a id="line_609"></a>
<a id="line_610"></a>

</li>

<li>The new <code>:rw</code> modifier causes this regex to <i>claim</i> the current string for modification rather than assuming copy-on-write semantics. All the captures in <code>$/</code> become lvalues into the string, such that if you modify, say, <code>$1</code>, the original string is modified in that location, and the positions of all the other fields modified accordingly (whatever that means). In the absence of this modifier (especially if it isn&#39;t implemented yet, or is never implemented), all pieces of <code>$/</code> are considered copy-on-write, if not read-only.
<a id="line_611"></a>
<a id="line_612"></a>
<a id="line_613"></a>


<p>[Conjecture: this should really associate a pattern with a string variable, not a (presumably immutable) string value.]</p>

<a id="line_614"></a>
<a id="line_615"></a>
<a id="line_616"></a>
<a id="line_617"></a>
<a id="line_618"></a>
<a id="line_619"></a>
<a id="line_620"></a>
<a id="line_621"></a>
<a id="line_622"></a>
<a id="line_623"></a>
<a id="line_624"></a>

</li>

<li>The new <code>:r</code> or <code>:ratchet</code> modifier causes this regex to not backtrack by default. (Generally you do not use this modifier directly, since it&#39;s implied by <code>token</code> and <code>rule</code> declarations.) The effect of this modifier is to imply a <code>:</code> after every atom, including but not limited to <code>*</code>, <code>+</code>, and <code>?</code> quantifiers, as well as alternations. Explicit backtracking modifiers on quantified atoms, such as <code>**</code>, will override this. (Note: for portions of patterns subject to longest-token analysis, a <code>:</code> is ignored in any case, since there will be no backtracking necessary.)
<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-modifier/ratchet.t#L5-L27"><code>S05-modifier/ratchet.t</code> lines <code>5&ndash;27</code></a>
  </p>
</div>
  


<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-mass/rx.t#L86-L93"><code>S05-mass/rx.t</code> lines <code>86&ndash;93</code></a>
  </p>
</div>
  


<a id="line_625"></a>
<a id="line_626"></a>
<a id="line_627"></a>
<a id="line_628"></a>
<a id="line_629"></a>

</li>

<li>The <code>:i</code>, <code>:m</code>, <code>:r</code>, <code>:s</code>, <code>:dba</code>, <code>:Perl5</code>, and Unicode-level modifiers can be placed inside the regex (and are lexically scoped):
<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-modifier/ignorecase.t#L18-L23"><code>S05-modifier/ignorecase.t</code> lines <code>18&ndash;23</code></a>
  </p>
</div>
  


<a id="line_630"></a>
<a id="line_631"></a>


<pre>     m/:s alignment &#39;=&#39; [:i left|right|cent[er|re]] /</pre>

<a id="line_632"></a>
<a id="line_633"></a>
<a id="line_634"></a>


<p>As with modifiers outside, only parentheses are recognized as valid brackets for args to the adverb. In particular:</p>

<a id="line_635"></a>
<a id="line_636"></a>
<a id="line_637"></a>
<a id="line_638"></a>


<pre>    m/:foo[xxx]/        Parses as :foo [xxx]
    m/:foo{xxx}/        Parses as :foo {xxx}
    m/:foo&#60;xxx&#62;/        Parses as :foo &#60;xxx&#62;</pre>

<a id="line_639"></a>
<a id="line_640"></a>
<a id="line_641"></a>
<a id="line_642"></a>

</li>

<li>User-defined modifiers will be possible:
<a id="line_643"></a>
<a id="line_644"></a>


<pre>         m:fuzzy/pattern/;</pre>

<a id="line_645"></a>
<a id="line_646"></a>
<a id="line_647"></a>
<a id="line_648"></a>

</li>

<li>User-defined modifiers can also take arguments, but only in parentheses:
<a id="line_649"></a>
<a id="line_650"></a>


<pre>         m:fuzzy(&#39;bare&#39;)/pattern/;</pre>

<a id="line_651"></a>
<a id="line_652"></a>
<a id="line_653"></a>
<a id="line_654"></a>

</li>

<li>To use parens for your delimiters you have to separate:
<a id="line_655"></a>
<a id="line_656"></a>


<pre>         m:fuzzy (pattern);</pre>

<a id="line_657"></a>
<a id="line_658"></a>


<p>or you&#39;ll end up with:</p>

<a id="line_659"></a>
<a id="line_660"></a>


<pre>         m:fuzzy(fuzzyargs); pattern ;</pre>

<a id="line_661"></a>
<a id="line_662"></a>
<a id="line_663"></a>
<a id="line_664"></a>
<a id="line_665"></a>
<a id="line_666"></a>
<a id="line_667"></a>
<a id="line_668"></a>
<a id="line_669"></a>

</li>

<li>Any grammar regex is really just a kind of method, and you may declare variables in such a routine using a colon followed by any scope declarator parsed by the Perl 6 grammar, including <code>my</code>, <code>our</code>, <code>state</code>, and <code>constant</code>. (As quasi declarators, <code>temp</code> and <code>let</code> are also recognized.) A single statement (up through a terminating semicolon or line-final closing brace) is parsed as normal Perl 6 code:
<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-modifier/my.t#L5-L87"><code>S05-modifier/my.t</code> lines <code>5&ndash;87</code></a>
  </p>
</div>
  


<a id="line_670"></a>
<a id="line_671"></a>
<a id="line_672"></a>
<a id="line_673"></a>
<a id="line_674"></a>


<pre>    token prove-nondeterministic-parsing {
        :my $threshold = rand;
        &#39;maybe&#39; \s+ &#60;it($threshold)&#62;
    }</pre>

<a id="line_675"></a>
<a id="line_676"></a>
<a id="line_677"></a>
<a id="line_678"></a>
<a id="line_679"></a>


<p>Such declarations do not terminate longest-token-matching, so an otherwise useless declaration may be used as a peg to hang side effects on without changing how the subsequent pattern matches:</p>

<a id="line_680"></a>
<a id="line_681"></a>
<a id="line_682"></a>
<a id="line_683"></a>
<a id="line_684"></a>


<pre>    rule breaker {
        :state $ = say &#34;got here at least once&#34;;
        ...
    }</pre>

<a id="line_685"></a>
<a id="line_686"></a>

</li>
</ul>

<a id="line_687"></a>
<a id="line_688"></a>
<a id="line_689"></a>
<a id="line_690"></a>
<a id="line_691"></a>


<h2><a class='u' href='#___top' title='click to go to top of document'
name="Allowed_modifiers"
>Allowed modifiers</a></h2>

<p>Some modifiers are allowed in all possible places where modifiers can occur, but not all of them.</p>

<a id="line_692"></a>
<a id="line_693"></a>
<a id="line_694"></a>
<a id="line_695"></a>
<a id="line_696"></a>
<a id="line_697"></a>
<a id="line_698"></a>
<a id="line_699"></a>


<p>In general, a modifier that affects the compilation of a regex (like <code>:i</code>) must be known at compile time. A modifier that affects only the calling behaviour, and not the regex itself (eg. <code>:pos</code>, <code>:overlap</code>, <code>:x(4)</code>) may only appear on constructs that involve a call (like <code>m//</code> and <code>s///</code>), and not on <code>rx//</code>. Finally overlapping is disallowed on substitutions, while adverbs that affect modifications (eg. <code>:samecase</code>) are only allowed on substitutions.</p>

<a id="line_700"></a>
<a id="line_701"></a>


<p>These principle result in the following rules:</p>

<a id="line_702"></a>
<a id="line_703"></a>
<a id="line_704"></a>
<a id="line_705"></a>
<a id="line_706"></a>
<a id="line_707"></a>
<a id="line_708"></a>
<a id="line_709"></a>
<a id="line_710"></a>
<a id="line_711"></a>


<ul>
<li>The <code>:ignorecase</code>, <code>:ignoremark</code>, <code>:sigspace</code>, <code>:ratchet</code> and <code>:Perl5</code> modifiers and their short forms are allowed everywhere: inside a regex, and on <code>m//</code>, <code>rx//</code> and <code>s///</code> constructs. An implementation may require that their value is known at compile time, and give a compile-time error message if that is not the case.
<a id="line_712"></a>
<a id="line_713"></a>
<a id="line_714"></a>
<a id="line_715"></a>
<a id="line_716"></a>


<pre>    rx:i/ hello /           # OK
    rx:i(1) /hello/         # OK
    my $i = 1;
    rx:i($i) /hello/        # may error out at compile time</pre>

<a id="line_717"></a>
<a id="line_718"></a>
<a id="line_719"></a>
<a id="line_720"></a>
<a id="line_721"></a>

</li>

<li>The <code>:samecase</code>, <code>:samespace</code> and <code>:samemark</code> modifiers (and their short forms) are only allowed on substitutions (<code>s///</code> and <code>s[] = ...</code>).
<a id="line_722"></a>
<a id="line_723"></a>
<a id="line_724"></a>
<a id="line_725"></a>
<a id="line_726"></a>

</li>

<li>The <code>:overlap</code> and <code>:exhaustive</code> modifiers (and their short forms) are only allowed on matches (ie <code>m//</code>), not on substitutions or regex quotes.
<a id="line_727"></a>
<a id="line_728"></a>
<a id="line_729"></a>
<a id="line_730"></a>
<a id="line_731"></a>
<a id="line_732"></a>

</li>

<li>The <code>:pos</code>, <code>:continue</code>, <code>:x</code> and <code>:nth</code> modifiers and their aliases are only allowed on constructs that involve immediate calls, eg. <code>m//</code> and <code>s///</code> (but not on <code>rx//</code>).
<a id="line_733"></a>
<a id="line_734"></a>
<a id="line_735"></a>
<a id="line_736"></a>

</li>

<li>The <code>:dba</code> adverb is only allowed inside a regex.
<a id="line_737"></a>
<a id="line_738"></a>

</li>
</ul>

<a id="line_739"></a>
<a id="line_740"></a>
<a id="line_741"></a>
<a id="line_742"></a>
<a id="line_743"></a>
<a id="line_744"></a>
<a id="line_745"></a>
<a id="line_746"></a>
<a id="line_747"></a>


<h1><a class='u' href='#___top' title='click to go to top of document'
name="Changed_metacharacters"
>Changed metacharacters</a></h1>

<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-metasyntax/changed.t#L6-L38"><code>S05-metasyntax/changed.t</code> lines <code>6&ndash;38</code></a>
  </p>
</div>
  


<ul>
<li>A dot <code>.</code> now matches <i>any</i> character including newline. (The <code>/s</code> modifier is gone.)
<a id="line_748"></a>
<a id="line_749"></a>
<a id="line_750"></a>
<a id="line_751"></a>
<a id="line_752"></a>
<a id="line_753"></a>
<a id="line_754"></a>
<a id="line_755"></a>

</li>

<li><code>^</code> and <code>$</code> now always match the start/end of a string, like the old <code>\A</code> and <code>\z</code>. (The <code>/m</code> modifier is gone.) On the right side of an embedded <code>~~</code> or <code>!~~</code> operator they always match the start/end of the indicated submatch because that submatch is logically being treated as a separate string.
<a id="line_756"></a>
<a id="line_757"></a>
<a id="line_758"></a>
<a id="line_759"></a>
<a id="line_760"></a>

</li>

<li>A <code>$</code> no longer matches an optional preceding <code>\n</code> so it&#39;s necessary to say <code>\n?$</code> if that&#39;s what you mean.
<a id="line_761"></a>
<a id="line_762"></a>
<a id="line_763"></a>
<a id="line_764"></a>
<a id="line_765"></a>

</li>

<li><code>\n</code> now matches a logical (platform independent) newline, not just <code>\x0a</code>. See TR18 section 1.6 for a list of logical newlines.
<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-metachars/newline.t#L13-L37"><code>S05-metachars/newline.t</code> lines <code>13&ndash;37</code></a>
  </p>
</div>
  


<a id="line_766"></a>
<a id="line_767"></a>
<a id="line_768"></a>
<a id="line_769"></a>

</li>

<li>The <code>\A</code>, <code>\Z</code>, and <code>\z</code> metacharacters are gone.
<a id="line_770"></a>
<a id="line_771"></a>

</li>
</ul>

<a id="line_772"></a>
<a id="line_773"></a>
<a id="line_774"></a>
<a id="line_775"></a>
<a id="line_776"></a>
<a id="line_777"></a>
<a id="line_778"></a>
<a id="line_779"></a>


<h1><a class='u' href='#___top' title='click to go to top of document'
name="New_metacharacters"
>New metacharacters</a></h1>

<ul>
<li>Because <code>/x</code> is default:
<a id="line_780"></a>
<a id="line_781"></a>
<a id="line_782"></a>
<a id="line_783"></a>
<a id="line_784"></a>
<a id="line_785"></a>
<a id="line_786"></a>
<a id="line_787"></a>
<a id="line_788"></a>


<ul>
<li>An unquoted <code>#</code> now always introduces a comment. If followed by a backtick and an opening bracket character, it introduces an embedded comment that terminates with the closing bracket. Otherwise the comment terminates at the newline.
<a id="line_789"></a>
<a id="line_790"></a>
<a id="line_791"></a>
<a id="line_792"></a>
<a id="line_793"></a>

</li>

<li>Whitespace is now always metasyntactic, i.e. used only for layout and not matched literally (but see the <code>:sigspace</code> modifier described above).
<a id="line_794"></a>
<a id="line_795"></a>

</li>
</ul>

<a id="line_796"></a>
<a id="line_797"></a>
<a id="line_798"></a>
<a id="line_799"></a>
<a id="line_800"></a>
<a id="line_801"></a>
<a id="line_802"></a>
<a id="line_803"></a>
<a id="line_804"></a>

</li>

<li><code>^^</code> and <code>$$</code> match line beginnings and endings. (The <code>/m</code> modifier is gone.) They are both zero-width assertions. <code>$$</code> matches before any <code>\n</code> (logical newline), and also at the end of the string if the final character was <i>not</i> a <code>\n</code>. <code>^^</code> always matches the beginning of the string and after any <code>\n</code> that is not the final character in the string.
<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-metachars/line-anchors.t#L15-L59"><code>S05-metachars/line-anchors.t</code> lines <code>15&ndash;59</code></a>
  </p>
</div>
  


<a id="line_805"></a>
<a id="line_806"></a>
<a id="line_807"></a>
<a id="line_808"></a>
<a id="line_809"></a>
<a id="line_810"></a>

</li>

<li><code>.</code> matches an <i>anything</i>, while <code>\N</code> matches an <i>anything except what <code>\n</code> matches</i>. (The <code>/s</code> modifier is gone.) In particular, <code>\N</code> matches neither carriage return nor line feed.
<a id="line_811"></a>
<a id="line_812"></a>
<a id="line_813"></a>
<a id="line_814"></a>
<a id="line_815"></a>
<a id="line_816"></a>
<a id="line_817"></a>

</li>

<li>The new <code>&#38;</code> metacharacter separates conjunctive terms. The patterns on either side must match with the same beginning and end point. Note: if you don&#39;t want your two terms to end at the same point, then you really want to use a lookahead instead.
<a id="line_818"></a>
<a id="line_819"></a>
<a id="line_820"></a>
<a id="line_821"></a>
<a id="line_822"></a>
<a id="line_823"></a>
<a id="line_824"></a>
<a id="line_825"></a>
<a id="line_826"></a>
<a id="line_827"></a>


<p>As with the disjunctions <code>|</code> and <code>||</code>, conjunctions come in both <code>&#38;</code> and <code>&#38;&#38;</code> forms. The <code>&#38;</code> form is considered declarative rather than procedural; it allows the compiler and/or the run-time system to decide which parts to evaluate first, and it is erroneous to assume either order happens consistently. The <code>&#38;&#38;</code> form guarantees left-to-right order, and backtracking makes the right argument vary faster than the left. In other words, <code>&#38;&#38;</code> and <code>||</code> establish sequence points. The left side may be backtracked into when backtracking is allowed into the construct as a whole.</p>

<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-metasyntax/sequential-alternation.t#L5-L21"><code>S05-metasyntax/sequential-alternation.t</code> lines <code>5&ndash;21</code></a>
  </p>
</div>
  


<a id="line_828"></a>
<a id="line_829"></a>
<a id="line_830"></a>
<a id="line_831"></a>
<a id="line_832"></a>


<p>The <code>&#38;</code> operator is list associative like <code>|</code>, but has slightly tighter precedence. Likewise <code>&#38;&#38;</code> has slightly tighter precedence than <code>||</code>. As with the normal junctional and short-circuit operators, <code>&#38;</code> and <code>|</code> are both tighter than <code>&#38;&#38;</code> and <code>||</code>.</p>

<a id="line_833"></a>
<a id="line_834"></a>
<a id="line_835"></a>
<a id="line_836"></a>
<a id="line_837"></a>
<a id="line_838"></a>
<a id="line_839"></a>
<a id="line_840"></a>

</li>

<li>The <code>~~</code> and <code>!~~</code> operators cause a submatch to be performed on whatever was matched by the variable or atom on the left. String anchors consider that submatch to be the entire string. So, for instance, you can ask to match any identifier that does not contain the word &#34;moose&#34;:
<a id="line_841"></a>
<a id="line_842"></a>


<pre>    &#60;ident&#62; !~~ &#39;moose&#39;</pre>

<a id="line_843"></a>
<a id="line_844"></a>


<p>In contrast</p>

<a id="line_845"></a>
<a id="line_846"></a>


<pre>    &#60;ident&#62; !~~ ^ &#39;moose&#39; $</pre>

<a id="line_847"></a>
<a id="line_848"></a>
<a id="line_849"></a>
<a id="line_850"></a>
<a id="line_851"></a>
<a id="line_852"></a>
<a id="line_853"></a>


<p>would allow any identifier (including any identifier containing &#34;moose&#34; as a substring) as long as the identifier as a whole is not equal to &#34;moose&#34;. (Note the anchors, which attach the submatch to the beginning and end of the identifier as if that were the entire match.) When used as part of a longer match, for clarity it might be good to use extra brackets:</p>

<a id="line_854"></a>
<a id="line_855"></a>


<pre>    [ &#60;ident&#62; !~~ ^ &#39;moose&#39; $ ]</pre>

<a id="line_856"></a>
<a id="line_857"></a>
<a id="line_858"></a>
<a id="line_859"></a>


<p>The precedence of <code>~~</code> and <code>!~~</code> fits in between the junctional and sequential versions of the logical operators just as it does in normal Perl expressions (see S03). Hence</p>

<a id="line_860"></a>
<a id="line_861"></a>


<pre>    &#60;ident&#62; !~~ &#39;moose&#39; | &#39;squirrel&#39;</pre>

<a id="line_862"></a>
<a id="line_863"></a>


<p>parses as</p>

<a id="line_864"></a>
<a id="line_865"></a>


<pre>    &#60;ident&#62; !~~ [ &#39;moose&#39; | &#39;squirrel&#39; ]</pre>

<a id="line_866"></a>
<a id="line_867"></a>


<p>while</p>

<a id="line_868"></a>
<a id="line_869"></a>


<pre>    &#60;ident&#62; !~~ &#39;moose&#39; || &#39;squirrel&#39;</pre>

<a id="line_870"></a>
<a id="line_871"></a>


<p>parses as</p>

<a id="line_872"></a>
<a id="line_873"></a>


<pre>    [ &#60;ident&#62; !~~ &#39;moose&#39; ] || &#39;squirrel&#39;</pre>

<a id="line_874"></a>
<a id="line_875"></a>
<a id="line_876"></a>
<a id="line_877"></a>
<a id="line_878"></a>
<a id="line_879"></a>

</li>

<li>The <code>~</code> operator is a helper for matching nested subrules with a specific terminator as the goal. It is designed to be placed between an opening and closing bracket, like so:
<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-metachars/tilde.t#L6-L76"><code>S05-metachars/tilde.t</code> lines <code>6&ndash;76</code></a>
  </p>
</div>
  


<a id="line_880"></a>
<a id="line_881"></a>


<pre>    &#39;(&#39; ~ &#39;)&#39; &#60;expression&#62;</pre>

<a id="line_882"></a>
<a id="line_883"></a>
<a id="line_884"></a>
<a id="line_885"></a>
<a id="line_886"></a>
<a id="line_887"></a>


<p>However, it mostly ignores the left argument, and operates on the next two atoms (which may be quantified). Its operation on those next two atoms is to &#34;twiddle&#34; them so that they are actually matched in reverse order. Hence the expression above, at first blush, is merely shorthand for:</p>

<a id="line_888"></a>
<a id="line_889"></a>


<pre>    &#39;(&#39; &#60;expression&#62; &#39;)&#39;</pre>

<a id="line_890"></a>
<a id="line_891"></a>
<a id="line_892"></a>
<a id="line_893"></a>
<a id="line_894"></a>
<a id="line_895"></a>
<a id="line_896"></a>


<p>But beyond that, when it rewrites the atoms it also inserts the apparatus that will set up the inner expression to recognize the terminator, and to produce an appropriate error message if the inner expression does not terminate on the required closing atom. So it really does pay attention to the left bracket as well, and it actually rewrites our example to something more like:</p>

<a id="line_897"></a>
<a id="line_898"></a>


<pre>    $&#60;OPEN&#62; = &#39;(&#39; &#60;SETGOAL: &#39;)&#39;&#62; &#60;expression&#62; [ $GOAL || &#60;FAILGOAL&#62; ]</pre>

<a id="line_899"></a>
<a id="line_900"></a>
<a id="line_901"></a>


<p>Note that you can use this construct to set up expectations for a closing construct even when there&#39;s no opening bracket:</p>

<a id="line_902"></a>
<a id="line_903"></a>


<pre>    &#60;?&#62; ~ &#39;)&#39; \d+</pre>

<a id="line_904"></a>
<a id="line_905"></a>


<p>Here &#60;?&#62; returns true on the first null string.</p>

<a id="line_906"></a>
<a id="line_907"></a>
<a id="line_908"></a>
<a id="line_909"></a>
<a id="line_910"></a>
<a id="line_911"></a>
<a id="line_912"></a>


<p>By default the error message uses the name of the current rule as an indicator of the abstract goal of the parser at that point. However, often this is not terribly informative, especially when rules are named according to an internal scheme that will not make sense to the user. The <code>:dba(&#34;doing business as&#34;)</code> adverb may be used to set up a more informative name for what the following code is trying to parse:</p>

<a id="line_913"></a>
<a id="line_914"></a>
<a id="line_915"></a>
<a id="line_916"></a>
<a id="line_917"></a>


<pre>    token postfix:sym&#60;[ ]&#62; {
        :dba(&#39;array subscript&#39;)
        &#39;[&#39; ~ &#39;]&#39; &#60;expression&#62;
    }</pre>

<a id="line_918"></a>
<a id="line_919"></a>


<p>Then instead of getting a message like:</p>

<a id="line_920"></a>
<a id="line_921"></a>


<pre>    Unable to parse expression in postfix:sym&#60;[ ]&#62;; couldn&#39;t find final &#39;]&#39;</pre>

<a id="line_922"></a>
<a id="line_923"></a>


<p>you&#39;ll get a message like:</p>

<a id="line_924"></a>
<a id="line_925"></a>


<pre>    Unable to parse expression in array subscript; couldn&#39;t find final &#39;]&#39;</pre>

<a id="line_926"></a>
<a id="line_927"></a>
<a id="line_928"></a>


<p>(The <code>:dba</code> adverb may also be used to give names to alternations and alternatives, which helps the lexer give better error messages.)</p>

<a id="line_929"></a>
<a id="line_930"></a>

</li>
</ul>

<a id="line_931"></a>
<a id="line_932"></a>
<a id="line_933"></a>
<a id="line_934"></a>
<a id="line_935"></a>
<a id="line_936"></a>
<a id="line_937"></a>
<a id="line_938"></a>
<a id="line_939"></a>


<h1><a class='u' href='#___top' title='click to go to top of document'
name="Bracket_rationalization"
>Bracket rationalization</a></h1>

<ul>
<li><code>(...)</code> still delimits a capturing group. However the ordering of these groups is hierarchical rather than linear. See <a href="#Nested_subpattern_captures" class="podlinkpod"
>&#34;Nested subpattern captures&#34;</a>.
<a id="line_940"></a>
<a id="line_941"></a>
<a id="line_942"></a>
<a id="line_943"></a>
<a id="line_944"></a>

</li>

<li><code>[...]</code> is no longer a character class. It now delimits a non-capturing group.
<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-match/non-capturing.t#L11-L39"><code>S05-match/non-capturing.t</code> lines <code>11&ndash;39</code></a>
  </p>
</div>
  


<a id="line_945"></a>
<a id="line_946"></a>
<a id="line_947"></a>


<p>A character class is now specified using <code>&#60;[...]&#62;</code>. See also <a href="#Extensible_metasyntax_(%3C...%3E)" class="podlinkpod"
>&#34;Extensible metasyntax (<code>&#60;...&#62;</code>)&#34;</a>.</p>

<a id="line_948"></a>
<a id="line_949"></a>
<a id="line_950"></a>
<a id="line_951"></a>
<a id="line_952"></a>
<a id="line_953"></a>
<a id="line_954"></a>
<a id="line_955"></a>
<a id="line_956"></a>

</li>

<li><code>{...}</code> is no longer a repetition quantifier. It now delimits an embedded closure. It is always considered procedural rather than declarative; it establishes a sequence point between what comes before and what comes after. (To avoid this use the <code>&#60;?{...}&#62;</code> assertion syntax instead.) A closure within a regex establishes its own lexical scope.
<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-metachars/closure.t#L15-L50"><code>S05-metachars/closure.t</code> lines <code>15&ndash;50</code></a>
  </p>
</div>
  


<a id="line_957"></a>
<a id="line_958"></a>
<a id="line_959"></a>
<a id="line_960"></a>
<a id="line_961"></a>
<a id="line_962"></a>

</li>

<li>You can call Perl code as part of a regex match by using a closure. Embedded code does not usually affect the match--it is only used for side-effects:
<a id="line_963"></a>
<a id="line_964"></a>
<a id="line_965"></a>
<a id="line_966"></a>


<pre>     / (\S+) { print &#34;string not blank\n&#34;; $text = $0; }
        \s+  { print &#34;but does contain whitespace\n&#34; }
     /</pre>

<a id="line_967"></a>
<a id="line_968"></a>
<a id="line_969"></a>
<a id="line_970"></a>


<p>An <b>explicit</b> reduction using the <code>make</code> function generates the <i>abstract syntax tree</i> object (<i>abstract object</i> or <i>ast</i> for short) for this match:</p>

<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-grammar/action-stubs.t#L40-L196"><code>S05-grammar/action-stubs.t</code> lines <code>40&ndash;196</code></a>
  </p>
</div>
  


<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-match/make.t#L7-L8"><code>S05-match/make.t</code> lines <code>7&ndash;8</code></a>
  </p>
</div>
  


<a id="line_971"></a>
<a id="line_972"></a>


<pre>        / (\d) { make $0.sqrt } Remainder /;</pre>

<a id="line_973"></a>
<a id="line_974"></a>
<a id="line_975"></a>
<a id="line_976"></a>
<a id="line_977"></a>
<a id="line_978"></a>
<a id="line_979"></a>


<p>This has the effect of capturing the square root of the numified string, instead of the string. The <code>Remainder</code> part is matched and returned as part of the <code>Match</code> object but is not returned as part of the abstract object. Since the abstract object usually represents the top node of an abstract syntax tree, the abstract object may be extracted from the <code>Match</code> object by use of the <code>.made</code> method.</p>

<a id="line_980"></a>
<a id="line_981"></a>
<a id="line_982"></a>


<p>A second call to <code>make</code> overrides any previous call to <code>make</code>. <code>make</code> is also available as a method on each match object.</p>

<a id="line_983"></a>
<a id="line_984"></a>
<a id="line_985"></a>
<a id="line_986"></a>
<a id="line_987"></a>
<a id="line_988"></a>


<p>Within a closure, the instantaneous position within the search is denoted by the <code>$&#162;.pos</code> method. As with all string positions, you must not treat it as a number unless you are very careful about which units you are dealing with.</p>

<a id="line_989"></a>
<a id="line_990"></a>
<a id="line_991"></a>


<p>The <code>Cursor</code> object can also return the original item that we are matching against; this is available from the <code>.orig</code> method.</p>

<a id="line_992"></a>
<a id="line_993"></a>
<a id="line_994"></a>
<a id="line_995"></a>
<a id="line_996"></a>
<a id="line_997"></a>
<a id="line_998"></a>


<p>The closure is also guaranteed to start with a <code>$/</code> <code>Match</code> object representing the match so far. However, if the closure does its own internal matching, its <code>$/</code> variable will be rebound to the result of <i>that</i> match until the end of the embedded closure. (The match will actually continue with the current value of the <code>$&#162;</code> object after the closure. <code>$/</code> and <code>$&#162;</code> just start out the same in your closure.)</p>

<a id="line_999"></a>
<a id="line_1000"></a>
<a id="line_1001"></a>
<a id="line_1002"></a>

</li>

<li>It can affect the match if it calls <code>fail</code>:
<a id="line_1003"></a>
<a id="line_1004"></a>


<pre>     / (\d+) { $0 &#60; 256 or fail } /</pre>

<a id="line_1005"></a>
<a id="line_1006"></a>
<a id="line_1007"></a>
<a id="line_1008"></a>
<a id="line_1009"></a>
<a id="line_1010"></a>


<p>Since closures establish a sequence point, they are guaranteed to be called at the canonical time even if the optimizer could prove that something after them can&#39;t match. (Anything before is fair game, however. In particular, a closure often serves as the terminator of a longest-token pattern.)</p>

<a id="line_1011"></a>
<a id="line_1012"></a>
<a id="line_1013"></a>
<a id="line_1014"></a>
<a id="line_1015"></a>
<a id="line_1016"></a>
<a id="line_1017"></a>
<a id="line_1018"></a>
<a id="line_1019"></a>
<a id="line_1020"></a>

</li>

<li>The general repetition specifier is now <code>**</code> for greedy matching, with a corresponding <code>**?</code> for frugal matching. (All such quantifier modifiers now go directly after the <code>**</code>.) Space is allowed on either side of the complete quantifier, but only the space before the <code>**</code> will be considered significant under <code>:sigspace</code> and match between repetitions. (Sigspace after the entire construct matches once after the all repetitions are found.)
<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-metasyntax/repeat.t#L19-L116"><code>S05-metasyntax/repeat.t</code> lines <code>19&ndash;116</code></a>
  </p>
</div>
  


<a id="line_1021"></a>
<a id="line_1022"></a>


<p>The next token constrains how many times the pattern on the left must match.</p>

<a id="line_1023"></a>
<a id="line_1024"></a>
<a id="line_1025"></a>


<p>If the next thing is an integer, then it is parsed as either as an exact count or a range:</p>

<a id="line_1026"></a>
<a id="line_1027"></a>
<a id="line_1028"></a>


<pre>    . ** 42                  # match exactly 42 times
    &#60;item&#62; ** 3..*           # match 3 or more times</pre>

<a id="line_1029"></a>
<a id="line_1030"></a>


<p>This form is considered declarational.</p>

<a id="line_1031"></a>
<a id="line_1032"></a>


<p>If you supply a closure, it should return either an <code>Int</code> or a <code>Range</code> object.</p>

<a id="line_1033"></a>
<a id="line_1034"></a>
<a id="line_1035"></a>


<pre>    &#39;x&#39; ** {$m}              # exact count returned from closure
    &#60;foo&#62; ** {$m..$n}        # range returned from closure</pre>

<a id="line_1036"></a>
<a id="line_1037"></a>


<pre>    / value was (\d **? {1..6}) with ([ &#60;alpha&#62;\w* ]**{$m..$n}) /</pre>

<a id="line_1038"></a>
<a id="line_1039"></a>


<p>It is illegal to return a list, so this easy mistake fails:</p>

<a id="line_1040"></a>
<a id="line_1041"></a>


<pre>    / [foo] ** {1,3} /</pre>

<a id="line_1042"></a>
<a id="line_1043"></a>
<a id="line_1044"></a>


<p>The closure form is always considered procedural, so the item it is modifying is never considered part of the longest token.</p>

<a id="line_1045"></a>
<a id="line_1046"></a>
<a id="line_1047"></a>
<a id="line_1048"></a>


<p>For backwards compatibility with previous versions of Perl 6, if the token following ** is not a closure or literal integer, it is interpreted as +% with a warning:</p>

<a id="line_1049"></a>
<a id="line_1050"></a>
<a id="line_1051"></a>


<pre>   / x ** y /                # same as / x+ % y /
   / x ** $y /               # same as / x [$y x]* /</pre>

<a id="line_1052"></a>
<a id="line_1053"></a>
<a id="line_1054"></a>


<p>No check is made to see if $y contains an integer or range value. This compatibility feature is not guaranteed to exist forever.</p>

<a id="line_1055"></a>
<a id="line_1056"></a>
<a id="line_1057"></a>
<a id="line_1058"></a>
<a id="line_1059"></a>
<a id="line_1060"></a>

</li>

<li>Negative range values are allowed, but only when modifying a reversible pattern (such as <code>after</code> could match). For example, to search the surrounding 200 characters as defined by &#39;dot&#39;, you could say:
<a id="line_1061"></a>
<a id="line_1062"></a>


<pre>    / . ** -100..100 &#60;element&#62; /</pre>

<a id="line_1063"></a>
<a id="line_1064"></a>


<p>Similarly, you can back up 50 characters with:</p>

<a id="line_1065"></a>
<a id="line_1066"></a>


<pre>    / . ** -50 &#60;element&#62; /</pre>

<a id="line_1067"></a>
<a id="line_1068"></a>
<a id="line_1069"></a>


<p>[Conjecture: A negative quantifier forces the construct to be considered procedural rather than declarational.]</p>

<a id="line_1070"></a>
<a id="line_1071"></a>
<a id="line_1072"></a>
<a id="line_1073"></a>
<a id="line_1074"></a>
<a id="line_1075"></a>
<a id="line_1076"></a>
<a id="line_1077"></a>

</li>

<li>Any quantified atom may be modified by an additional constraint that specifies the separator to look for between repeats of the left side. This is indicated by use of a <code>%</code> between the quantifier and the separator. The initial item is iterated only as long as the separator is seen between items:
<a id="line_1078"></a>
<a id="line_1079"></a>
<a id="line_1080"></a>
<a id="line_1081"></a>
<a id="line_1082"></a>


<pre>    &#60;alt&#62;+ % &#39;|&#39;            # repetition controlled by presence of character
    &#60;addend&#62;+ % &#60;addop&#62;     # repetition controlled by presence of subrule
    &#60;item&#62;+ % [ \!?&#39;==&#39; ]   # repetition controlled by presence of operator
    &#60;file&#62;+%\h+             # repetition controlled by presence of whitespace</pre>

<a id="line_1083"></a>
<a id="line_1084"></a>


<p>Any quantifier may be so modified:</p>

<a id="line_1085"></a>
<a id="line_1086"></a>
<a id="line_1087"></a>
<a id="line_1088"></a>
<a id="line_1089"></a>


<pre>    &#60;a&#62;* % &#39;,&#39;              # 0 or more comma-separated elements
    &#60;a&#62;+ % &#39;,&#39;              # 1 or more
    &#60;a&#62;? % &#39;,&#39;              # 0 or 1 (but &#39;,&#39; never used!?!)
    &#60;a&#62; ** 2..* % &#39;,&#39;       # 2 or more</pre>

<a id="line_1090"></a>
<a id="line_1091"></a>
<a id="line_1092"></a>
<a id="line_1093"></a>
<a id="line_1094"></a>


<p>The <code>%</code> modifier may only be used on a quantifier; any attempt to use it on a bare term will result in a parse error (to minimize possible confusion with any hash notations we choose to support in Perl 6 regexes).</p>

<a id="line_1095"></a>
<a id="line_1096"></a>
<a id="line_1097"></a>
<a id="line_1098"></a>


<p>A successful match of a <code>%</code> construct generally ends &#34;in the middle&#34; at the <code>%</code>, that is, after the initial item but before the next separator. Therefore</p>

<a id="line_1099"></a>
<a id="line_1100"></a>


<pre>    / &#60;ident&#62;+ % &#39;,&#39; /</pre>

<a id="line_1101"></a>
<a id="line_1102"></a>


<p>can match</p>

<a id="line_1103"></a>
<a id="line_1104"></a>
<a id="line_1105"></a>
<a id="line_1106"></a>


<pre>    foo
    foo,bar
    foo,bar,baz</pre>

<a id="line_1107"></a>
<a id="line_1108"></a>


<p>but never</p>

<a id="line_1109"></a>
<a id="line_1110"></a>
<a id="line_1111"></a>


<pre>    foo,
    foo,bar,</pre>

<a id="line_1112"></a>
<a id="line_1113"></a>
<a id="line_1114"></a>
<a id="line_1115"></a>


<p>The only time such a match doesn&#39;t end in the middle is if the left side can match 0 times (and does so), in which case the whole construct matches the null string.</p>

<a id="line_1116"></a>
<a id="line_1117"></a>


<pre>    &#39;&#39; ~~ / &#60;ident&#62;* % &#39;,&#39; /  # matches because of the *</pre>

<a id="line_1118"></a>
<a id="line_1119"></a>
<a id="line_1120"></a>


<p>If you wish to allow the match to end after either side, use <code>%%</code> instead. Therefore</p>

<a id="line_1121"></a>
<a id="line_1122"></a>


<pre>    / &#60;ident&#62;+ %% &#39;,&#39; /</pre>

<a id="line_1123"></a>
<a id="line_1124"></a>


<p>can match any of</p>

<a id="line_1125"></a>
<a id="line_1126"></a>
<a id="line_1127"></a>
<a id="line_1128"></a>
<a id="line_1129"></a>
<a id="line_1130"></a>
<a id="line_1131"></a>


<pre>    foo
    foo,
    foo,bar
    foo,bar,
    foo,bar,baz
    foo,bar,baz,</pre>

<a id="line_1132"></a>
<a id="line_1133"></a>


<p>If you wish to quantify each match on the left individually, you must place it in brackets:</p>

<a id="line_1134"></a>
<a id="line_1135"></a>


<pre>    [&#60;a&#62;*]+ % &#39;,&#39;</pre>

<a id="line_1136"></a>
<a id="line_1137"></a>
<a id="line_1138"></a>


<p>It is legal for the separator to be zero-width as long as the pattern on the left progresses on each iteration:</p>

<a id="line_1139"></a>
<a id="line_1140"></a>


<pre>    .+ % &#60;?same&#62;   # match sequence of identical characters</pre>

<a id="line_1141"></a>
<a id="line_1142"></a>
<a id="line_1143"></a>
<a id="line_1144"></a>
<a id="line_1145"></a>
<a id="line_1146"></a>


<p>The separator never matches independently of the next item; if the separator matches but the next item fails, it backtracks all the way back through the separator. Likewise, this matching of the separator does not count as &#34;progress&#34; under <code>:ratchet</code> semantics unless the next item succeeds.</p>

<a id="line_1147"></a>
<a id="line_1148"></a>
<a id="line_1149"></a>
<a id="line_1150"></a>


<p>When significant space is used under <code>:sigspace</code>, each matching element enables the immediately following whitespace to be considered significant. Space after the <code>%</code> does nothing. If you write:</p>

<a id="line_1151"></a>
<a id="line_1152"></a>
<a id="line_1153"></a>


<pre>    ms/ &#60;element&#62; +  %  &#39;,&#39; /
      #1        #2 #3 #4  #5</pre>

<a id="line_1154"></a>
<a id="line_1155"></a>


<p>it ignores whitespace #1 and #4, and rewrites the rest to:</p>

<a id="line_1156"></a>
<a id="line_1157"></a>
<a id="line_1158"></a>


<pre>    / [ &#60;element&#62; &#60;.ws&#62; ]+ % [ &#39;,&#39; &#60;.ws&#62; ] &#60;.ws&#62; /
                    #2               #5      #3</pre>

<a id="line_1159"></a>
<a id="line_1160"></a>
<a id="line_1161"></a>


<p>Since #3 is redundant with #2 (because <code>+</code> requires an element), it suffices to supply either #2 or #3:</p>

<a id="line_1162"></a>
<a id="line_1163"></a>
<a id="line_1164"></a>


<pre>    ms/ &#60;element&#62;+ % &#39;,&#39; /    # ws after comma and at end
    ms/ &#60;element&#62; +% &#39;,&#39; /    # ws after comma and any element</pre>

<a id="line_1165"></a>
<a id="line_1166"></a>


<p>So the first</p>

<a id="line_1167"></a>
<a id="line_1168"></a>


<pre>    ms/ &#60;element&#62;+ % &#39;,&#39; /    # ws after comma and at end</pre>

<a id="line_1169"></a>
<a id="line_1170"></a>


<p>is like</p>

<a id="line_1171"></a>
<a id="line_1172"></a>


<pre>    / &#60;element&#62;[&#39;,&#39;&#60;.ws&#62;&#60;element&#62;]*&#60;.ws&#62; /</pre>

<a id="line_1173"></a>
<a id="line_1174"></a>


<p>while the second</p>

<a id="line_1175"></a>
<a id="line_1176"></a>


<pre>    ms/ &#60;element&#62; +% &#39;,&#39; /    # ws after comma and any element</pre>

<a id="line_1177"></a>
<a id="line_1178"></a>


<p>is like</p>

<a id="line_1179"></a>
<a id="line_1180"></a>


<pre>    / &#60;element&#62;&#60;.ws&#62;[&#39;,&#39;&#60;.ws&#62;&#60;element&#62;&#60;.ws&#62;]* /</pre>

<a id="line_1181"></a>
<a id="line_1182"></a>


<p>and</p>

<a id="line_1183"></a>
<a id="line_1184"></a>


<pre>    ms/ &#60;element&#62;+% &#39;,&#39;/</pre>

<a id="line_1185"></a>
<a id="line_1186"></a>


<p>excludes all significant whitespace like this:</p>

<a id="line_1187"></a>
<a id="line_1188"></a>


<pre>    / &#60;element&#62;[&#39;,&#39;&#60;element&#62;]* /</pre>

<a id="line_1189"></a>
<a id="line_1190"></a>
<a id="line_1191"></a>
<a id="line_1192"></a>
<a id="line_1193"></a>


<p>Note that with a <code>*</code> instead of a <code>+</code>, space #3 would not be redundant with #2, since if 0 elements are matched, the space associated with it (#2) is not matched. In that case it makes sense to put space on both sides of the <code>*</code>:</p>

<a id="line_1194"></a>
<a id="line_1195"></a>


<pre>    ms/ &#60;element&#62; * % &#39;,&#39; /</pre>

<a id="line_1196"></a>
<a id="line_1197"></a>
<a id="line_1198"></a>
<a id="line_1199"></a>
<a id="line_1200"></a>

</li>

<li><code>&#60;...&#62;</code> are now extensible metasyntax delimiters or <i>assertions</i> (i.e. they replace Perl 5&#39;s crufty <code>(?...)</code> syntax).
<a id="line_1201"></a>
<a id="line_1202"></a>

</li>
</ul>

<a id="line_1203"></a>
<a id="line_1204"></a>
<a id="line_1205"></a>
<a id="line_1206"></a>
<a id="line_1207"></a>
<a id="line_1208"></a>
<a id="line_1209"></a>
<a id="line_1210"></a>


<h1><a class='u' href='#___top' title='click to go to top of document'
name="Variable_(non-)interpolation"
>Variable (non-)interpolation</a></h1>

<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-interpolation/regex-in-variable.t#L15-L122"><code>S05-interpolation/regex-in-variable.t</code> lines <code>15&ndash;122</code></a>
  </p>
</div>
  


<ul>
<li>In Perl 6 regexes, variables don&#39;t interpolate.
<a id="line_1211"></a>
<a id="line_1212"></a>
<a id="line_1213"></a>
<a id="line_1214"></a>
<a id="line_1215"></a>

</li>

<li>Instead they&#39;re passed <i>raw</i> to the regex engine, which can then decide how to handle them (more on that below).
<a id="line_1216"></a>
<a id="line_1217"></a>
<a id="line_1218"></a>
<a id="line_1219"></a>
<a id="line_1220"></a>
<a id="line_1221"></a>

</li>

<li>The default way in which the engine handles a string scalar is to match it as a <code>&#34;...&#34;</code> literal (i.e. it does not treat the interpolated string as a subpattern). In other words, a Perl 6:
<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-metasyntax/litvar.t#L17-L38"><code>S05-metasyntax/litvar.t</code> lines <code>17&ndash;38</code></a>
  </p>
</div>
  


<a id="line_1222"></a>
<a id="line_1223"></a>


<pre>     / $var /</pre>

<a id="line_1224"></a>
<a id="line_1225"></a>


<p>is like a Perl 5:</p>

<a id="line_1226"></a>
<a id="line_1227"></a>


<pre>     / \Q$var\E /</pre>

<a id="line_1228"></a>
<a id="line_1229"></a>


<p>To interpolate a <code>Regex</code> object, use <code>&#60;$var&#62;</code> instead.</p>

<a id="line_1230"></a>
<a id="line_1231"></a>


<p>If <code>$var</code> is undefined, a warning is issued and the match fails.</p>

<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-interpolation/regex-in-variable.t#L129-L159"><code>S05-interpolation/regex-in-variable.t</code> lines <code>129&ndash;159</code></a>
  </p>
</div>
  


<a id="line_1232"></a>
<a id="line_1233"></a>
<a id="line_1234"></a>
<a id="line_1235"></a>
<a id="line_1236"></a>
<a id="line_1237"></a>


<p>When matching against a Stringy type that is not Str, the variable must be interpretable as a value of that Stringy type (or a related type that can be coerced to that type). For example, when regex matching a Buf type, the variable will be matched under the Buf type&#39;s semantics, not Str semantics.</p>

<a id="line_1238"></a>
<a id="line_1239"></a>
<a id="line_1240"></a>
<a id="line_1241"></a>
<a id="line_1242"></a>
<a id="line_1243"></a>


<p>[Conjecture: when we allow matching against non-string types, doing a type match on the current node will require the syntax of an embedded signature, not just a bare variable, so there is no need to account for a variable containing a type object, which is by definition undefined, and hence fails to match by the above rule.]</p>

<a id="line_1244"></a>
<a id="line_1245"></a>
<a id="line_1246"></a>


<p>However, a variable used as the left side of an alias or submatch operator is not used for matching.</p>

<a id="line_1247"></a>
<a id="line_1248"></a>
<a id="line_1249"></a>


<pre>    $x = &#60;.ident&#62;
    $0 ~~ &#60;.ident&#62;</pre>

<a id="line_1250"></a>
<a id="line_1251"></a>
<a id="line_1252"></a>


<p>If you do want to match <code>$0</code> again and then use that as the submatch, you can force the match using double quotes:</p>

<a id="line_1253"></a>
<a id="line_1254"></a>


<pre>    &#34;$0&#34; ~~ &#60;.ident&#62;</pre>

<a id="line_1255"></a>
<a id="line_1256"></a>
<a id="line_1257"></a>


<p>On the other hand, it is non-sensical to alias to something that is not a variable:</p>

<a id="line_1258"></a>
<a id="line_1259"></a>
<a id="line_1260"></a>
<a id="line_1261"></a>
<a id="line_1262"></a>
<a id="line_1263"></a>


<pre>    &#34;$0&#34; = &#60;.ident&#62;     # ERROR
    $0 = &#60;.ident&#62;       # okay
    $x = &#60;.ident&#62;       # okay, temporary capture
    $&#60;x&#62; = &#60;.ident&#62;     # okay, persistent capture
    &#60;x=.ident&#62;          # same thing</pre>

<a id="line_1264"></a>
<a id="line_1265"></a>
<a id="line_1266"></a>
<a id="line_1267"></a>
<a id="line_1268"></a>
<a id="line_1269"></a>
<a id="line_1270"></a>
<a id="line_1271"></a>
<a id="line_1272"></a>
<a id="line_1273"></a>


<p>Variables declared in capture aliases are lexically scoped to the rest of the regex. You should not confuse this use of <code>=</code> with either ordinary assignment or ordinary binding. You should read the <code>=</code> more like the pseudoassignment of a declarator than like normal assignment. It&#39;s more like the ordinary <code>:=</code> operator, since at the level regexes work, strings are immutable, so captures are really just precomputed substr values. Nevertheless, when you eventually use the values independently, the substr may be copied, and then it&#39;s more like it was an assignment originally.</p>

<a id="line_1274"></a>
<a id="line_1275"></a>
<a id="line_1276"></a>
<a id="line_1277"></a>
<a id="line_1278"></a>


<p>Capture variables of the form <code>$&#60;ident&#62;</code> may persist beyond the lexical scope; if the match succeeds they are remembered in the <code>Match</code> object&#39;s hash, with a key corresponding to the variable name&#39;s identifier. Likewise bound numeric variables persist as <code>$0</code>, etc.</p>

<a id="line_1279"></a>
<a id="line_1280"></a>
<a id="line_1281"></a>
<a id="line_1282"></a>


<p>You may capture to existing lexical variables; such variables may already be visible from an outer scope, or may be declared within the regex via a <code>:my</code> declaration.</p>

<a id="line_1283"></a>
<a id="line_1284"></a>
<a id="line_1285"></a>


<pre>    my $x; / $x = [...] /            # capture to outer lexical $x
    / :my $x; $x = [...] /           # capture to our own lexical $x</pre>

<a id="line_1286"></a>
<a id="line_1287"></a>
<a id="line_1288"></a>
<a id="line_1289"></a>

</li>

<li>An interpolated array:
<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-metasyntax/litvar.t#L39-L107"><code>S05-metasyntax/litvar.t</code> lines <code>39&ndash;107</code></a>
  </p>
</div>
  


<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-metasyntax/sequential-alternation.t#L22-L37"><code>S05-metasyntax/sequential-alternation.t</code> lines <code>22&ndash;37</code></a>
  </p>
</div>
  


<a id="line_1290"></a>
<a id="line_1291"></a>


<pre>     / @cmds /</pre>

<a id="line_1292"></a>
<a id="line_1293"></a>
<a id="line_1294"></a>


<p>is matched as if it were an alternation of its literal elements. Ordinarily it matches using junctive semantics:</p>

<a id="line_1295"></a>
<a id="line_1296"></a>


<pre>     / [ $(@cmds[0]) | $(@cmds[1]) | $(@cmds[2]) | ... ] /</pre>

<a id="line_1297"></a>


<a id="line_1298"></a>
<a id="line_1299"></a>
<a id="line_1300"></a>
<a id="line_1301"></a>


<p>However, if it is a direct member of a <code>||</code> list, it uses sequential matching semantics, even it&#39;s the only member of the list. Conveniently, you can put <code>||</code> before the first member of an alternation, hence</p>

<a id="line_1302"></a>
<a id="line_1303"></a>


<pre>     / || @cmds /</pre>

<a id="line_1304"></a>
<a id="line_1305"></a>


<p>is equivalent to</p>

<a id="line_1306"></a>
<a id="line_1307"></a>


<pre>     / [ $(@cmds[0]) || $(@cmds[1]) || $(@cmds[2]) || ... ] /</pre>

<a id="line_1308"></a>
<a id="line_1309"></a>


<p>Or course, you can also</p>

<a id="line_1310"></a>
<a id="line_1311"></a>


<pre>     / | @cmds /</pre>

<a id="line_1312"></a>
<a id="line_1313"></a>


<p>to be clear that you mean junctive semantics.</p>

<a id="line_1314"></a>
<a id="line_1315"></a>
<a id="line_1316"></a>


<p>Note the usage of $(...) to prevent the subscripts from being parsed as regex syntax rather than an actual subscript.</p>

<a id="line_1317"></a>
<a id="line_1318"></a>
<a id="line_1319"></a>
<a id="line_1320"></a>
<a id="line_1321"></a>


<p>Since <code>$x</code> is interpolated as if you&#39;d said <code>&#34;$x&#34;</code>, if <code>$x</code> contains a list, it is stringified first. To get alternation you must use the <code>@$x</code> or <code>@($x)</code> form to indicate that you&#39;re intending the scalar variable to be treated as a list.</p>

<a id="line_1322"></a>
<a id="line_1323"></a>
<a id="line_1324"></a>
<a id="line_1325"></a>


<p>An interpolated array using junctive semantics is declarative (participates in external longest token matching) only if it&#39;s known to be constant at the time the regex is compiled.</p>

<a id="line_1326"></a>
<a id="line_1327"></a>
<a id="line_1328"></a>
<a id="line_1329"></a>


<p>As with a scalar variable, each element is matched as a literal. All such values pay attention to the current <code>:ignorecase</code> and <code>:ignoremark</code> settings.</p>

<a id="line_1330"></a>
<a id="line_1331"></a>


<p>When you get tired of writing:</p>

<a id="line_1332"></a>
<a id="line_1333"></a>


<pre>    token sigil { &#39;$&#39; | &#39;@&#39; | &#39;%&#39; | &#39;&#38;&#39; | &#39;::&#39; }</pre>

<a id="line_1334"></a>
<a id="line_1335"></a>


<p>you can write:</p>

<a id="line_1336"></a>
<a id="line_1337"></a>


<pre>    token sigil { &#60; $ @ % &#38; :: &#62; }</pre>

<a id="line_1338"></a>
<a id="line_1339"></a>
<a id="line_1340"></a>
<a id="line_1341"></a>


<p>as long as you&#39;re careful to put a space after the initial angle so that it won&#39;t be interpreted as a subrule. With the space it is parsed like angle quotes in ordinary Perl 6 and treated as a literal array value.</p>

<a id="line_1342"></a>
<a id="line_1343"></a>
<a id="line_1344"></a>
<a id="line_1345"></a>
<a id="line_1346"></a>
<a id="line_1347"></a>
<a id="line_1348"></a>

</li>

<li>Alternatively, if you predeclare a proto regex, you can write multiple regexes for the same category, differentiated only by the symbol they match. The symbol is specified as part of the &#34;long name&#34;. It may also be matched within the rule using <code>&#60;sym&#62;</code>, like this:
<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-grammar/protos.t#L7-L31"><code>S05-grammar/protos.t</code> lines <code>7&ndash;31</code></a>
  </p>
</div>
  


<a id="line_1349"></a>
<a id="line_1350"></a>
<a id="line_1351"></a>
<a id="line_1352"></a>
<a id="line_1353"></a>
<a id="line_1354"></a>
<a id="line_1355"></a>


<pre>    proto token sigil {*}
    multi token sigil:sym&#60;$&#62;  { &#60;sym&#62; }
    multi token sigil:sym&#60;@&#62;  { &#60;sym&#62; }
    multi token sigil:sym&#60;%&#62;  { &#60;sym&#62; }
    multi token sigil:sym&#60;&#38;&#62;  { &#60;sym&#62; }
    multi token sigil:sym&#60;::&#62; { &#60;sym&#62; }</pre>

<a id="line_1356"></a>
<a id="line_1357"></a>


<p>(The <code>multi</code> is optional and generally omitted with a grammar.)</p>

<a id="line_1358"></a>
<a id="line_1359"></a>
<a id="line_1360"></a>
<a id="line_1361"></a>
<a id="line_1362"></a>
<a id="line_1363"></a>


<p>This can be viewed as a form of multiple dispatch, except that it&#39;s based on longest-token matching rather than signature matching. The advantage of writing it this way is that it&#39;s easy to add additional rules to the same category in a derived grammar. All of them will be matched in parallel when you try to match <code>/&#60;sigil&#62;/</code>.</p>

<a id="line_1364"></a>
<a id="line_1365"></a>
<a id="line_1366"></a>
<a id="line_1367"></a>
<a id="line_1368"></a>


<p>If there are formal parameters on multi regex methods, matching still proceeds via longest-token rules first. If that results in a tie, a normal multiple dispatch is made using the arguments to the remaining variants, assuming they can be differentiated by type.</p>

<a id="line_1369"></a>
<a id="line_1370"></a>
<a id="line_1371"></a>
<a id="line_1372"></a>
<a id="line_1373"></a>


<p>The <code>proto</code> calls into the subdispatcher when it sees a <code>*</code> that cannot be a quantifier and is the only thing in its block. Therefore you can put items before and after the subdispatch by putting the <code>*</code> into curlies:</p>

<a id="line_1374"></a>
<a id="line_1375"></a>


<pre>    proto token foo { &#60;prestuff&#62; {*} &#60;poststuff&#62; }</pre>

<a id="line_1376"></a>
<a id="line_1377"></a>
<a id="line_1378"></a>
<a id="line_1379"></a>
<a id="line_1380"></a>


<p>This works only in a proto. See <a href="http://design.perl6.org/S06.html" class="podlinkpod"
>S06</a> for a discussion of the semantics of <code>{*}</code>. (Unlike a proto sub, a proto regex automatically remembers the return values from <code>{*}</code> because they are carried along with the match cursor.)</p>

<a id="line_1381"></a>
<a id="line_1382"></a>
<a id="line_1383"></a>
<a id="line_1384"></a>

</li>

<li>The use of a hash variable in patterns is reserved.
<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-interpolation/regex-in-variable.t#L123-L128"><code>S05-interpolation/regex-in-variable.t</code> lines <code>123&ndash;128</code></a>
  </p>
</div>
  


<a id="line_1385"></a>
<a id="line_1386"></a>
<a id="line_1387"></a>
<a id="line_1388"></a>
<a id="line_1389"></a>
<a id="line_1390"></a>
<a id="line_1391"></a>
<a id="line_1392"></a>
<a id="line_1393"></a>
<a id="line_1394"></a>
<a id="line_1395"></a>
<a id="line_1396"></a>

</li>

<li>Variable matches are considered declarative if and only if the variable is known to represent a constant, Otherwise they are procedural. Note that role parameters (if readonly) are considered constant declarations for this purpose despite the absence of an explicit <code>constant</code> declarator, since roles themselves are immutable, and will presumably be replacing the parameter with a constant value when composed (if the value passed is a constant). Macros instantiated with constants would also make those constants eligible for declarative treatment.
<a id="line_1397"></a>
<a id="line_1398"></a>

</li>
</ul>

<a id="line_1399"></a>
<a id="line_1400"></a>
<a id="line_1401"></a>
<a id="line_1402"></a>
<a id="line_1403"></a>
<a id="line_1404"></a>
<a id="line_1405"></a>
<a id="line_1406"></a>


<h1><a class='u' href='#___top' title='click to go to top of document'
name="Extensible_metasyntax_(&#60;...&#62;)"
>Extensible metasyntax (<code>&#60;...&#62;</code>)</a></h1>

<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-metasyntax/angle-brackets.t#L18-L138"><code>S05-metasyntax/angle-brackets.t</code> lines <code>18&ndash;138</code></a>
  </p>
</div>
  


<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-mass/recursive.t#L14-L48"><code>S05-mass/recursive.t</code> lines <code>14&ndash;48</code></a>
  </p>
</div>
  


<p>Both <code>&#60;</code> and <code>&#62;</code> are metacharacters, and are usually (but not always) used in matched pairs. (Some combinations of metacharacters function as standalone tokens, and these may include angles. These are described below.) Most assertions are considered declarative; procedural assertions will be marked as exceptions.</p>

<a id="line_1407"></a>
<a id="line_1408"></a>
<a id="line_1409"></a>


<p>For matched pairs, the first character after <code>&#60;</code> determines the nature of the assertion:</p>

<a id="line_1410"></a>
<a id="line_1411"></a>
<a id="line_1412"></a>
<a id="line_1413"></a>
<a id="line_1414"></a>
<a id="line_1415"></a>
<a id="line_1416"></a>


<ul>
<li>If the first character is whitespace, the angles are treated as an ordinary &#34;quote words&#34; array literal.
<a id="line_1417"></a>
<a id="line_1418"></a>


<pre>    &#60; adam &#38; eve &#62;   # equivalent to [ &#39;adam&#39; | &#39;&#38;&#39; | &#39;eve&#39; ]</pre>

<a id="line_1419"></a>
<a id="line_1420"></a>
<a id="line_1421"></a>


<p>Note that the space before the ending &#62; is optional and therefore &#60; adam &#38; eve&#62; would be acceptable.</p>

<a id="line_1422"></a>
<a id="line_1423"></a>
<a id="line_1424"></a>
<a id="line_1425"></a>
<a id="line_1426"></a>

</li>

<li>A leading alphabetic character means it&#39;s a capturing grammatical assertion (i.e. a subrule or a named character class - see below):
<a id="line_1427"></a>
<a id="line_1428"></a>


<pre>     / &#60;sign&#62;? &#60;mantissa&#62; &#60;exponent&#62;? /</pre>

<a id="line_1429"></a>
<a id="line_1430"></a>
<a id="line_1431"></a>
<a id="line_1432"></a>
<a id="line_1433"></a>


<p>The first character after the identifier determines the treatment of the rest of the text before the closing angle. The underlying semantics is that of a function or method call, so if the first character is a left parenthesis, it really is a call to either a method or function:</p>

<a id="line_1434"></a>
<a id="line_1435"></a>


<pre>    &#60;foo(&#39;bar&#39;)&#62;</pre>

<a id="line_1436"></a>
<a id="line_1437"></a>
<a id="line_1438"></a>


<p>If the first character after the identifier is an <code>=</code>, then the identifier is taken as an alias for what follows. In particular,</p>

<a id="line_1439"></a>
<a id="line_1440"></a>


<pre>    &#60;foo=bar&#62;</pre>

<a id="line_1441"></a>
<a id="line_1442"></a>


<p>is just shorthand for</p>

<a id="line_1443"></a>
<a id="line_1444"></a>


<pre>    $&#60;foo&#62; = &#60;bar&#62;</pre>

<a id="line_1445"></a>
<a id="line_1446"></a>
<a id="line_1447"></a>
<a id="line_1448"></a>
<a id="line_1449"></a>


<p>Note that this aliasing does not modify the original <code>&#60;bar&#62;</code> capture. To rename an inherited method capture without using the original name, use the dot form described below on the capture you wish to suppress. That is,</p>

<a id="line_1450"></a>
<a id="line_1451"></a>


<pre>    &#60;foo=.bar&#62;</pre>

<a id="line_1452"></a>
<a id="line_1453"></a>


<p>desugars to:</p>

<a id="line_1454"></a>
<a id="line_1455"></a>


<pre>    $&#60;foo&#62; = &#60;.bar&#62;</pre>

<a id="line_1456"></a>
<a id="line_1457"></a>
<a id="line_1458"></a>


<p>Likewise, to rename a lexically scoped regex explicitly, use the <code>&#38;</code> form described below. That is,</p>

<a id="line_1459"></a>
<a id="line_1460"></a>


<pre>    &#60;foo=&#38;bar&#62;</pre>

<a id="line_1461"></a>
<a id="line_1462"></a>


<p>desugars to:</p>

<a id="line_1463"></a>
<a id="line_1464"></a>


<pre>    $&#60;foo&#62; = &#60;&#38;bar&#62;</pre>

<a id="line_1465"></a>
<a id="line_1466"></a>


<p>Multiple aliases are allowed, so</p>

<a id="line_1467"></a>
<a id="line_1468"></a>


<pre>    &#60;foo=pub=bar&#62;</pre>

<a id="line_1469"></a>
<a id="line_1470"></a>


<p>is short for</p>

<a id="line_1471"></a>
<a id="line_1472"></a>


<pre>    $&#60;foo&#62; = $&#60;pub&#62; = &#60;bar&#62;</pre>

<a id="line_1473"></a>
<a id="line_1474"></a>


<p>Similarly, you can alias other assertion, e.g.:</p>

<a id="line_1475"></a>
<a id="line_1476"></a>
<a id="line_1477"></a>
<a id="line_1478"></a>


<pre>    &#60;foo=[abc]&#62;    # a character class, same as $&#60;foo&#62;=&#60;[abc]&#62;
    &#60;foo=:Letter&#62;  # a Unicode property, same as $&#60;foo&#62;=:Letter&#62;
    &#60;foo=:!Letter&#62; # a negated Unicode property lookup</pre>

<a id="line_1479"></a>
<a id="line_1480"></a>
<a id="line_1481"></a>


<p>If the first character after the identifier is whitespace, the subsequent text (following any whitespace) is passed as a regex, so:</p>

<a id="line_1482"></a>
<a id="line_1483"></a>


<pre>    &#60;foo bar&#62;</pre>

<a id="line_1484"></a>
<a id="line_1485"></a>


<p>is more or less equivalent to</p>

<a id="line_1486"></a>
<a id="line_1487"></a>


<pre>    &#60;foo(/bar/)&#62;</pre>

<a id="line_1488"></a>
<a id="line_1489"></a>


<p>To pass a regex with leading whitespace you must use the parenthesized form.</p>

<a id="line_1490"></a>
<a id="line_1491"></a>
<a id="line_1492"></a>
<a id="line_1493"></a>


<p>If the first character is a colon followed by whitespace, the rest of the text is taken as a list of arguments to the method, just as in ordinary Perl syntax. So these mean the same thing:</p>

<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-grammar/signatures.t#L7-L61"><code>S05-grammar/signatures.t</code> lines <code>7&ndash;61</code></a>
  </p>
</div>
  


<a id="line_1494"></a>
<a id="line_1495"></a>
<a id="line_1496"></a>


<pre>    &#60;foo(&#39;foo&#39;, $bar, 42)&#62;
    &#60;foo: &#39;foo&#39;, $bar, 42&#62;</pre>

<a id="line_1497"></a>
<a id="line_1498"></a>


<p>No other characters are allowed after the initial identifier.</p>

<a id="line_1499"></a>
<a id="line_1500"></a>
<a id="line_1501"></a>
<a id="line_1502"></a>
<a id="line_1503"></a>
<a id="line_1504"></a>


<p>Subrule matches are considered declarative to the extent that the front of the subrule is itself considered declarative. If a subrule contains a sequence point, then so does the subrule match. Longest-token matching does not proceed past such a subrule, for instance.</p>

<a id="line_1505"></a>
<a id="line_1506"></a>
<a id="line_1507"></a>
<a id="line_1508"></a>
<a id="line_1509"></a>
<a id="line_1510"></a>


<p>This form always gives preference to a lexically scoped regex declaration, dispatching directly to it as if it were function. If there is no such lexical regex (or lexical method) in scope, the call is dispatched to the current grammar, assuming there is one. That is, if there is a <code>my regex foo</code> visible from the current lexical scope, then</p>

<a id="line_1511"></a>
<a id="line_1512"></a>


<pre>    &#60;foo(1,2,3)&#62;</pre>

<a id="line_1513"></a>
<a id="line_1514"></a>


<p>means the same as</p>

<a id="line_1515"></a>
<a id="line_1516"></a>


<pre>    &#60;foo=&#38;foo(1,2,3)&#62;</pre>

<a id="line_1517"></a>
<a id="line_1518"></a>
<a id="line_1519"></a>
<a id="line_1520"></a>
<a id="line_1521"></a>
<a id="line_1522"></a>


<p>However, if there is no such lexically scoped regex (and note that within a grammar, regexes are installed as methods which have no lexical alias by default), then the call is dispatched as a normal method on the current <code>Cursor</code> (which will fail if you&#39;re not currently within a grammar). So in that case:</p>

<a id="line_1523"></a>
<a id="line_1524"></a>


<pre>    &#60;foo(1,2,3)&#62;</pre>

<a id="line_1525"></a>
<a id="line_1526"></a>


<p>means the same as:</p>

<a id="line_1527"></a>
<a id="line_1528"></a>


<pre>    &#60;foo=.foo(1,2,3)&#62;</pre>

<a id="line_1529"></a>
<a id="line_1530"></a>
<a id="line_1531"></a>
<a id="line_1532"></a>
<a id="line_1533"></a>
<a id="line_1534"></a>


<p>A call to <code>&#60;foo&#62;</code> will fail if there is neither any lexically scoped routine of that name it can call, nor any method of that name that be reached via method dispatch. (The decision of which dispatcher to use is made at compile time, not at run time; the method call is not a fallback mechanism.)</p>

<a id="line_1535"></a>
<a id="line_1536"></a>
<a id="line_1537"></a>
<a id="line_1538"></a>
<a id="line_1539"></a>
<a id="line_1540"></a>
<a id="line_1541"></a>

</li>

<li>A leading <code>.</code> explicitly calls a method as a subrule; the fact that the initial character is not alphanumeric also causes the named assertion to not capture what it matches (see <a href="#Subrule_captures" class="podlinkpod"
>&#34;Subrule captures&#34;</a>. For example:
<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-metasyntax/angle-brackets.t#L139-L238"><code>S05-metasyntax/angle-brackets.t</code> lines <code>139&ndash;238</code></a>
  </p>
</div>
  


<a id="line_1542"></a>
<a id="line_1543"></a>
<a id="line_1544"></a>
<a id="line_1545"></a>


<pre>     / &#60;ident&#62;  &#60;ws&#62;  /      # $/&#60;ident&#62; and $/&#60;ws&#62; both captured
     / &#60;.ident&#62; &#60;ws&#62;  /      # only $/&#60;ws&#62; captured
     / &#60;.ident&#62; &#60;.ws&#62; /      # nothing captured</pre>

<a id="line_1546"></a>
<a id="line_1547"></a>
<a id="line_1548"></a>
<a id="line_1549"></a>
<a id="line_1550"></a>
<a id="line_1551"></a>
<a id="line_1552"></a>


<p>The assertion is otherwise parsed identically to an assertion beginning with an identifier, provided the next thing after the dot is an identifier. As with the identifier form, any extra arguments pertaining to the matching engine are automatically supplied to the argument list via the implicit <code>Cursor</code> invocant. If there is no current class/grammar, or the current class is not derived from <code>Cursor</code>, the call is likely to fail.</p>

<a id="line_1553"></a>
<a id="line_1554"></a>
<a id="line_1555"></a>


<p>If the dot is not followed by an identifier, it is parsed as a &#34;dotty&#34; postfix of some type, such as an indirect method call:</p>

<a id="line_1556"></a>
<a id="line_1557"></a>


<pre>    &#60;.$indirect(@args)&#62;</pre>

<a id="line_1558"></a>
<a id="line_1559"></a>
<a id="line_1560"></a>
<a id="line_1561"></a>
<a id="line_1562"></a>
<a id="line_1563"></a>
<a id="line_1564"></a>


<p>As with all regex matching, the current match state (some derivative of <code>Cursor</code>) is passed as the first argument, which in this case is simply the method&#39;s invocant. The method is expected to return a lazy list of new match state objects, or <code>Nil</code> if the match fails entirely. Ratcheted routines will typically return a list containing only one match.</p>

<a id="line_1565"></a>
<a id="line_1566"></a>
<a id="line_1567"></a>
<a id="line_1568"></a>
<a id="line_1569"></a>
<a id="line_1570"></a>
<a id="line_1571"></a>
<a id="line_1572"></a>
<a id="line_1573"></a>
<a id="line_1574"></a>
<a id="line_1575"></a>
<a id="line_1576"></a>
<a id="line_1577"></a>

</li>

<li>Whereas a leading <code>.</code> unambiguously calls a method, a leading <code>&#38;</code> unambiguously calls a routine instead. Such a regex routine must be declared (or imported) with <code>my</code> or <code>our</code> scoping to make its name visible to the lexical scope, since by default a regex name is installed only into the current class&#39;s metaobject instance, just as with an ordinary method. The routine serves as a kind of private submethod, and is called without any consideration of inheritance. It must still take a <code>Cursor</code> as its first argument (which it can think of as an invocant if it likes), and must return the new match state as a cursor object. Hence,
<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-metasyntax/interpolating-closure.t#L17-L48"><code>S05-metasyntax/interpolating-closure.t</code> lines <code>17&ndash;48</code></a>
  </p>
</div>
  


<a id="line_1578"></a>
<a id="line_1579"></a>


<pre>     &#60;&#38;foo(1,2,3)&#62;</pre>

<a id="line_1580"></a>
<a id="line_1581"></a>


<p>is sugar for something like:</p>

<a id="line_1582"></a>
<a id="line_1583"></a>


<pre>     &#60;.gather { take foo($&#162;,1,2,3) }&#62;</pre>

<a id="line_1584"></a>
<a id="line_1585"></a>
<a id="line_1586"></a>
<a id="line_1587"></a>


<p>where <code>$&#162;</code> represents the current incoming match state, and the routine must return <code>Nil</code> for failure, or a lazy list of one or more match states (<code>Cursor</code>-derived objects) for successful matches.</p>

<a id="line_1588"></a>
<a id="line_1589"></a>


<p>As with the <code>.</code> form, an explicit <code>&#38;</code> suppresses capture.</p>

<a id="line_1590"></a>
<a id="line_1591"></a>
<a id="line_1592"></a>


<p>Note that all normal <code>Regex</code> objects are really such routines in disguise. When you say:</p>

<a id="line_1593"></a>
<a id="line_1594"></a>


<pre>    rx/stuff/</pre>

<a id="line_1595"></a>
<a id="line_1596"></a>


<p>you&#39;re really declaring an anonymous method, something like:</p>

<a id="line_1597"></a>
<a id="line_1598"></a>


<pre>    my $internal = anon regex :: ($&#162;: ) { stuff }</pre>

<a id="line_1599"></a>
<a id="line_1600"></a>
<a id="line_1601"></a>
<a id="line_1602"></a>
<a id="line_1603"></a>


<p>and then passing that object off to someone else who will call it indirectly. In this case, the method is installed neither into a class nor into a lexical scope, but as long as the value stays live somehow, it can still be called indirectly (see below).</p>

<a id="line_1604"></a>
<a id="line_1605"></a>
<a id="line_1606"></a>
<a id="line_1607"></a>
<a id="line_1608"></a>
<a id="line_1609"></a>
<a id="line_1610"></a>

</li>

<li>A leading <code>$</code> indicates an indirect subrule call. The variable must contain either a <code>Regex</code> object (really an anonymous method--see above), or a string to be compiled as the regex. The string is never matched literally.
<a id="line_1611"></a>
<a id="line_1612"></a>
<a id="line_1613"></a>


<p>If the compilation of the string form fails, the error message is converted to a warning and the assertion fails.</p>

<a id="line_1614"></a>
<a id="line_1615"></a>
<a id="line_1616"></a>


<p>The indirect subrule assertion is not captured. (No assertion with leading punctuation is captured by default.) You may always capture it explicitly, of course:</p>

<a id="line_1617"></a>
<a id="line_1618"></a>


<pre>    / &#60;name=$rx&#62; /</pre>

<a id="line_1619"></a>
<a id="line_1620"></a>
<a id="line_1621"></a>


<p>An indirect subrule is always considered procedural, and may not participate in longest-token matching.</p>

<a id="line_1622"></a>
<a id="line_1623"></a>
<a id="line_1624"></a>
<a id="line_1625"></a>

</li>

<li>A leading <code>::</code> indicates a symbolic indirect subrule:
<a id="line_1626"></a>
<a id="line_1627"></a>


<pre>     / &#60;::($somename)&#62; /</pre>

<a id="line_1628"></a>
<a id="line_1629"></a>
<a id="line_1630"></a>
<a id="line_1631"></a>
<a id="line_1632"></a>
<a id="line_1633"></a>
<a id="line_1634"></a>


<p>The variable must contain the name of a subrule. By the rules of single method dispatch this is first searched for in the current grammar and its ancestors. If this search fails an attempt is made to dispatch via MMD, in which case it can find subrules defined as multis rather than methods. This form is not captured by default. It is always considered procedural, not declarative.</p>

<a id="line_1635"></a>
<a id="line_1636"></a>
<a id="line_1637"></a>
<a id="line_1638"></a>
<a id="line_1639"></a>
<a id="line_1640"></a>
<a id="line_1641"></a>

</li>

<li>A leading <code>@</code> matches like a bare array except that each element is treated as a subrule (string or <code>Regex</code> object) rather than as a literal. That is, a string is forced to be compiled as a subrule instead of being matched literally. (There is no difference for a <code>Regex</code> object.)
<a id="line_1642"></a>
<a id="line_1643"></a>


<p>This assertion is not automatically captured.</p>

<a id="line_1644"></a>
<a id="line_1645"></a>
<a id="line_1646"></a>
<a id="line_1647"></a>

</li>

<li>The use of a hash as an assertion is reserved.
<a id="line_1648"></a>
<a id="line_1649"></a>
<a id="line_1650"></a>
<a id="line_1651"></a>
<a id="line_1652"></a>

</li>

<li>A leading <code>{</code> indicates code that produces a regex to be interpolated into the pattern at that point as a subrule:
<a id="line_1653"></a>
<a id="line_1654"></a>


<pre>     / (&#60;.ident&#62;)  &#60;{ %cache{$0} //= get_body_for($0) }&#62; /</pre>

<a id="line_1655"></a>
<a id="line_1656"></a>
<a id="line_1657"></a>


<p>The closure is guaranteed to be run at the canonical time; it declares a sequence point, and is considered to be procedural.</p>

<a id="line_1658"></a>
<a id="line_1659"></a>
<a id="line_1660"></a>
<a id="line_1661"></a>
<a id="line_1662"></a>
<a id="line_1663"></a>
<a id="line_1664"></a>
<a id="line_1665"></a>
<a id="line_1666"></a>
<a id="line_1667"></a>
<a id="line_1668"></a>
<a id="line_1669"></a>

</li>

<li>In any case of regex interpolation, if the value already happens to be a <code>Regex</code> object, it is not recompiled. If it is a string, the compiled form is cached with the string so that it is not recompiled next time you use it unless the string changes. (Any external lexical variable names must be rebound each time though.) Subrules may not be interpolated with unbalanced bracketing. An interpolated subrule keeps its own inner match results as a single item, so its parentheses never count toward the outer regexes groupings. (In other words, parenthesis numbering is always lexically scoped.)
<a id="line_1670"></a>
<a id="line_1671"></a>
<a id="line_1672"></a>
<a id="line_1673"></a>

</li>

<li>A leading <code>?{</code> or <code>!{</code> indicates a code assertion:
<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-metasyntax/assertions.t#L7-L25"><code>S05-metasyntax/assertions.t</code> lines <code>7&ndash;25</code></a>
  </p>
</div>
  


<a id="line_1674"></a>
<a id="line_1675"></a>
<a id="line_1676"></a>


<pre>     / (\d**1..3) &#60;?{ $0 &#60; 256 }&#62; /
     / (\d**1..3) &#60;!{ $0 &#60; 256 }&#62; /</pre>

<a id="line_1677"></a>
<a id="line_1678"></a>


<p>Similar to:</p>

<a id="line_1679"></a>
<a id="line_1680"></a>
<a id="line_1681"></a>


<pre>     / (\d**1..3) { $0 &#60; 256 or fail } /
     / (\d**1..3) { $0 &#60; 256 and fail } /</pre>

<a id="line_1682"></a>
<a id="line_1683"></a>
<a id="line_1684"></a>
<a id="line_1685"></a>
<a id="line_1686"></a>


<p>Unlike closures, code assertions are considered declarative; they are not guaranteed to be run at the canonical time if the optimizer can prove something later can&#39;t match. So you can sneak in a call to a non-canonical closure that way:</p>

<a id="line_1687"></a>
<a id="line_1688"></a>


<pre>     token { foo .* &#60;?{ do { say &#34;Got here!&#34; } or 1 }&#62; .* bar }</pre>

<a id="line_1689"></a>
<a id="line_1690"></a>


<p>The <code>do</code> block is unlikely to run unless the string ends with &#34;<code>bar</code>&#34;.</p>

<a id="line_1691"></a>
<a id="line_1692"></a>
<a id="line_1693"></a>
<a id="line_1694"></a>
<a id="line_1695"></a>

</li>

<li>A leading <code>[</code> indicates an enumerated character class. Ranges in enumerated character classes are indicated with &#34;<code>..</code>&#34; rather than &#34;<code>-</code>&#34;.
<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-metasyntax/charset.t#L18-L22"><code>S05-metasyntax/charset.t</code> lines <code>18&ndash;22</code></a>
  </p>
</div>
  


<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-mass/rx.t#L246-L260"><code>S05-mass/rx.t</code> lines <code>246&ndash;260</code></a>
  </p>
</div>
  


<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-mass/rx.t#L281-L442"><code>S05-mass/rx.t</code> lines <code>281&ndash;442</code></a>
  </p>
</div>
  


<a id="line_1696"></a>
<a id="line_1697"></a>


<pre>     / &#60;[a..z_]&#62;* /</pre>

<a id="line_1698"></a>
<a id="line_1699"></a>


<p>Whitespace is ignored within square brackets:</p>

<a id="line_1700"></a>
<a id="line_1701"></a>


<pre>     / &#60;[ a .. z _ ]&#62;* /</pre>

<a id="line_1702"></a>
<a id="line_1703"></a>
<a id="line_1704"></a>


<p>A reversed range is illegal. In directly compiled code it&#39;s a compile-time error to say</p>

<a id="line_1705"></a>
<a id="line_1706"></a>


<pre>    / &#60;[ z .. a ]&#62; /  # Reversed range is not allowed</pre>

<a id="line_1707"></a>
<a id="line_1708"></a>


<p>In indirectly compiled code, a similar warning is issued and the assertion fails:</p>

<a id="line_1709"></a>
<a id="line_1710"></a>
<a id="line_1711"></a>


<pre>    $rx = &#39;&#60;[ z .. a ]&#62;&#39;;
    / &#60;$rx&#62; /;  # warns and never matches</pre>

<a id="line_1712"></a>
<a id="line_1713"></a>
<a id="line_1714"></a>
<a id="line_1715"></a>

</li>

<li>A leading <code>-</code> indicates a complemented character class:
<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-metasyntax/charset.t#L23-L32"><code>S05-metasyntax/charset.t</code> lines <code>23&ndash;32</code></a>
  </p>
</div>
  


<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-mass/rx.t#L261-L280"><code>S05-mass/rx.t</code> lines <code>261&ndash;280</code></a>
  </p>
</div>
  


<a id="line_1716"></a>
<a id="line_1717"></a>
<a id="line_1718"></a>


<pre>     / &#60;-[a..z_]&#62; &#60;-alpha&#62; /
     / &#60;- [a..z_]&#62; &#60;- alpha&#62; /  # whitespace allowed after -</pre>

<a id="line_1719"></a>
<a id="line_1720"></a>


<p>This is essentially the same as using negative lookahead and dot:</p>

<a id="line_1721"></a>
<a id="line_1722"></a>


<pre>    / &#60;![a..z_]&#62; . &#60;!alpha&#62; . /</pre>

<a id="line_1723"></a>
<a id="line_1724"></a>


<p>Whitespace is ignored after the initial <code>-</code>.</p>

<a id="line_1725"></a>
<a id="line_1726"></a>
<a id="line_1727"></a>
<a id="line_1728"></a>
<a id="line_1729"></a>

</li>

<li>A leading <code>+</code> may also be supplied to indicate that the following character class is to be matched in a positive sense.
<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-mass/rx.t#L520-L2107"><code>S05-mass/rx.t</code> lines <code>520&ndash;2107</code></a>
  </p>
</div>
  


<a id="line_1730"></a>
<a id="line_1731"></a>
<a id="line_1732"></a>
<a id="line_1733"></a>


<pre>     / &#60;+[a..z_]&#62;* /
     / &#60;+[ a..z _ ]&#62;* /
     / &#60;+ [ a .. z _ ] &#62;* /      # whitespace allowed after +</pre>

<a id="line_1734"></a>
<a id="line_1735"></a>
<a id="line_1736"></a>
<a id="line_1737"></a>
<a id="line_1738"></a>

</li>

<li>Character classes can be combined (additively or subtractively) within a single set of angle brackets. Whitespace is ignored. For example:
<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-metasyntax/charset.t#L33-L140"><code>S05-metasyntax/charset.t</code> lines <code>33&ndash;140</code></a>
  </p>
</div>
  


<a id="line_1739"></a>
<a id="line_1740"></a>


<pre>     / &#60;[a..z] - [aeiou] + xdigit&#62; /      # consonant or hex digit</pre>

<a id="line_1741"></a>
<a id="line_1742"></a>


<p>A named character class may be used by itself:</p>

<a id="line_1743"></a>
<a id="line_1744"></a>


<pre>    &#60;alpha&#62;</pre>

<a id="line_1745"></a>
<a id="line_1746"></a>
<a id="line_1747"></a>
<a id="line_1748"></a>


<p>However, in order to combine classes you must prefix a named character class with <code>+</code> or <code>-</code>. Whitespace is required before any <code>-</code> that would be misparsed as an identifier extender.</p>

<a id="line_1749"></a>
<a id="line_1750"></a>
<a id="line_1751"></a>
<a id="line_1752"></a>
<a id="line_1753"></a>
<a id="line_1754"></a>

</li>

<li>One can use character classes as assertions. The following two expressions are equivalent and match a variable that does not start with a sigil assuming that <code>&#60;variable&#62;</code> can also match a sigil less variable.
<a id="line_1755"></a>
<a id="line_1756"></a>
<a id="line_1757"></a>


<pre>   &#60;?[<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="a88ce8">[email&#160;protected]</a>%&#38;]&#62; &#60;variable&#62;
   &#60;?before &#60;[<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="a88ce8">[email&#160;protected]</a>%&#38;]&#62; &#62; &#60;variable&#62;</pre>

<a id="line_1758"></a>
<a id="line_1759"></a>
<a id="line_1760"></a>
<a id="line_1761"></a>
<a id="line_1762"></a>

</li>

<li>Unicode properties are indicated by use of pair notation in place of a normal rule name:
<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-metasyntax/unicode-property-pair.t#L6-L22"><code>S05-metasyntax/unicode-property-pair.t</code> lines <code>6&ndash;22</code></a>
  </p>
</div>
  


<a id="line_1763"></a>
<a id="line_1764"></a>
<a id="line_1765"></a>


<pre>    &#60;:Letter&#62;   # a letter
    &#60;:!Letter&#62;  # a non-letter</pre>

<a id="line_1766"></a>
<a id="line_1767"></a>


<p>Properties with arguments are passed as the argument to the pair:</p>

<a id="line_1768"></a>
<a id="line_1769"></a>
<a id="line_1770"></a>


<pre>    &#60;:East_Asian_Width&#60;Narrow&#62;&#62;
    &#60;:!Blk&#60;ASCII&#62;&#62;</pre>

<a id="line_1771"></a>
<a id="line_1772"></a>
<a id="line_1773"></a>


<p>The pair value is smartmatched against the value in the Unicode Character Database.</p>

<a id="line_1774"></a>
<a id="line_1775"></a>


<pre>    &#60;:Nv(0 ^..^ 1)&#62;     # the char has a proper fractional value</pre>

<a id="line_1776"></a>
<a id="line_1777"></a>
<a id="line_1778"></a>


<p>As a particular case of smartmatching, TR18 section 2.6 is satisfied with a pattern as the argument:</p>

<a id="line_1779"></a>
<a id="line_1780"></a>


<pre>    &#60;:name(/^LATIN LETTER.*P$/)&#62;</pre>

<a id="line_1781"></a>
<a id="line_1782"></a>
<a id="line_1783"></a>
<a id="line_1784"></a>

</li>

<li>Multiple of these terms may be combined with pluses and minuses:
<a id="line_1785"></a>
<a id="line_1786"></a>


<pre>    &#60;+ :HexDigit - :Upper &#62;</pre>

<a id="line_1787"></a>
<a id="line_1788"></a>
<a id="line_1789"></a>
<a id="line_1790"></a>
<a id="line_1791"></a>
<a id="line_1792"></a>
<a id="line_1793"></a>
<a id="line_1794"></a>
<a id="line_1795"></a>


<p>Terms may also be combined using <code>&#38;</code> for set intersection, <code>|</code> for set union, and <code>^</code> for symmetric set difference. Parens may be used for grouping. (Square brackets always quote literal characters (including backslashed literal forms), and may not be nested, unlike the suggested notation in TR18 section 1.3.) The precedence of the operators is the same as the correspondingly named operators in <a href="http://design.perl6.org/S03.html#Operator_precedence" class="podlinkpod"
>&#34;Operator precedence&#34; in S03</a>, even though they have somewhat different semantics.</p>

<a id="line_1796"></a>
<a id="line_1797"></a>
<a id="line_1798"></a>
<a id="line_1799"></a>
<a id="line_1800"></a>
<a id="line_1801"></a>

</li>

<li>Extra long characters may be entered by quoting them and including them via intersection. Any quoted characters will be treated as &#34;longest tokens&#34; when appropriate. Here &#39;ll&#39; would be recognized in preference to &#39;l&#39;:
<a id="line_1802"></a>
<a id="line_1803"></a>


<pre>    / &#60;[ a..z ] | &#39;&#241;&#39; | &#39;ch&#39; | &#39;ll&#39; | &#39;rr&#39;&#62;</pre>

<a id="line_1804"></a>
<a id="line_1805"></a>
<a id="line_1806"></a>


<p>Note that a negated character class containing &#34;long characters&#34; always advances by a single character.</p>

<a id="line_1807"></a>
<a id="line_1808"></a>
<a id="line_1809"></a>
<a id="line_1810"></a>
<a id="line_1811"></a>
<a id="line_1812"></a>
<a id="line_1813"></a>

</li>

<li>When any character constructor such as <code>\c</code>, <code>\x</code>, or <code>\o</code> contains multiple values separated by commas, these are treated as &#34;long characters&#34;. So you could add a <code>\c[13,10]</code> to the list above to match CRLF as a long character.
<a id="line_1814"></a>
<a id="line_1815"></a>
<a id="line_1816"></a>
<a id="line_1817"></a>


<p>A consequence of this is that the negated form advances by a single position (matching as <code>.</code> does) when the long character doesn&#39;t match as a whole. Hence, this matches:</p>

<a id="line_1818"></a>
<a id="line_1819"></a>


<pre>    &#34;\c[13,13,10,10]&#34; ~~ /\C[13,10]* \c[13,10] \C[13,10]/;</pre>

<a id="line_1820"></a>
<a id="line_1821"></a>


<p>If you want it to mean \C13\C10 instead, then you can just write it that way.</p>

<a id="line_1822"></a>
<a id="line_1823"></a>
<a id="line_1824"></a>
<a id="line_1825"></a>

</li>

<li>A leading <code>!</code> indicates a negated meaning (always a zero-width assertion):
<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-metasyntax/angle-brackets.t#L239-L339"><code>S05-metasyntax/angle-brackets.t</code> lines <code>239&ndash;339</code></a>
  </p>
</div>
  


<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-mass/rx.t#L2108-L2146"><code>S05-mass/rx.t</code> lines <code>2108&ndash;2146</code></a>
  </p>
</div>
  


<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-mass/rx.t#L2147-L2382"><code>S05-mass/rx.t</code> lines <code>2147&ndash;2382</code></a>
  </p>
</div>
  


<a id="line_1826"></a>
<a id="line_1827"></a>


<pre>     / &#60;!before _ &#62; /    # We aren&#39;t before an _</pre>

<a id="line_1828"></a>
<a id="line_1829"></a>
<a id="line_1830"></a>
<a id="line_1831"></a>
<a id="line_1832"></a>


<p>Note that <code>&#60;!alpha&#62;</code> is different from <code>&#60;-alpha&#62;</code>. <code>/&#60;-alpha&#62;/</code> is a complemented character class equivalent to <code>/&#60;!before &#60;alpha&#62;&#62; ./</code>, whereas <code>&#60;!alpha&#62;</code> is a zero-width assertion equivalent to a <code>/&#60;!before &#60;alpha&#62;&#62;/</code> assertion.</p>

<a id="line_1833"></a>
<a id="line_1834"></a>
<a id="line_1835"></a>


<p>Note also that as a metacharacter <code>!</code> doesn&#39;t change the parsing rules of whatever follows (unlike, say, <code>+</code> or <code>-</code>).</p>

<a id="line_1836"></a>
<a id="line_1837"></a>
<a id="line_1838"></a>
<a id="line_1839"></a>
<a id="line_1840"></a>
<a id="line_1841"></a>
<a id="line_1842"></a>

</li>

<li>A leading <code>?</code> indicates a positive zero-width assertion, and like <code>!</code> merely reparses the rest of the assertion recursively as if the <code>?</code> were not there. In addition to forcing zero-width, it also suppresses any named capture:
<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-mass/rx.t#L443-L465"><code>S05-mass/rx.t</code> lines <code>443&ndash;465</code></a>
  </p>
</div>
  


<a id="line_1843"></a>
<a id="line_1844"></a>
<a id="line_1845"></a>
<a id="line_1846"></a>


<pre>    &#60;alpha&#62;     # match a letter and capture to $alpha (eventually $&#60;alpha&#62;)
    &#60;.alpha&#62;    # match a letter, don&#39;t capture
    &#60;?alpha&#62;    # match null before a letter, don&#39;t capture</pre>

<a id="line_1847"></a>
<a id="line_1848"></a>


<p>The special named assertions include:</p>

<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-metasyntax/lookaround.t#L13-L33"><code>S05-metasyntax/lookaround.t</code> lines <code>13&ndash;33</code></a>
  </p>
</div>
  


<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-mass/rx.t#L466-L519"><code>S05-mass/rx.t</code> lines <code>466&ndash;519</code></a>
  </p>
</div>
  


<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-mass/charsets.t#L5-L56"><code>S05-mass/charsets.t</code> lines <code>5&ndash;56</code></a>
  </p>
</div>
  


<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-mass/stdrules.t#L15-L307"><code>S05-mass/stdrules.t</code> lines <code>15&ndash;307</code></a>
  </p>
</div>
  


<a id="line_1849"></a>
<a id="line_1850"></a>
<a id="line_1851"></a>


<pre>     / &#60;?before pattern&#62; /    # lookahead
     / &#60;?after pattern&#62; /     # lookbehind</pre>

<a id="line_1852"></a>
<a id="line_1853"></a>


<pre>     / &#60;?same&#62; /              # true between two identical characters</pre>

<a id="line_1854"></a>
<a id="line_1855"></a>
<a id="line_1856"></a>
<a id="line_1857"></a>


<pre>     / &#60;.ws&#62; /                # match &#34;whitespace&#34;:
                              #   \s+ if it&#39;s between two \w characters,
                              #   \s* otherwise</pre>

<a id="line_1858"></a>
<a id="line_1859"></a>
<a id="line_1860"></a>
<a id="line_1861"></a>


<pre>     / &#60;?at($pos)&#62; /          # match only at a particular position
                              # short for &#60;?{ .pos === $pos }&#62;
                              # (considered declarative until $pos changes)</pre>

<a id="line_1862"></a>
<a id="line_1863"></a>
<a id="line_1864"></a>
<a id="line_1865"></a>
<a id="line_1866"></a>


<p>It is legal to use any of these assertions as named captures by omitting the punctuation at the front. However, capture entails some overhead in both memory and computation, so in general you want to suppress that for data you aren&#39;t interested in preserving.</p>

<a id="line_1867"></a>
<a id="line_1868"></a>
<a id="line_1869"></a>
<a id="line_1870"></a>


<p>The <code>after</code> assertion implements lookbehind by reversing the syntax tree and looking for things in the opposite order going to the left. It is illegal to do lookbehind on a pattern that cannot be reversed.</p>

<a id="line_1871"></a>
<a id="line_1872"></a>
<a id="line_1873"></a>


<p>Note: the effect of a forward-scanning lookbehind at the top level can be achieved with:</p>

<a id="line_1874"></a>
<a id="line_1875"></a>


<pre>    / .*? prestuff &#60;( mainpat )&#62; /</pre>

<a id="line_1876"></a>
<a id="line_1877"></a>
<a id="line_1878"></a>
<a id="line_1879"></a>
<a id="line_1880"></a>
<a id="line_1881"></a>
<a id="line_1882"></a>
<a id="line_1883"></a>

</li>

<li>A leading <code>*</code> indicates that the following pattern allows a partial match. It always succeeds after matching as many characters as possible. (It is not zero-width unless 0 characters match.) For instance, to match a number of abbreviations, you might write any of:
<a id="line_1884"></a>
<a id="line_1885"></a>
<a id="line_1886"></a>
<a id="line_1887"></a>
<a id="line_1888"></a>
<a id="line_1889"></a>
<a id="line_1890"></a>


<pre>    s/ ^ G&#60;*n|enesis&#62;     $ /gen/  or
    s/ ^ Ex&#60;*odus&#62;        $ /ex/   or
    s/ ^ L&#60;*v|eviticus&#62;   $ /lev/  or
    s/ ^ N&#60;*m|umbers&#62;     $ /num/  or
    s/ ^ D&#60;*t|euteronomy&#62; $ /deut/ or
    ...</pre>

<a id="line_1891"></a>
<a id="line_1892"></a>


<pre>    / (&#60;* &#60; foo bar baz &#62; &#62;) /</pre>

<a id="line_1893"></a>
<a id="line_1894"></a>


<pre>    / &#60;short=*@abbrev&#62; / and return %long{$&#60;short&#62;} || $&#60;short&#62;;</pre>

<a id="line_1895"></a>
<a id="line_1896"></a>
<a id="line_1897"></a>
<a id="line_1898"></a>
<a id="line_1899"></a>


<p>The pattern is restricted to declarative forms that can be rewritten as nested optional character matches. Sequence information may not be discarded while making all following characters optional. That is, it is not sufficient to rewrite:</p>

<a id="line_1900"></a>
<a id="line_1901"></a>


<pre>    &#60;*xyz&#62;</pre>

<a id="line_1902"></a>
<a id="line_1903"></a>


<p>as:</p>

<a id="line_1904"></a>
<a id="line_1905"></a>


<pre>    x? y? z?            # bad, would allow xz</pre>

<a id="line_1906"></a>
<a id="line_1907"></a>


<p>Instead, it must be implemented as:</p>

<a id="line_1908"></a>
<a id="line_1909"></a>


<pre>    [x [y z?]?]?        # allow only x, xy, xyz (and &#39;&#39;)</pre>

<a id="line_1910"></a>
<a id="line_1911"></a>


<p>Explicit quantifiers are allowed on single characters, so this:</p>

<a id="line_1912"></a>
<a id="line_1913"></a>


<pre>    &#60;* a b+ c | ax*&#62;</pre>

<a id="line_1914"></a>
<a id="line_1915"></a>


<p>is rewritten as something like:</p>

<a id="line_1916"></a>
<a id="line_1917"></a>


<pre>    [a [b+ c?]?]? | [a x*]?</pre>

<a id="line_1918"></a>
<a id="line_1919"></a>
<a id="line_1920"></a>
<a id="line_1921"></a>


<p>In the latter example we&#39;re assuming the DFA token matcher is going to give us the longest match regardless. It&#39;s also possible that quantified multi-character sequences can be recursively remapped:</p>

<a id="line_1922"></a>
<a id="line_1923"></a>
<a id="line_1924"></a>
<a id="line_1925"></a>


<pre>    &#60;* &#39;ab&#39;+&#62;     # match a, ab, ababa, etc. (but not aab!)
    ==&#62; [ &#39;ab&#39;* &#60;*ab&#62; ]
    ==&#62; [ &#39;ab&#39;* [a b?]? ]</pre>

<a id="line_1926"></a>
<a id="line_1927"></a>
<a id="line_1928"></a>
<a id="line_1929"></a>
<a id="line_1930"></a>
<a id="line_1931"></a>
<a id="line_1932"></a>
<a id="line_1933"></a>
<a id="line_1934"></a>
<a id="line_1935"></a>


<p>[Conjecture: depending on how fancy we get, we might (or might not) be able to autodetect ambiguities in <code>&#60;*@abbrev&#62;</code> and refuse to generate ambiguous abbreviations (although exact match of a shorter abbrev should always be allowed even if it&#39;s the prefix of a longer abbreviation). If it is not possible, then the user will have to check for ambiguities after the match. Note also that the array form is assuming the array doesn&#39;t change often. If it does, the longest-token matcher has to be recalculated, which could get expensive.]</p>

<a id="line_1936"></a>
<a id="line_1937"></a>
<a id="line_1938"></a>
<a id="line_1939"></a>
<a id="line_1940"></a>
<a id="line_1941"></a>
<a id="line_1942"></a>

</li>

<li>A leading <code>~~</code> indicates a recursive call back into some or all of the current rule. An optional argument indicates which subpattern to re-use, and if provided must resolve to a single subpattern. If omitted, the entire pattern is called recursively:
<a id="line_1943"></a>
<a id="line_1944"></a>
<a id="line_1945"></a>
<a id="line_1946"></a>


<pre>    &#60;~~&#62;       # call myself recursively
    &#60;~~0&#62;      # match according to $0&#39;s pattern
    &#60;~~foo&#62;    # match according to $&#60;foo&#62;&#39;s pattern</pre>

<a id="line_1947"></a>
<a id="line_1948"></a>
<a id="line_1949"></a>


<p>Note that this rematches the pattern associated with the name, not the string matched. So</p>

<a id="line_1950"></a>
<a id="line_1951"></a>


<pre>    $_ = &#34;foodbard&#34;</pre>

<a id="line_1952"></a>
<a id="line_1953"></a>
<a id="line_1954"></a>
<a id="line_1955"></a>


<pre>    / ( foo | bar ) d $0 /      # fails; doesn&#39;t match &#34;foo&#34; literally
    / ( foo | bar ) d &#60;$0&#62; /    # fails; doesn&#39;t match /foo/ as subrule
    / ( foo | bar ) d &#60;~~0&#62; /   # matches using rule associated with $0</pre>

<a id="line_1956"></a>
<a id="line_1957"></a>


<p>The last is equivalent to</p>

<a id="line_1958"></a>
<a id="line_1959"></a>


<pre>    / ( foo | bar ) d ( foo | bar ) /</pre>

<a id="line_1960"></a>
<a id="line_1961"></a>


<p>Note that the &#34;self&#34; call of</p>

<a id="line_1962"></a>
<a id="line_1963"></a>


<pre>    / &#60;term&#62; &#60;operator&#62; &#60;~~&#62; /</pre>

<a id="line_1964"></a>
<a id="line_1965"></a>
<a id="line_1966"></a>
<a id="line_1967"></a>
<a id="line_1968"></a>


<p>calls back into this anonymous rule as a subrule, and is implicitly anchored to the end of the operator as any other subrule would be. Despite the fact that the outer rule scans the string, the inner call to it does not.</p>

<a id="line_1969"></a>
<a id="line_1970"></a>


<p>Note that a consequence of the previous section is that you also get</p>

<a id="line_1971"></a>
<a id="line_1972"></a>


<pre>    &#60;!~~&#62;</pre>

<a id="line_1973"></a>
<a id="line_1974"></a>


<p>for free, which fails if the current rule would match again at this location.</p>

<a id="line_1975"></a>
<a id="line_1976"></a>
<a id="line_1977"></a>
<a id="line_1978"></a>
<a id="line_1979"></a>
<a id="line_1980"></a>

</li>

<li>A leading <code>|</code> indicates some kind of a zero-width boundary. You can refer to backslash sequences with this syntax; <code>&#60;|h&#62;</code> will match between a <code>\h</code> and a <code>\H</code>, for instance. Some examples:
<a id="line_1981"></a>
<a id="line_1982"></a>
<a id="line_1983"></a>
<a id="line_1984"></a>


<pre>    &#60;|w&#62; word boundary
    &#60;|g&#62; grapheme boundary (always matches in grapheme mode)
    &#60;|c&#62; codepoint boundary (always matches in grapheme/codepoint mode)</pre>

<a id="line_1985"></a>
<a id="line_1986"></a>

</li>
</ul>

<a id="line_1987"></a>
<a id="line_1988"></a>


<p>The following tokens include angles but are not required to balance:</p>

<a id="line_1989"></a>
<a id="line_1990"></a>
<a id="line_1991"></a>
<a id="line_1992"></a>
<a id="line_1993"></a>
<a id="line_1994"></a>
<a id="line_1995"></a>
<a id="line_1996"></a>
<a id="line_1997"></a>
<a id="line_1998"></a>


<ul>
<li>A <code>&#60;(</code> token indicates the start of the match&#39;s overall capture, while the corresponding <code>)&#62;</code> token indicates its endpoint. When matched, these behave as assertions that are always true, but have the side effect of setting the <code>.from</code> and <code>.to</code> attributes of the match object. That is:
<a id="line_1999"></a>
<a id="line_2000"></a>


<pre>    / foo &#60;( \d+ )&#62; bar /</pre>

<a id="line_2001"></a>
<a id="line_2002"></a>


<p>is equivalent to:</p>

<a id="line_2003"></a>
<a id="line_2004"></a>


<pre>    / &#60;?after foo&#62; \d+ &#60;?before bar&#62; /</pre>

<a id="line_2005"></a>
<a id="line_2006"></a>
<a id="line_2007"></a>
<a id="line_2008"></a>
<a id="line_2009"></a>
<a id="line_2010"></a>
<a id="line_2011"></a>
<a id="line_2012"></a>


<p>except that the scan for &#34;<code>foo</code>&#34; can be done in the forward direction, while a lookbehind assertion would presumably scan for <code>\d+</code> and then match &#34;<code>foo</code>&#34; backwards. The use of <code>&#60;(...)&#62;</code> affects only the positions of the beginning and ending of the match, and anything calculated based on those positions. For instance, after the match above, <code>$()</code> contains only the digits matched, and <code>$/.to</code> is pointing to after the digits. Other captures (named or numbered) are unaffected and may be accessed through <code>$/</code>.</p>

<a id="line_2013"></a>
<a id="line_2014"></a>
<a id="line_2015"></a>
<a id="line_2016"></a>
<a id="line_2017"></a>
<a id="line_2018"></a>
<a id="line_2019"></a>
<a id="line_2020"></a>
<a id="line_2021"></a>
<a id="line_2022"></a>
<a id="line_2023"></a>


<p>When used directly within quantifiers (that is, within quantified square brackets), there is only one <code>Match</code> object to set <code>.from</code>/<code>.to</code> on, so the <code>&#60;(</code> token always sets <code>.from</code> to the leftmost matching position, while <code>)&#62;</code> always sets <code>.to</code> to the rightmost position. However, the situation is different for capturing parentheses. When used within parentheses (whether or not the parens are quantified), the <code>Match</code> being generated by each dynamic capture serves as the target, so each such capturing group sets its own <code>.from</code>/<code>.to</code>. Hence, if the group is quantified, each capture sets its own boundaries independently.</p>

<a id="line_2024"></a>
<a id="line_2025"></a>


<p>These tokens are considered declarative.</p>

<a id="line_2026"></a>
<a id="line_2027"></a>
<a id="line_2028"></a>
<a id="line_2029"></a>
<a id="line_2030"></a>
<a id="line_2031"></a>
<a id="line_2032"></a>
<a id="line_2033"></a>
<a id="line_2034"></a>
<a id="line_2035"></a>

</li>

<li>A <code>&#171;</code> or <code>&#60;&#60;</code> token indicates a left word boundary. A <code>&#187;</code> or <code>&#62;&#62;</code> token indicates a right word boundary. (As separate tokens, these need not be balanced.) Perl 5&#39;s <code>\b</code> is replaced by a <code>&#60;|w&#62;</code> &#34;word boundary&#34; assertion, while <code>\B</code> becomes <code>&#60;!|w&#62;</code>. (None of these are dependent on the definition of <code>&#60;.ws&#62;</code>, but only on the <code>\w</code> definition of &#34;word&#34; characters. Non-space mark characters are ignored in calculating word properties of the preceding character. See TR18 1.4.)
<a id="line_2036"></a>
<a id="line_2037"></a>

</li>
</ul>

<a id="line_2038"></a>
<a id="line_2039"></a>
<a id="line_2040"></a>
<a id="line_2041"></a>


<h2><a class='u' href='#___top' title='click to go to top of document'
name="Predefined_Subrules"
>Predefined Subrules</a></h2>

<p>These are some of the predefined subrules for any grammar or regex:</p>

<a id="line_2042"></a>
<a id="line_2043"></a>
<a id="line_2044"></a>
<a id="line_2045"></a>
<a id="line_2046"></a>
<a id="line_2047"></a>
<a id="line_2048"></a>


<ul>
<li>ident <!--
	INDEX: ident
--><!--
	INDEX: &#60;ident&#62;
-->
<p>Match an identifier.</p>

<a id="line_2049"></a>
<a id="line_2050"></a>
<a id="line_2051"></a>
<a id="line_2052"></a>
<a id="line_2053"></a>

</li>

<li>upper <!--
	INDEX: upper
--><!--
	INDEX: &#60;upper&#62;
-->
<p>Match a single uppercase character.</p>

<a id="line_2054"></a>
<a id="line_2055"></a>
<a id="line_2056"></a>
<a id="line_2057"></a>
<a id="line_2058"></a>

</li>

<li>lower <!--
	INDEX: lower
--><!--
	INDEX: &#60;lower&#62;
-->
<p>Match a single lowercase character.</p>

<a id="line_2059"></a>
<a id="line_2060"></a>
<a id="line_2061"></a>
<a id="line_2062"></a>
<a id="line_2063"></a>

</li>

<li>alpha <!--
	INDEX: alpha
--><!--
	INDEX: &#60;alpha&#62;
-->
<p>Match a single alphabetic character, or an underscore.</p>

<a id="line_2064"></a>
<a id="line_2065"></a>
<a id="line_2066"></a>


<p>To match Unicode alphabetic characters without the underscore, use <code>&#60;:alpha&#62;</code>.</p>

<a id="line_2067"></a>
<a id="line_2068"></a>
<a id="line_2069"></a>
<a id="line_2070"></a>
<a id="line_2071"></a>

</li>

<li>digit <!--
	INDEX: digit
--><!--
	INDEX: &#60;digit&#62;
-->
<p>Match a single digit.</p>

<a id="line_2072"></a>
<a id="line_2073"></a>
<a id="line_2074"></a>
<a id="line_2075"></a>
<a id="line_2076"></a>

</li>

<li>xdigit <!--
	INDEX: xdigit
--><!--
	INDEX: &#60;xdigit&#62;
-->
<p>Match a single hexadecimal digit.</p>

<a id="line_2077"></a>
<a id="line_2078"></a>
<a id="line_2079"></a>
<a id="line_2080"></a>
<a id="line_2081"></a>

</li>

<li>print <!--
	INDEX: print
--><!--
	INDEX: &#60;print&#62;
-->
<p>Match a single printable character.</p>

<a id="line_2082"></a>
<a id="line_2083"></a>
<a id="line_2084"></a>
<a id="line_2085"></a>
<a id="line_2086"></a>

</li>

<li>graph <!--
	INDEX: graph
--><!--
	INDEX: &#60;graph&#62;
-->
<p>Match a single &#34;graphical&#34; character.</p>

<a id="line_2087"></a>
<a id="line_2088"></a>
<a id="line_2089"></a>
<a id="line_2090"></a>
<a id="line_2091"></a>
<a id="line_2092"></a>
<a id="line_2093"></a>
<a id="line_2094"></a>
<a id="line_2095"></a>
<a id="line_2096"></a>

</li>

<li>cntrl <!--
	INDEX: cntrl
--><!--
	INDEX: &#60;cntrl&#62;
-->
<p>Match a single &#34;control&#34; character (equivalent to the &#60;:Cc&#62; property). A control character is usually one that doesn&#39;t produce output as such but instead controls the terminal somehow: for example newline and backspace are control characters. All characters with ord() less than 32 are usually classified as control characters (assuming ASCII, the ISO Latin character sets, and Unicode), as is the character with the ord() value of 127 (DEL). The characters from 128 to 159 are also control characters.</p>

<a id="line_2097"></a>
<a id="line_2098"></a>
<a id="line_2099"></a>
<a id="line_2100"></a>
<a id="line_2101"></a>
<a id="line_2102"></a>

</li>

<li>punct <!--
	INDEX: punct
--><!--
	INDEX: &#60;punct&#62;
-->
<p>Match a single punctuation character (that is, any character from the Unicode General Category &#34;Punctuation&#34;).</p>

<a id="line_2103"></a>
<a id="line_2104"></a>
<a id="line_2105"></a>
<a id="line_2106"></a>
<a id="line_2107"></a>

</li>

<li>alnum <!--
	INDEX: alnum
--><!--
	INDEX: &#60;alnum&#62;
-->
<p>Match a single alphanumeric character. This is equivalent to &#60;+alpha +digit&#62; .</p>

<a id="line_2108"></a>
<a id="line_2109"></a>
<a id="line_2110"></a>
<a id="line_2111"></a>
<a id="line_2112"></a>
<a id="line_2113"></a>
<a id="line_2114"></a>
<a id="line_2115"></a>

</li>

<li>wb <!--
	INDEX: wb
--><!--
	INDEX: &#60;wb&#62;
-->
<p>Returns a zero-width match that is true at word boundaries. A word boundary is a spot with a &#34;\w&#34; on one side and a &#34;\W&#34; on the other side (in either order), counting the beginning and end of the string as matching &#34;\W&#34;.</p>

<a id="line_2116"></a>
<a id="line_2117"></a>
<a id="line_2118"></a>
<a id="line_2119"></a>
<a id="line_2120"></a>

</li>

<li>ww <!--
	INDEX: ww
--><!--
	INDEX: &#60;ww&#62;
-->
<p>Matches between two word characters (zero-width match).</p>

<a id="line_2121"></a>
<a id="line_2122"></a>
<a id="line_2123"></a>
<a id="line_2124"></a>
<a id="line_2125"></a>
<a id="line_2126"></a>
<a id="line_2127"></a>

</li>

<li>ws <!--
	INDEX: ws
--><!--
	INDEX: &#60;ws&#62;
-->
<p>Matches required whitespace between two word characters, optional whitespace otherwise. This is roughly equivalent to <code>&#60;!ww&#62; \s*</code> (<code>ws</code> isn&#39;t required to use the <code>ww</code> subrule).</p>

<a id="line_2128"></a>
<a id="line_2129"></a>
<a id="line_2130"></a>
<a id="line_2131"></a>
<a id="line_2132"></a>

</li>

<li>space <!--
	INDEX: space
--><!--
	INDEX: &#60;space&#62;
-->
<p>Match a single whitespace character (same as <code> \s </code> ).</p>

<a id="line_2133"></a>
<a id="line_2134"></a>
<a id="line_2135"></a>
<a id="line_2136"></a>
<a id="line_2137"></a>
<a id="line_2138"></a>

</li>

<li>blank <!--
	INDEX: blank
--><!--
	INDEX: &#60;blank&#62;
-->
<p>Match a single &#34;blank&#34; character -- in most locales, this corresponds to space and tab.</p>

<a id="line_2139"></a>
<a id="line_2140"></a>
<a id="line_2141"></a>
<a id="line_2142"></a>
<a id="line_2143"></a>
<a id="line_2144"></a>
<a id="line_2145"></a>

</li>

<li>before <code>pattern</code> <!--
	INDEX: before
--><!--
	INDEX: &#60;before&#62;
-->
<p>Perform lookahead -- i.e., check if we&#39;re at a position where <code>pattern</code> matches. Returns a zero-width <code>Match</code> object on success.</p>

<a id="line_2146"></a>
<a id="line_2147"></a>
<a id="line_2148"></a>
<a id="line_2149"></a>
<a id="line_2150"></a>
<a id="line_2151"></a>
<a id="line_2152"></a>

</li>

<li>after <code>pattern</code> <!--
	INDEX: after
--><!--
	INDEX: &#60;after&#62;
-->
<p>Perform lookbehind -- i.e., check if the string before the current position matches &#60;pattern&#62; (anchored at the end). Returns a zero-width <code>Match</code> object on success.</p>

<a id="line_2153"></a>
<a id="line_2154"></a>
<a id="line_2155"></a>
<a id="line_2156"></a>
<a id="line_2157"></a>

</li>

<li>&#60;?&#62; <!--
	INDEX: ?
--><!--
	INDEX: &#60;?&#62;
-->
<p>Match a null string, viz., always returns true</p>

<a id="line_2158"></a>
<a id="line_2159"></a>
<a id="line_2160"></a>
<a id="line_2161"></a>
<a id="line_2162"></a>

</li>

<li>&#60;!&#62; <!--
	INDEX: !
--><!--
	INDEX: &#60;!&#62;
-->
<p>Inverse of &#60;?&#62;, viz., always returns false.</p>

<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-mass/stdrules.t#L308-L333"><code>S05-mass/stdrules.t</code> lines <code>308&ndash;333</code></a>
  </p>
</div>
  


<a id="line_2163"></a>
<a id="line_2164"></a>

</li>
</ul>

<a id="line_2165"></a>
<a id="line_2166"></a>
<a id="line_2167"></a>
<a id="line_2168"></a>
<a id="line_2169"></a>
<a id="line_2170"></a>
<a id="line_2171"></a>
<a id="line_2172"></a>
<a id="line_2173"></a>
<a id="line_2174"></a>
<a id="line_2175"></a>
<a id="line_2176"></a>
<a id="line_2177"></a>


<h1><a class='u' href='#___top' title='click to go to top of document'
name="Backslash_reform"
>Backslash reform</a></h1>

<ul>
<li>Many <code>\p</code> and <code>\P</code> properties become intrinsic grammar rules such as (<code>&#60;alpha&#62;</code> and <code>&#60;-alpha&#62;</code>). They may be combined using the above-mentioned character class notation: <code>&#60;[-]+alpha+digit&#62;</code>. Regardless of the higher-level character class names, all low-level Unicode properties are always available with a prefix of colon, that is, in pair notation within the angle brackets. Hence, <code>&#60;+:Lu+:Lt&#62;</code> is equivalent to <code>&#60;+upper+title&#62;</code>.
<a id="line_2178"></a>
<a id="line_2179"></a>
<a id="line_2180"></a>
<a id="line_2181"></a>
<a id="line_2182"></a>
<a id="line_2183"></a>
<a id="line_2184"></a>

</li>

<li>The <code>\L...\E</code>, <code>\U...\E</code>, and <code>\Q...\E</code> sequences are gone. The single-character case modifiers <code>\l</code> and <code>\u</code> are also gone. In the rare cases that need them you can use <code>&#60;{ lc $regex }&#62;</code>, <code>&#60;{tc $word}&#62;</code>, etc.
<a id="line_2185"></a>
<a id="line_2186"></a>
<a id="line_2187"></a>
<a id="line_2188"></a>
<a id="line_2189"></a>
<a id="line_2190"></a>

</li>

<li>As mentioned above, the <code>\b</code> and <code>\B</code> word boundary assertions are gone, and are replaced with <code>&#60;|w&#62;</code> (or &#60;wb&#62;) and <code>&#60;!|w&#62;</code> (or &#60;!wb&#62;) zero-width assertions.
<a id="line_2191"></a>
<a id="line_2192"></a>
<a id="line_2193"></a>
<a id="line_2194"></a>
<a id="line_2195"></a>
<a id="line_2196"></a>
<a id="line_2197"></a>

</li>

<li>The <code>\G</code> sequence is gone. Use <code>:p</code> instead. (Note, however, that it makes no sense to use <code>:p</code> within a pattern, since every internal pattern is implicitly anchored to the current position.) See the <code>at</code> assertion below.
<a id="line_2198"></a>
<a id="line_2199"></a>
<a id="line_2200"></a>
<a id="line_2201"></a>
<a id="line_2202"></a>

</li>

<li>Backreferences (e.g. <code>\1</code>, <code>\2</code>, etc.) are gone; <code>$0</code>, <code>$1</code>, etc. can be used instead, because variables are no longer interpolated.
<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-capture/dot.t#L56-L65"><code>S05-capture/dot.t</code> lines <code>56&ndash;65</code></a>
  </p>
</div>
  


<a id="line_2203"></a>
<a id="line_2204"></a>
<a id="line_2205"></a>


<p>Numeric variables are assumed to change every time and therefore are considered procedural, unlike normal variables.</p>

<a id="line_2206"></a>
<a id="line_2207"></a>
<a id="line_2208"></a>
<a id="line_2209"></a>
<a id="line_2210"></a>
<a id="line_2211"></a>
<a id="line_2212"></a>

</li>

<li>New backslash sequences, <code>\h</code> and <code>\v</code>, match horizontal and vertical whitespace respectively, including Unicode. Horizontal whitespace is defined as anything matching <code>\s</code> that doesn&#39;t also match <code>\v</code>. Vertical whitespace is defined as any of:
<a id="line_2213"></a>
<a id="line_2214"></a>
<a id="line_2215"></a>
<a id="line_2216"></a>
<a id="line_2217"></a>
<a id="line_2218"></a>
<a id="line_2219"></a>
<a id="line_2220"></a>


<pre>    U+000A  LINE FEED (LF)
    U+000B  LINE TABULATION
    U+000C  FORM FEED (FF)
    U+000D  CARRIAGE RETURN (CR)
    U+0085  NEXT LINE (NEL)
    U+2028  LINE SEPARATOR
    U+2029  PARAGRAPH SEPARATOR</pre>

<a id="line_2221"></a>
<a id="line_2222"></a>
<a id="line_2223"></a>


<p>Note that <code>U+000D</code> (CARRIAGE RETURN) is considered vertical whitespace despite the fact that it only moves the &#34;carriage&#34; horizontally.</p>

<a id="line_2224"></a>
<a id="line_2225"></a>
<a id="line_2226"></a>
<a id="line_2227"></a>

</li>

<li><code>\s</code> now matches any Unicode whitespace character.
<a id="line_2228"></a>
<a id="line_2229"></a>
<a id="line_2230"></a>
<a id="line_2231"></a>
<a id="line_2232"></a>

</li>

<li>The new backslash sequence <code>\N</code> matches anything except a logical newline; it is the negation of <code>\n</code>.
<a id="line_2233"></a>
<a id="line_2234"></a>
<a id="line_2235"></a>
<a id="line_2236"></a>
<a id="line_2237"></a>

</li>

<li>Other new capital backslash sequences are also the negations of their lowercase counterparts:
<a id="line_2238"></a>
<a id="line_2239"></a>
<a id="line_2240"></a>
<a id="line_2241"></a>
<a id="line_2242"></a>
<a id="line_2243"></a>


<ul>
<li><code>\H</code> matches anything but horizontal whitespace.
<a id="line_2244"></a>
<a id="line_2245"></a>
<a id="line_2246"></a>
<a id="line_2247"></a>

</li>

<li><code>\V</code> matches anything but vertical whitespace.
<a id="line_2248"></a>
<a id="line_2249"></a>
<a id="line_2250"></a>
<a id="line_2251"></a>

</li>

<li><code>\T</code> matches anything but a tab.
<a id="line_2252"></a>
<a id="line_2253"></a>
<a id="line_2254"></a>
<a id="line_2255"></a>

</li>

<li><code>\R</code> matches anything but a return.
<a id="line_2256"></a>
<a id="line_2257"></a>
<a id="line_2258"></a>
<a id="line_2259"></a>

</li>

<li><code>\F</code> matches anything but a formfeed.
<a id="line_2260"></a>
<a id="line_2261"></a>
<a id="line_2262"></a>
<a id="line_2263"></a>

</li>

<li><code>\E</code> matches anything but an escape.
<a id="line_2264"></a>
<a id="line_2265"></a>
<a id="line_2266"></a>
<a id="line_2267"></a>
<a id="line_2268"></a>

</li>

<li><code>\X...</code> matches anything but the specified character (specified in hexadecimal).
<a id="line_2269"></a>
<a id="line_2270"></a>
<a id="line_2271"></a>
<a id="line_2272"></a>
<a id="line_2273"></a>
<a id="line_2274"></a>
<a id="line_2275"></a>
<a id="line_2276"></a>

</li>

<li>Backslash escapes for literal characters in ordinary strings are allowed in regexes (<code>\a</code>, <code>\x</code>, etc.). However, the exception to this rule is <code>\b</code>, which is disallowed in order to avoid conflict with its former use as a word boundary assertion. To match a literal backspace, use <code>\c8</code>, <code>\x8</code>, or a double-quoted <code>\b</code>.
<a id="line_2277"></a>
<a id="line_2278"></a>

</li>
</ul>

<a id="line_2279"></a>
<a id="line_2280"></a>

</li>
</ul>

<a id="line_2281"></a>
<a id="line_2282"></a>
<a id="line_2283"></a>
<a id="line_2284"></a>
<a id="line_2285"></a>


<h2><a class='u' href='#___top' title='click to go to top of document'
name="Character_class_shortcuts"
>Character class shortcuts</a></h2>

<p>For historical and convenience reasons, the following character classes are available as backslash sequences:</p>

<a id="line_2286"></a>
<a id="line_2287"></a>
<a id="line_2288"></a>
<a id="line_2289"></a>
<a id="line_2290"></a>
<a id="line_2291"></a>
<a id="line_2292"></a>
<a id="line_2293"></a>
<a id="line_2294"></a>
<a id="line_2295"></a>
<a id="line_2296"></a>


<pre>   \d      &#60;digit&#62;    A digit
   \D      &#60;-digit&#62;   A nondigit
   \w      &#60;alnum&#62;    A word character
   \W      &#60;-alnum&#62;   A non-word character
   \s                 A whitespace character
   \S                 A non-whitespace character
   \h                 A horizontal whitespace
   \H                 A non-horizontal whitespace
   \v                 A vertical whitespace
   \V                 A non-vertical whitespace</pre>

<a id="line_2297"></a>
<a id="line_2298"></a>
<a id="line_2299"></a>
<a id="line_2300"></a>
<a id="line_2301"></a>
<a id="line_2302"></a>
<a id="line_2303"></a>
<a id="line_2304"></a>


<h1><a class='u' href='#___top' title='click to go to top of document'
name="Regexes_constitute_a_first-class_language,_rather_than_just_being_strings"
>Regexes constitute a first-class language, rather than just being strings</a></h1>

<ul>
<li>The Perl 5 <code>qr/pattern/</code> regex constructor is gone.
<a id="line_2305"></a>
<a id="line_2306"></a>
<a id="line_2307"></a>
<a id="line_2308"></a>

</li>

<li>The Perl 6 equivalents are:
<a id="line_2309"></a>
<a id="line_2310"></a>
<a id="line_2311"></a>


<pre>     regex { pattern }    # always takes {...} as delimiters
     rx    / pattern /    # can take (almost) any chars as delimiters</pre>

<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-metasyntax/delimiters.t#L6-L19"><code>S05-metasyntax/delimiters.t</code> lines <code>6&ndash;19</code></a>
  </p>
</div>
  


<a id="line_2312"></a>
<a id="line_2313"></a>
<a id="line_2314"></a>
<a id="line_2315"></a>
<a id="line_2316"></a>


<p>You may not use whitespace or alphanumerics for delimiters. Space is optional unless needed to distinguish from modifier arguments or function parens. So you may use parens as your <code>rx</code> delimiters, but only if you interpose whitespace:</p>

<a id="line_2317"></a>
<a id="line_2318"></a>
<a id="line_2319"></a>


<pre>     rx ( pattern )      # okay
     rx( 1,2,3 )         # tries to call rx function</pre>

<a id="line_2320"></a>
<a id="line_2321"></a>


<p>(This is true for all quotelike constructs in Perl 6.)</p>

<a id="line_2322"></a>
<a id="line_2323"></a>
<a id="line_2324"></a>
<a id="line_2325"></a>


<p>The <code>rx</code> form may be used directly as a pattern anywhere a normal <code>//</code> match can. The <code>regex</code> form is really a method definition, and must be used in such a way that the grammar class it is to be used in is apparent.</p>

<a id="line_2326"></a>
<a id="line_2327"></a>
<a id="line_2328"></a>
<a id="line_2329"></a>

</li>

<li>If either form needs modifiers, they go before the opening delimiter:
<a id="line_2330"></a>
<a id="line_2331"></a>
<a id="line_2332"></a>


<pre>     $regex = regex :s:i { my name is (.*) };
     $regex = rx:s:i     / my name is (.*) /;    # same thing</pre>

<a id="line_2333"></a>
<a id="line_2334"></a>
<a id="line_2335"></a>
<a id="line_2336"></a>


<p>Space is necessary after the final modifier if you use any bracketing character for the delimiter. (Otherwise it would be taken as an argument to the modifier.)</p>

<a id="line_2337"></a>
<a id="line_2338"></a>
<a id="line_2339"></a>
<a id="line_2340"></a>
<a id="line_2341"></a>

</li>

<li>You may not use colons for the delimiter. Space is allowed between modifiers:
<a id="line_2342"></a>
<a id="line_2343"></a>


<pre>     $regex = rx :s :i / my name is (.*) /;</pre>

<a id="line_2344"></a>
<a id="line_2345"></a>
<a id="line_2346"></a>
<a id="line_2347"></a>
<a id="line_2348"></a>
<a id="line_2349"></a>

</li>

<li>The name of the constructor was changed from <code>qr</code> because it&#39;s no longer an interpolating quote-like operator. <code>rx</code> is short for <i>regex</i>, (not to be confused with regular expressions, except when they are).
<a id="line_2350"></a>
<a id="line_2351"></a>
<a id="line_2352"></a>
<a id="line_2353"></a>
<a id="line_2354"></a>

</li>

<li>As the syntax indicates, it is now more closely analogous to a <code>sub {...}</code> constructor. In fact, that analogy runs <i>very</i> deep in Perl 6.
<a id="line_2355"></a>
<a id="line_2356"></a>
<a id="line_2357"></a>
<a id="line_2358"></a>
<a id="line_2359"></a>
<a id="line_2360"></a>
<a id="line_2361"></a>
<a id="line_2362"></a>

</li>

<li>Just as a raw <code>{...}</code> is now always a closure (which may still execute immediately in certain contexts and be passed as an object in others), so too a raw <code>/.../</code> is now always a <code>Regex</code> object (which may still match immediately in certain contexts and be passed as an object in others).
<a id="line_2363"></a>
<a id="line_2364"></a>
<a id="line_2365"></a>
<a id="line_2366"></a>
<a id="line_2367"></a>
<a id="line_2368"></a>
<a id="line_2369"></a>

</li>

<li>Specifically, a <code>/.../</code> matches immediately in a value context (sink, Boolean, string, or numeric), or when it is an explicit argument of a <code>~~</code>. Otherwise it&#39;s a <code>Regex</code> constructor identical to the explicit <code>regex</code> form. So this:
<a id="line_2370"></a>
<a id="line_2371"></a>


<pre>     $var = /pattern/;</pre>

<a id="line_2372"></a>
<a id="line_2373"></a>
<a id="line_2374"></a>


<p>no longer does the match and sets <code>$var</code> to the result. Instead it assigns a <code>Regex</code> object to <code>$var</code>.</p>

<a id="line_2375"></a>
<a id="line_2376"></a>
<a id="line_2377"></a>
<a id="line_2378"></a>

</li>

<li>The two cases can always be distinguished using <code>m{...}</code> or <code>rx{...}</code>:
<a id="line_2379"></a>
<a id="line_2380"></a>
<a id="line_2381"></a>


<pre>     $match = m{pattern};    # Match regex immediately, assign result
     $regex = rx{pattern};   # Assign regex expression itself</pre>

<a id="line_2382"></a>
<a id="line_2383"></a>
<a id="line_2384"></a>
<a id="line_2385"></a>

</li>

<li>Note that this means that former magically lazy usages like:
<a id="line_2386"></a>
<a id="line_2387"></a>


<pre>     @list = split /pattern/, $str;</pre>

<a id="line_2388"></a>
<a id="line_2389"></a>


<p>are now just consequences of the normal semantics.</p>

<a id="line_2390"></a>
<a id="line_2391"></a>
<a id="line_2392"></a>
<a id="line_2393"></a>
<a id="line_2394"></a>

</li>

<li>It&#39;s now also possible to set up a user-defined subroutine that acts like <code>grep</code>:
<a id="line_2395"></a>
<a id="line_2396"></a>
<a id="line_2397"></a>
<a id="line_2398"></a>
<a id="line_2399"></a>
<a id="line_2400"></a>
<a id="line_2401"></a>
<a id="line_2402"></a>
<a id="line_2403"></a>


<pre>     sub my_grep($selector, *@list) {
         given $selector {
             when Regex { ... }
             when Code  { ... }
             when Hash  { ... }
             # etc.
         }
     }</pre>

<a id="line_2404"></a>
<a id="line_2405"></a>
<a id="line_2406"></a>
<a id="line_2407"></a>
<a id="line_2408"></a>


<p>When you call <code>my_grep</code>, the first argument is bound in item context, so passing <code>{...}</code> or <code>/.../</code> produces a <code>Code</code> or <code>Regex</code> object, which the switch statement then selects upon. (Normal <code>grep</code> just lets a smartmatch operator do all the work.)</p>

<a id="line_2409"></a>
<a id="line_2410"></a>
<a id="line_2411"></a>
<a id="line_2412"></a>
<a id="line_2413"></a>
<a id="line_2414"></a>

</li>

<li>Just as <code>rx</code> has variants, so does the <code>regex</code> declarator. In particular, there are two special variants for use in grammars: <code>token</code> and <code>rule</code>.
<a id="line_2415"></a>
<a id="line_2416"></a>


<p>A token declaration:</p>

<a id="line_2417"></a>
<a id="line_2418"></a>


<pre>    token ident { [ &#60;alpha&#62; | \- ] \w* }</pre>

<a id="line_2419"></a>
<a id="line_2420"></a>
<a id="line_2421"></a>


<p>never backtracks by default. That is, it likes to commit to whatever it has scanned so far. The above is equivalent to</p>

<a id="line_2422"></a>
<a id="line_2423"></a>


<pre>    regex ident { [ &#60;alpha&#62;: | \-: ]: \w*: }</pre>

<a id="line_2424"></a>
<a id="line_2425"></a>
<a id="line_2426"></a>
<a id="line_2427"></a>
<a id="line_2428"></a>
<a id="line_2429"></a>
<a id="line_2430"></a>
<a id="line_2431"></a>
<a id="line_2432"></a>


<p>but rather easier to read. The bare <code>*</code>, <code>+</code>, and <code>?</code> quantifiers never backtrack in a <code>token</code>. In normal regexes, use <code>*:</code>, <code>+:</code>, or <code>?:</code> to prevent any backtracking into the quantifier. If you want to explicitly backtrack, append either a <code>?</code> or a <code>!</code> to the quantifier. The <code>?</code> forces frugal matching as usual, while the <code>!</code> forces greedy matching. The <code>token</code> declarator is really just short for</p>

<a id="line_2433"></a>
<a id="line_2434"></a>


<pre>    regex :ratchet { ... }</pre>

<a id="line_2435"></a>
<a id="line_2436"></a>
<a id="line_2437"></a>
<a id="line_2438"></a>
<a id="line_2439"></a>


<p>The other is the <code>rule</code> declarator, for declaring non-terminal productions in a grammar. Like a <code>token</code>, it also does not backtrack by default. In addition, a <code>rule</code> regex also assumes <code>:sigspace</code>. A <code>rule</code> is really short for:</p>

<a id="line_2440"></a>
<a id="line_2441"></a>


<pre>    regex :ratchet :sigspace { ... }</pre>

<a id="line_2442"></a>
<a id="line_2443"></a>
<a id="line_2444"></a>
<a id="line_2445"></a>
<a id="line_2446"></a>

</li>

<li>The Perl 5 <code>?...?</code> syntax (<i>succeed once</i>) was rarely used and can be now emulated more cleanly with a state variable:
<a id="line_2447"></a>
<a id="line_2448"></a>


<pre>    $result = do { state $x ||= m/ pattern /; }    # only matches first time</pre>

<a id="line_2449"></a>
<a id="line_2450"></a>
<a id="line_2451"></a>


<p>To reset the pattern, simply say <code>$x = 0</code>. Though if you want <code>$x</code> visible you&#39;d have to avoid using a block:</p>

<a id="line_2452"></a>
<a id="line_2453"></a>
<a id="line_2454"></a>
<a id="line_2455"></a>


<pre>    $result = state $x ||= m/ pattern /;
    ...
    $x = 0;</pre>

<a id="line_2456"></a>
<a id="line_2457"></a>

</li>
</ul>

<a id="line_2458"></a>
<a id="line_2459"></a>
<a id="line_2460"></a>
<a id="line_2461"></a>
<a id="line_2462"></a>


<h1><a class='u' href='#___top' title='click to go to top of document'
name="Backtracking_control"
>Backtracking control</a></h1>

<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-metasyntax/longest-alternative.t#L480-L490"><code>S05-metasyntax/longest-alternative.t</code> lines <code>480&ndash;490</code></a>
  </p>
</div>
  


<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-metasyntax/sequential-alternation.t#L38-L48"><code>S05-metasyntax/sequential-alternation.t</code> lines <code>38&ndash;48</code></a>
  </p>
</div>
  


<p>Within those portions of a pattern that are considered procedural rather than declarative, you may control the backtracking behavior.</p>

<a id="line_2463"></a>
<a id="line_2464"></a>
<a id="line_2465"></a>
<a id="line_2466"></a>
<a id="line_2467"></a>
<a id="line_2468"></a>
<a id="line_2469"></a>
<a id="line_2470"></a>


<ul>
<li>By default, backtracking is greedy in <code>rx</code>, <code>m</code>, <code>s</code>, and the like. It&#39;s also greedy in ordinary <code>regex</code> declarations. In <code>rule</code> and <code>token</code> declarations, backtracking must be explicit.
<a id="line_2471"></a>
<a id="line_2472"></a>
<a id="line_2473"></a>
<a id="line_2474"></a>
<a id="line_2475"></a>
<a id="line_2476"></a>
<a id="line_2477"></a>
<a id="line_2478"></a>

</li>

<li>To force the preceding atom to do frugal backtracking (also sometimes known as &#34;eager matching&#34; or &#34;minimal matching&#34;), append a <code>:?</code> or <code>?</code> to the atom. If the preceding token is a quantifier, the <code>:</code> may be omitted, so <code>*?</code> works just as in Perl 5.
<a id="line_2479"></a>
<a id="line_2480"></a>
<a id="line_2481"></a>
<a id="line_2482"></a>
<a id="line_2483"></a>
<a id="line_2484"></a>
<a id="line_2485"></a>
<a id="line_2486"></a>

</li>

<li>To force the preceding atom to do greedy backtracking in a spot that would default otherwise, append a <code>:!</code> to the atom. If the preceding token is a quantifier, the <code>:</code> may be omitted. (Perl 5 has no corresponding construct because backtracking always defaults to greedy in Perl 5.)
<a id="line_2487"></a>
<a id="line_2488"></a>
<a id="line_2489"></a>
<a id="line_2490"></a>
<a id="line_2491"></a>
<a id="line_2492"></a>

</li>

<li>To force the preceding atom to do no backtracking, use a single <code>:</code> without a subsequent <code>?</code> or <code>!</code>. Backtracking over a single colon causes the regex engine not to retry the preceding atom:
<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-mass/rx.t#L9-L33"><code>S05-mass/rx.t</code> lines <code>9&ndash;33</code></a>
  </p>
</div>
  


<a id="line_2493"></a>
<a id="line_2494"></a>


<pre>     ms/ \( &#60;expr&#62; [ , &#60;expr&#62; ]*: \) /</pre>

<a id="line_2495"></a>
<a id="line_2496"></a>
<a id="line_2497"></a>


<p>(i.e. there&#39;s no point trying fewer <code>&#60;expr&#62;</code> matches, if there&#39;s no closing parenthesis on the horizon)</p>

<a id="line_2498"></a>
<a id="line_2499"></a>
<a id="line_2500"></a>


<p>When modifying a quantifier, a <code>+</code> may be used instead of a <code>:</code>, in which case the quantifier is often known as a <i>possessive</i> quantifier.</p>

<a id="line_2501"></a>
<a id="line_2502"></a>


<pre>     ms/ \( &#60;expr&#62; [ , &#60;expr&#62; ]*+ \) /  # same thing</pre>

<a id="line_2503"></a>
<a id="line_2504"></a>
<a id="line_2505"></a>


<p>To force all the atoms in an expression not to backtrack by default, use <code>:ratchet</code> or <code>rule</code> or <code>token</code>.</p>

<a id="line_2506"></a>
<a id="line_2507"></a>
<a id="line_2508"></a>
<a id="line_2509"></a>
<a id="line_2510"></a>

</li>

<li>Evaluating a double colon throws away all saved choice points in the current <a href="#Longest-token_matching" class="podlinkpod"
>LTM</a> alternation.
<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-mass/rx.t#L34-L50"><code>S05-mass/rx.t</code> lines <code>34&ndash;50</code></a>
  </p>
</div>
  


<a id="line_2511"></a>
<a id="line_2512"></a>
<a id="line_2513"></a>
<a id="line_2514"></a>
<a id="line_2515"></a>
<a id="line_2516"></a>


<pre>     ms/ [ if :: &#60;expr&#62; &#60;block&#62;
         | for :: &#60;list&#62; &#60;block&#62;
         | loop :: &#60;loop_controls&#62;? &#60;block&#62;
         ]
     /</pre>

<a id="line_2517"></a>
<a id="line_2518"></a>
<a id="line_2519"></a>


<p>(i.e. there&#39;s no point trying to match a different keyword if one was already found but failed).</p>

<a id="line_2520"></a>
<a id="line_2521"></a>
<a id="line_2522"></a>
<a id="line_2523"></a>


<p>The <code>::</code> also has the effect of hiding any declarative match on the right from &#34;longest token&#34; processing by <code>|</code>. Only the left side is evaluated for determinacy.</p>

<a id="line_2524"></a>
<a id="line_2525"></a>
<a id="line_2526"></a>
<a id="line_2527"></a>


<p><code>::</code> does nothing if there is no current LTM alternation. &#34;Current&#34; is defined dynamically, not lexically. A <code>::</code> in a subrule will affect the enclosing alternation.</p>

<a id="line_2528"></a>
<a id="line_2529"></a>
<a id="line_2530"></a>
<a id="line_2531"></a>
<a id="line_2532"></a>

</li>

<li>Evaluating a <code>::&#62;</code> throws away all saved choice points in the current innermost temporal alternation. It thus acts as a &#34;then&#34;.
<a id="line_2533"></a>
<a id="line_2534"></a>
<a id="line_2535"></a>
<a id="line_2536"></a>
<a id="line_2537"></a>
<a id="line_2538"></a>
<a id="line_2539"></a>


<pre>    ms/ [
        || &#60;?{ $a == 1 }&#62; ::&#62; &#60;foo&#62;
        || &#60;?{ $a == 2 }&#62; ::&#62; &#60;bar&#62;
        || &#60;?{ $a == 3 }&#62; ::&#62; &#60;baz&#62;
        ]
    /</pre>

<a id="line_2540"></a>
<a id="line_2541"></a>
<a id="line_2542"></a>
<a id="line_2543"></a>
<a id="line_2544"></a>
<a id="line_2545"></a>
<a id="line_2546"></a>


<p>Note that you can still back into the &#34;then&#34; part of such an alternation, so you may also need to put <code>:</code> after it if you also want to disable that. If an explicit or implicit <code>:ratchet</code> has disabled backtracking by supplying an implicit <code>:</code>, you need to put an explicit <code>!</code> after the alternation to enable backing into, say, the <code>&#60;foo&#62;</code> rule above.</p>

<a id="line_2547"></a>
<a id="line_2548"></a>
<a id="line_2549"></a>
<a id="line_2550"></a>


<p><code>::&#62;</code> does nothing if there is no current temporal alternation. &#34;Current&#34; is defined dynamically, not lexically. A <code>::&#62;</code> in a subrule will affect the enclosing alternation.</p>

<a id="line_2551"></a>
<a id="line_2552"></a>
<a id="line_2553"></a>
<a id="line_2554"></a>
<a id="line_2555"></a>
<a id="line_2556"></a>

</li>

<li>Evaluating a triple colon throws away all saved choice points since the current regex was entered. Backtracking to (or past) this point will fail the rule outright (no matter where in the regex it occurs):
<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-mass/rx.t#L51-L85"><code>S05-mass/rx.t</code> lines <code>51&ndash;85</code></a>
  </p>
</div>
  


<a id="line_2557"></a>
<a id="line_2558"></a>
<a id="line_2559"></a>
<a id="line_2560"></a>
<a id="line_2561"></a>


<pre>     regex ident {
           ( [&#60;alpha&#62;|\-] \w* ) ::: { fail if %reserved{$0} }
         || &#34; [&#60;alpha&#62;|\-] \w* &#34;
     }</pre>

<a id="line_2562"></a>
<a id="line_2563"></a>


<pre>     ms/ get &#60;ident&#62;? /</pre>

<a id="line_2564"></a>
<a id="line_2565"></a>


<p>(i.e. using an unquoted reserved word as an identifier is not permitted)</p>

<a id="line_2566"></a>
<a id="line_2567"></a>
<a id="line_2568"></a>
<a id="line_2569"></a>
<a id="line_2570"></a>
<a id="line_2571"></a>
<a id="line_2572"></a>

</li>

<li>Evaluating a <code>&#60;commit&#62;</code> assertion throws away all saved choice points since the start of the entire match. Backtracking to (or past) this point will fail the entire match, no matter how many subrules down it happens:
<a id="line_2573"></a>
<a id="line_2574"></a>
<a id="line_2575"></a>
<a id="line_2576"></a>
<a id="line_2577"></a>


<pre>     regex subname {
         ([&#60;alpha&#62;|\-] \w*) &#60;commit&#62; { fail if %reserved{$0} }
     }
     ms/ sub &#60;subname&#62;? &#60;block&#62; /</pre>

<a id="line_2578"></a>
<a id="line_2579"></a>
<a id="line_2580"></a>


<p>(i.e. using a reserved word as a subroutine name is instantly fatal to the <i>surrounding</i> match as well)</p>

<a id="line_2581"></a>
<a id="line_2582"></a>
<a id="line_2583"></a>


<p>If commit is given an argument, it&#39;s the name of a calling rule that should be committed:</p>

<a id="line_2584"></a>
<a id="line_2585"></a>


<pre>    &#60;commit(&#39;infix&#39;)&#62;</pre>

<a id="line_2586"></a>
<a id="line_2587"></a>
<a id="line_2588"></a>
<a id="line_2589"></a>
<a id="line_2590"></a>
<a id="line_2591"></a>
<a id="line_2592"></a>
<a id="line_2593"></a>
<a id="line_2594"></a>
<a id="line_2595"></a>

</li>

<li>A <code>&#60;cut&#62;</code> assertion always matches successfully, and has the side effect of logically deleting the parts of the string already matched. Whether this actually frees up the memory immediately may depend on various interactions among your backreferences, the string implementation, and the garbage collector. In any case, the string will report that it has been chopped off on the front. It&#39;s illegal to use <code>&#60;cut&#62;</code> on a string that you do not have write access to.
<a id="line_2596"></a>
<a id="line_2597"></a>
<a id="line_2598"></a>
<a id="line_2599"></a>
<a id="line_2600"></a>
<a id="line_2601"></a>


<p>Attempting to backtrack past a <code>&#60;cut&#62;</code> causes the complete match to fail (like backtracking past a <code>&#60;commit&#62;</code>). This is because there&#39;s now no preceding text to backtrack into. This is useful for throwing away successfully processed input when matching from an input stream or an iterator of arbitrary length.</p>

<a id="line_2602"></a>
<a id="line_2603"></a>

</li>
</ul>

<a id="line_2604"></a>
<a id="line_2605"></a>
<a id="line_2606"></a>
<a id="line_2607"></a>
<a id="line_2608"></a>
<a id="line_2609"></a>
<a id="line_2610"></a>
<a id="line_2611"></a>


<h1><a class='u' href='#___top' title='click to go to top of document'
name="Regex_Routines,_Named_and_Anonymous"
>Regex Routines, Named and Anonymous</a></h1>

<ul>
<li>The analogy between <code>sub</code> and <code>regex</code> extends much further.
<a id="line_2612"></a>
<a id="line_2613"></a>
<a id="line_2614"></a>
<a id="line_2615"></a>

</li>

<li>Just as you can have anonymous subs and named subs...
<a id="line_2616"></a>
<a id="line_2617"></a>
<a id="line_2618"></a>
<a id="line_2619"></a>
<a id="line_2620"></a>

</li>

<li>...so too you can have anonymous regexes and <i>named</i> regexes (and tokens, and rules):
<a id="line_2621"></a>
<a id="line_2622"></a>


<pre>     token ident { [&#60;alpha&#62;|\-] \w* }</pre>

<a id="line_2623"></a>
<a id="line_2624"></a>


<pre>     # and later...</pre>

<a id="line_2625"></a>
<a id="line_2626"></a>


<pre>     @ids = grep /&#60;ident&#62;/, @strings;</pre>

<a id="line_2627"></a>
<a id="line_2628"></a>
<a id="line_2629"></a>
<a id="line_2630"></a>
<a id="line_2631"></a>

</li>

<li>As the above example indicates, it&#39;s possible to refer to named regexes, such as:
<a id="line_2632"></a>
<a id="line_2633"></a>
<a id="line_2634"></a>


<pre>     regex serial_number { &#60;[A..Z]&#62; \d**8 }
     token type { alpha | beta | production | deprecated | legacy }</pre>

<a id="line_2635"></a>
<a id="line_2636"></a>


<p>in other regexes as named assertions:</p>

<a id="line_2637"></a>
<a id="line_2638"></a>


<pre>     rule identification { [soft|hard]ware &#60;type&#62; &#60;serial_number&#62; }</pre>

<a id="line_2639"></a>
<a id="line_2640"></a>
<a id="line_2641"></a>


<p>These keyword-declared regexes are officially of type <code>Method</code>, which is derived from <code>Routine</code>.</p>

<a id="line_2642"></a>
<a id="line_2643"></a>
<a id="line_2644"></a>
<a id="line_2645"></a>
<a id="line_2646"></a>
<a id="line_2647"></a>
<a id="line_2648"></a>
<a id="line_2649"></a>
<a id="line_2650"></a>


<p>In general, the anchoring of any subrule call is controlled by its calling context. When a regex, token, or rule method is called as a subrule, the front is anchored to the current position (as with <code>:p</code>), while the end is not anchored, since the calling context will likely wish to continue parsing. However, when such a method is smartmatched directly, it is automatically anchored on both ends to the beginning and end of the string. Thus, you can do direct pattern matching by using an anonymous regex routine as a standalone pattern:</p>

<a id="line_2651"></a>
<a id="line_2652"></a>
<a id="line_2653"></a>
<a id="line_2654"></a>


<pre>    $string ~~ regex { \d+ }
    $string ~~ token { \d+ }
    $string ~~ rule { \d+ }</pre>

<a id="line_2655"></a>
<a id="line_2656"></a>


<p>and these are equivalent to</p>

<a id="line_2657"></a>
<a id="line_2658"></a>
<a id="line_2659"></a>
<a id="line_2660"></a>


<pre>    $string ~~ m/^ \d+ $/;
    $string ~~ m/^ \d+: $/;
    $string ~~ m/^ &#60;.ws&#62; \d+: &#60;.ws&#62; $/;</pre>

<a id="line_2661"></a>
<a id="line_2662"></a>
<a id="line_2663"></a>
<a id="line_2664"></a>


<p>The basic rule of thumb is that the keyword-defined methods never do implicit <code>.*?</code>-like scanning, while the <code>m//</code> and <code>s///</code> quotelike forms do such scanning in the absence of explicit anchoring.</p>

<a id="line_2665"></a>
<a id="line_2666"></a>
<a id="line_2667"></a>
<a id="line_2668"></a>
<a id="line_2669"></a>
<a id="line_2670"></a>


<p>The <code>rx//</code> and <code>//</code> forms can go either way: they scan when used directly within a smartmatch or boolean context, but when called indirectly as a subrule they do not scan. That is, the object returned by <code>rx//</code> behaves like <code>m//</code> when used directly, but like <code>regex</code> <code>{}</code> when used as a subrule:</p>

<a id="line_2671"></a>
<a id="line_2672"></a>
<a id="line_2673"></a>
<a id="line_2674"></a>


<pre>    $pattern = rx/foo/;
    $string ~~ $pattern;                  # equivalent to m/foo/;
    $string ~~ /&#39;[&#39; &#60;$pattern&#62; &#39;]&#39;/       # equivalent to /&#39;[foo]&#39;/</pre>

<a id="line_2675"></a>
<a id="line_2676"></a>

</li>
</ul>

<a id="line_2677"></a>
<a id="line_2678"></a>
<a id="line_2679"></a>
<a id="line_2680"></a>
<a id="line_2681"></a>
<a id="line_2682"></a>
<a id="line_2683"></a>
<a id="line_2684"></a>


<h1><a class='u' href='#___top' title='click to go to top of document'
name="Nothing_is_illegal"
>Nothing is illegal</a></h1>

<ul>
<li>The empty pattern is now illegal.
<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-mass/rx.t#L2383-L2396"><code>S05-mass/rx.t</code> lines <code>2383&ndash;2396</code></a>
  </p>
</div>
  


<a id="line_2685"></a>
<a id="line_2686"></a>
<a id="line_2687"></a>
<a id="line_2688"></a>
<a id="line_2689"></a>

</li>

<li>To match the zero-width string, you must use some explicit representation of the null match:
<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-metasyntax/null.t#L17-L25"><code>S05-metasyntax/null.t</code> lines <code>17&ndash;25</code></a>
  </p>
</div>
  


<a id="line_2690"></a>
<a id="line_2691"></a>
<a id="line_2692"></a>


<pre>    / &#39;&#39; /;
    / &#60;?&#62; /;</pre>

<a id="line_2693"></a>
<a id="line_2694"></a>


<p>For example:</p>

<a id="line_2695"></a>
<a id="line_2696"></a>


<pre>     split /&#39;&#39;/, $string</pre>

<a id="line_2697"></a>
<a id="line_2698"></a>


<p>splits between characters. But then, so does this:</p>

<a id="line_2699"></a>
<a id="line_2700"></a>


<pre>     split &#39;&#39;, $string</pre>

<a id="line_2701"></a>
<a id="line_2702"></a>
<a id="line_2703"></a>
<a id="line_2704"></a>

</li>

<li>Likewise, to match an empty alternative, use something like:
<a id="line_2705"></a>
<a id="line_2706"></a>
<a id="line_2707"></a>


<pre>     /a|b|c|&#60;?&#62;/
     /a|b|c|&#39;&#39;/</pre>

<a id="line_2708"></a>
<a id="line_2709"></a>


<p>This makes it easier to catch errors like this:</p>

<a id="line_2710"></a>
<a id="line_2711"></a>


<pre>    /a|b|c|/</pre>

<a id="line_2712"></a>
<a id="line_2713"></a>


<p>As a special case, however, the first null alternative in a match like</p>

<a id="line_2714"></a>
<a id="line_2715"></a>
<a id="line_2716"></a>
<a id="line_2717"></a>
<a id="line_2718"></a>
<a id="line_2719"></a>
<a id="line_2720"></a>


<pre>     ms/ [
         | if :: &#60;expr&#62; &#60;block&#62;
         | for :: &#60;list&#62; &#60;block&#62;
         | loop :: &#60;loop_controls&#62;? &#60;block&#62;
         ]
     /</pre>

<a id="line_2721"></a>
<a id="line_2722"></a>
<a id="line_2723"></a>


<p>is simply ignored. Only the first alternative is special that way. If you write:</p>

<a id="line_2724"></a>
<a id="line_2725"></a>
<a id="line_2726"></a>
<a id="line_2727"></a>
<a id="line_2728"></a>
<a id="line_2729"></a>
<a id="line_2730"></a>


<pre>     ms/ [
             if :: &#60;expr&#62; &#60;block&#62;              |
             for :: &#60;list&#62; &#60;block&#62;             |
             loop :: &#60;loop_controls&#62;? &#60;block&#62;  |
         ]
     /</pre>

<a id="line_2731"></a>


<a id="line_2732"></a>
<a id="line_2733"></a>


<p>it&#39;s still an error.</p>

<a id="line_2734"></a>
<a id="line_2735"></a>
<a id="line_2736"></a>
<a id="line_2737"></a>
<a id="line_2738"></a>

</li>

<li>However, it&#39;s okay for a non-null syntactic construct to have a degenerate case matching the null string:
<a id="line_2739"></a>
<a id="line_2740"></a>
<a id="line_2741"></a>


<pre>     $something = &#34;&#34;;
     /a|b|c|$something/;</pre>

<a id="line_2742"></a>
<a id="line_2743"></a>
<a id="line_2744"></a>


<p>In particular, <code>&#60;?&#62;</code> always matches the null string successfully, and <code>&#60;!&#62;</code> always fails to match anything.</p>

<a id="line_2745"></a>
<a id="line_2746"></a>

</li>
</ul>

<a id="line_2747"></a>
<a id="line_2748"></a>
<a id="line_2749"></a>
<a id="line_2750"></a>
<a id="line_2751"></a>
<a id="line_2752"></a>
<a id="line_2753"></a>
<a id="line_2754"></a>


<h1><a class='u' href='#___top' title='click to go to top of document'
name="Longest-token_matching"
>Longest-token matching</a></h1>

<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-metasyntax/longest-alternative.t#L52-L479"><code>S05-metasyntax/longest-alternative.t</code> lines <code>52&ndash;479</code></a>
  </p>
</div>
  


<p>Since &#34;longest-token matching&#34; is a long phrase, we will usually refer to this idea as <b>LTM</b>. The basic notion is that LTM is how people tend to parse text in their heads, so the computer ought to try to do the same. And parsing with LTM is all about how the computer decides which alternative of a set of alternatives is going to match.</p>

<a id="line_2755"></a>
<a id="line_2756"></a>
<a id="line_2757"></a>
<a id="line_2758"></a>
<a id="line_2759"></a>
<a id="line_2760"></a>
<a id="line_2761"></a>


<p>Instead of representing temporal alternation as it does in Perl 5, in Perl 6 <code>|</code> represents logical alternation with declarative longest-token semantics. (You may now use <code>||</code> to indicate the old temporal alternation. That is, <code>|</code> and <code>||</code> now work within regex syntax much the same as they do outside of regex syntax, where they represent junctional and short-circuit OR. This includes the fact that <code>|</code> has tighter precedence than <code>||</code>.)</p>

<a id="line_2762"></a>
<a id="line_2763"></a>
<a id="line_2764"></a>
<a id="line_2765"></a>
<a id="line_2766"></a>
<a id="line_2767"></a>
<a id="line_2768"></a>
<a id="line_2769"></a>
<a id="line_2770"></a>
<a id="line_2771"></a>
<a id="line_2772"></a>
<a id="line_2773"></a>
<a id="line_2774"></a>
<a id="line_2775"></a>
<a id="line_2776"></a>
<a id="line_2777"></a>
<a id="line_2778"></a>


<p>Historically regex processing has proceeded in Perl via a backtracking NFA algorithm. This is quite powerful, but many parsers work more efficiently by processing rules in parallel rather than one after another, at least up to a point. If you look at something like a yacc grammar, you find a lot of pattern/action declarations where the patterns are considered in parallel, and eventually the grammar decides which action to fire off. While the default Perl view of parsing is essentially top-down (perhaps with a bottom-up &#34;middle layer&#34; to handle operator precedence), it is extremely useful for user understanding if at least the token processing proceeds deterministically. So for regex matching purposes we define token patterns as those patterns that can be matched without potential side effects or self-reference. (Since whitespace often has side effects at line transitions, it is usually excluded from such patterns, give or take a little lookahead.) Basically, Perl automatically derives a lexer from the grammar without you having to write one yourself.</p>

<a id="line_2779"></a>
<a id="line_2780"></a>
<a id="line_2781"></a>
<a id="line_2782"></a>
<a id="line_2783"></a>
<a id="line_2784"></a>
<a id="line_2785"></a>
<a id="line_2786"></a>
<a id="line_2787"></a>
<a id="line_2788"></a>
<a id="line_2789"></a>


<p>To that end, every regex in Perl 6 is required to be able to distinguish its &#34;pure&#34; patterns from its actions, and return its list of initial token patterns (transitively including the token patterns of any subrule called by the &#34;pure&#34; part of that regex, but not including any subrule more than once, since that would involve self reference, which is not allowed in traditional regular expressions). A logical alternation using <code>|</code> then takes two or more of these lists and dispatches to the alternative that matches the longest token prefix. This may or may not be the alternative that comes first lexically.</p>

<a id="line_2790"></a>
<a id="line_2791"></a>
<a id="line_2792"></a>
<a id="line_2793"></a>
<a id="line_2794"></a>
<a id="line_2795"></a>
<a id="line_2796"></a>
<a id="line_2797"></a>
<a id="line_2798"></a>
<a id="line_2799"></a>
<a id="line_2800"></a>


<p>However, if two alternatives match at the same length, the tie is broken first by specificity. The alternative that starts with the longest fixed string wins; that is, an exact match counts as closer than a match made using character classes. If that doesn&#39;t work, the tie is broken by one of two methods. If the alternatives are in different grammars, standard MRO (method resolution order) determines which one to try first. If the alternatives are in the same grammar file, the textually earlier alternative takes precedence. (If a grammar&#39;s rules are defined in more than one file, the order is undefined, and an explicit assertion must be used to force failure if the wrong one is tried first.)</p>

<a id="line_2801"></a>
<a id="line_2802"></a>
<a id="line_2803"></a>
<a id="line_2804"></a>
<a id="line_2805"></a>
<a id="line_2806"></a>
<a id="line_2807"></a>
<a id="line_2808"></a>
<a id="line_2809"></a>
<a id="line_2810"></a>
<a id="line_2811"></a>


<p>This longest token prefix corresponds roughly to the notion of &#34;token&#34; in other parsing systems that use a lexer, but in the case of Perl this is largely an epiphenomenon derived automatically from the grammar definition. However, despite being automatically calculated, the set of tokens can be modified by the user; various constructs within a regex declaratively tell the grammar engine that it is finished with the pattern part and starting in on the side effects, so by inserting such constructs the user controls what is considered a token and what is not. The constructs deemed to terminate a token declaration and start the &#34;action&#34; part of the pattern include:</p>

<a id="line_2812"></a>
<a id="line_2813"></a>
<a id="line_2814"></a>
<a id="line_2815"></a>
<a id="line_2816"></a>
<a id="line_2817"></a>


<ul>
<li>Any :: or ::: backtracking control (but not the : possessive modifier).
<a id="line_2818"></a>
<a id="line_2819"></a>
<a id="line_2820"></a>
<a id="line_2821"></a>

</li>

<li>Any atom that is quantified with a frugal match (using the <code>?</code> modifier).
<a id="line_2822"></a>
<a id="line_2823"></a>
<a id="line_2824"></a>
<a id="line_2825"></a>
<a id="line_2826"></a>
<a id="line_2827"></a>
<a id="line_2828"></a>
<a id="line_2829"></a>

</li>

<li>Any <code>{...}</code> action, but not an assertion containing a closure. (The empty closure <code>{}</code> is customarily used to explicitly terminate the pure part of the pattern.) The closure form of the general <code>**{...}</code> quantifier also terminates the longest token, but the closureless forms of quantifier do not.
<a id="line_2830"></a>
<a id="line_2831"></a>
<a id="line_2832"></a>
<a id="line_2833"></a>

</li>

<li>Any sequential control flow operator such as <code>||</code> or <code>&#38;&#38;</code>.
<a id="line_2834"></a>
<a id="line_2835"></a>
<a id="line_2836"></a>
<a id="line_2837"></a>
<a id="line_2838"></a>
<a id="line_2839"></a>
<a id="line_2840"></a>
<a id="line_2841"></a>
<a id="line_2842"></a>
<a id="line_2843"></a>

</li>

<li>As a consequence of the previous point, and because the standard grammar&#39;s <code>&#60;ws&#62;</code> rule defines whitespace using <code>||</code>, the longest token is also terminated by any part of the regex or rule that <i>might</i> match whitespace using that rule, including whitespace implicitly matched via <code>:sigspace</code>. (However, token declarations are specifically allowed to recognize whitespace within a token by using such lower-level primitives as <code>\h+</code> or other character classes.)
<a id="line_2844"></a>
<a id="line_2845"></a>

</li>
</ul>

<a id="line_2846"></a>
<a id="line_2847"></a>
<a id="line_2848"></a>
<a id="line_2849"></a>
<a id="line_2850"></a>
<a id="line_2851"></a>
<a id="line_2852"></a>


<p>Subpatterns (captures) specifically do not terminate the token pattern, but may require a reparse of the token to find the location of the subpatterns. Likewise assertions may need to be checked out after the longest token is determined. (Alternately, if DFA semantics are simulated in any of various ways, such as by Thompson NFA, it may be possible to know when to fire off the assertions without backchecks.)</p>

<a id="line_2853"></a>
<a id="line_2854"></a>
<a id="line_2855"></a>


<p>Greedy quantifiers and character classes do not terminate a token pattern. Zero-width assertions such as word boundaries are also okay.</p>

<a id="line_2856"></a>
<a id="line_2857"></a>
<a id="line_2858"></a>
<a id="line_2859"></a>
<a id="line_2860"></a>


<p>Because such assertions can be part of the token, the lexer engine must be able to recover from the failure of such an assertion and backtrack to the next best token candidate, which might be the same length or shorter, but can never be longer than the current candidate.</p>

<a id="line_2861"></a>
<a id="line_2862"></a>
<a id="line_2863"></a>
<a id="line_2864"></a>
<a id="line_2865"></a>
<a id="line_2866"></a>
<a id="line_2867"></a>
<a id="line_2868"></a>
<a id="line_2869"></a>
<a id="line_2870"></a>


<p>For a pattern that contains a positive lookahead assertion such as <code>&#60;?foo&#62;</code> or <code>&#60;?before \s&#62;</code>, the assertion is assumed to be more specific than the subsequent pattern, so the lookahead&#39;s pattern is counted as the final part of the longest token; the longest-token matcher will be smart enough to treat the extra bit as 0-width, that is, to rematch any text traversed by the lookahead when (and if) it continues the match. (Indeed, if the entire lookahead is pure enough to participate in LTM, the rematcher may simply optimize away the rematching, since the lookahead already matched in the LTM engine.)</p>

<a id="line_2871"></a>
<a id="line_2872"></a>
<a id="line_2873"></a>
<a id="line_2874"></a>
<a id="line_2875"></a>
<a id="line_2876"></a>
<a id="line_2877"></a>
<a id="line_2878"></a>
<a id="line_2879"></a>
<a id="line_2880"></a>
<a id="line_2881"></a>
<a id="line_2882"></a>


<p>However, for a pattern that contains a negative lookahead assertion such as <code>&#60;!foo&#62;</code> or <code>&#60;!before \s&#62;</code>, just the opposite is true: the subsequent pattern is assumed to be more specific than the assertion&#39;s. So LTM completely ignores negative lookaheads, and continues to look for pure patterns in whatever follows the negative lookahead. You might say that positive lookaheads are opaque to LTM, but negative lookaheads are transparent to LTM. As a consequence, if you wish to write a positive lookahead that is transparent to LTM, you may indicate this with a double negation: <code>&#60;!!foo&#62;</code>. (The optimizer is free to remove the double negation, but not the transparency.)</p>

<a id="line_2883"></a>
<a id="line_2884"></a>
<a id="line_2885"></a>
<a id="line_2886"></a>
<a id="line_2887"></a>


<p>Oddly enough, the <code>token</code> keyword specifically does not determine the scope of a token, except insofar as a token pattern usually doesn&#39;t do much matching of whitespace, and whitespace is the prototypical way of terminating tokens.</p>

<a id="line_2888"></a>
<a id="line_2889"></a>
<a id="line_2890"></a>
<a id="line_2891"></a>
<a id="line_2892"></a>
<a id="line_2893"></a>


<p>The initial token matcher must take into account case sensitivity (or any other canonicalization primitives) and do the right thing even when propagated up to rules that don&#39;t have the same canonicalization. That is, they must continue to represent the set of matches that the lower rule would match.</p>

<a id="line_2894"></a>
<a id="line_2895"></a>
<a id="line_2896"></a>
<a id="line_2897"></a>
<a id="line_2898"></a>
<a id="line_2899"></a>
<a id="line_2900"></a>
<a id="line_2901"></a>
<a id="line_2902"></a>
<a id="line_2903"></a>
<a id="line_2904"></a>
<a id="line_2905"></a>


<p>The <code>||</code> form has the old short-circuit semantics, and will not attempt to match its right side unless all possibilities (including all <code>|</code> possibilities) are exhausted on its left. The first <code>||</code> in a regex makes the token patterns on its left available to the outer longest-token matcher, but hides any subsequent tests from longest-token matching. Every <code>||</code> establishes a new longest-token matcher. That is, if you use <code>|</code> on the right side of <code>||</code>, that right side establishes a new top level scope for longest-token processing for this subexpression and any called subrules. The right side&#39;s longest-token automaton is invisible to the left of the <code>||</code> or outside the regex containing the <code>||</code>.</p>

<a id="line_2906"></a>
<a id="line_2907"></a>
<a id="line_2908"></a>
<a id="line_2909"></a>
<a id="line_2910"></a>
<a id="line_2911"></a>
<a id="line_2912"></a>
<a id="line_2913"></a>
<a id="line_2914"></a>
<a id="line_2915"></a>
<a id="line_2916"></a>
<a id="line_2917"></a>
<a id="line_2918"></a>
<a id="line_2919"></a>
<a id="line_2920"></a>
<a id="line_2921"></a>
<a id="line_2922"></a>


<h1><a class='u' href='#___top' title='click to go to top of document'
name="Return_values_from_matches"
>Return values from matches</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Match_objects"
>Match objects</a></h2>

<ul>
<li>A successful match always returns a <code>Match</code> object, which is generally also put into <code>$/</code>, a dynamic lexical declared in the outer routine that is calling the regex. (A named <code>regex</code>, <code>token</code>, or <code>rule</code> is a routine, and hence declares its own lexical <code>$/</code> variable, which always refers to the most recent submatch within the rule, if any.) The current match state is kept in the regex&#39;s <code>$&#162;</code> variable which will eventually get bound to the user&#39;s <code>$/</code> variable when the match completes.
<a id="line_2923"></a>
<a id="line_2924"></a>
<a id="line_2925"></a>


<p>An unsuccessful match returns <code>Nil</code> (and sets <code>$/</code> to <code>Nil</code> if the match would have set it).</p>

<a id="line_2926"></a>
<a id="line_2927"></a>
<a id="line_2928"></a>
<a id="line_2929"></a>
<a id="line_2930"></a>
<a id="line_2931"></a>
<a id="line_2932"></a>
<a id="line_2933"></a>
<a id="line_2934"></a>

</li>

<li>Notionally, a match object contains (among other things) a boolean success value, an array of ordered submatch objects, and a hash of named submatch objects. (It also optionally carries an <i>abstract object</i> normally used to build up an abstract syntax tree,) To provide convenient access to these various values, the match object evaluates differently in different contexts:
<a id="line_2935"></a>
<a id="line_2936"></a>
<a id="line_2937"></a>
<a id="line_2938"></a>
<a id="line_2939"></a>
<a id="line_2940"></a>
<a id="line_2941"></a>


<ul>
<li>In boolean context it evaluates as true or false (i.e. did the match succeed?):
<a id="line_2942"></a>
<a id="line_2943"></a>
<a id="line_2944"></a>
<a id="line_2945"></a>


<pre>     if /pattern/ {...}
     # or:
     /pattern/; if $/ {...}</pre>

<a id="line_2946"></a>
<a id="line_2947"></a>
<a id="line_2948"></a>
<a id="line_2949"></a>


<p>With <code>:global</code> or <code>:overlap</code> or <code>:exhaustive</code> the boolean is allowed to return true on the first match. The <code>Match</code> object can produce the rest of the results lazily if evaluated in list context.</p>

<a id="line_2950"></a>
<a id="line_2951"></a>
<a id="line_2952"></a>
<a id="line_2953"></a>
<a id="line_2954"></a>

</li>

<li>In string context it evaluates to the stringified value of its match, which is usually the entire matched string:
<a id="line_2955"></a>
<a id="line_2956"></a>
<a id="line_2957"></a>
<a id="line_2958"></a>


<pre>     print %hash{ &#34;{$text ~~ /&#60;.ident&#62;/}&#34; };
     # or equivalently:
     $text ~~ /&#60;.ident&#62;/  &#38;&#38;  print %hash{~$/};</pre>

<a id="line_2959"></a>
<a id="line_2960"></a>


<p>But generally you should say <code>~$/</code> if you mean <code>~$/</code>.</p>

<a id="line_2961"></a>
<a id="line_2962"></a>
<a id="line_2963"></a>
<a id="line_2964"></a>
<a id="line_2965"></a>

</li>

<li>In numeric context it evaluates to the numeric value of its match, which is usually the entire matched string:
<a id="line_2966"></a>
<a id="line_2967"></a>
<a id="line_2968"></a>
<a id="line_2969"></a>


<pre>     $sum += /\d+/;
     # or equivalently:
     /\d+/; $sum = $sum + $/;</pre>

<a id="line_2970"></a>
<a id="line_2971"></a>
<a id="line_2972"></a>
<a id="line_2973"></a>

</li>

<li>When used as a scalar, a <code>Match</code> object evaluates to itself.
<a id="line_2974"></a>
<a id="line_2975"></a>
<a id="line_2976"></a>
<a id="line_2977"></a>
<a id="line_2978"></a>
<a id="line_2979"></a>
<a id="line_2980"></a>


<p>However, sometimes you would like an alternate scalar value to ride along with the match. The <code>Match</code> object itself describes a concrete parse tree, so this extra value is called an <i>abstract</i> object; it rides along as an attribute of the <code>Match</code> object. The <code>.made</code> method by default returns an undefined value. <code>$()</code> is a shorthand for <code>$($/.made // ~$/)</code>.</p>

<a id="line_2981"></a>
<a id="line_2982"></a>
<a id="line_2983"></a>


<p>Therefore <code>$()</code> is usually just the entire match string, but you can override that by calling <code>make</code> inside a regex:</p>

<a id="line_2984"></a>
<a id="line_2985"></a>
<a id="line_2986"></a>
<a id="line_2987"></a>
<a id="line_2988"></a>
<a id="line_2989"></a>


<pre>    my $moose = $(m[
        &#60;antler&#62; &#60;body&#62;
        { make Moose.new( body =&#62; $&#60;body&#62;.attach($&#60;antler&#62;) ) }
        # match succeeds -- ignore the rest of the regex
    ]);</pre>

<a id="line_2990"></a>
<a id="line_2991"></a>
<a id="line_2992"></a>
<a id="line_2993"></a>


<p>This puts the new abstract node into <code>$/.made</code>. An AST node may be of any type. Using the <code>make</code>/<code>.made</code> mechanism, it is convenient to build up an abstract syntax tree of arbitrary node types.</p>

<a id="line_2994"></a>
<a id="line_2995"></a>
<a id="line_2996"></a>
<a id="line_2997"></a>
<a id="line_2998"></a>
<a id="line_2999"></a>


<p>However, the <code>make</code> function is not limited to be used for storing AST nodes and building abstract syntax trees only. This is just a specific Perl 6 internal use of this functionality. Nor does the <code>make</code> function impose any item or list context onto its argument, so if you say something ambiguously listy like</p>

<a id="line_3000"></a>
<a id="line_3001"></a>
<a id="line_3002"></a>
<a id="line_3003"></a>


<pre>    make ()
    make @array
    make foo()</pre>

<a id="line_3004"></a>
<a id="line_3005"></a>
<a id="line_3006"></a>


<p>the value returned from <code>.made</code> will interpolate into a list. To suppress this, use one of these:</p>

<a id="line_3007"></a>
<a id="line_3008"></a>
<a id="line_3009"></a>
<a id="line_3010"></a>
<a id="line_3011"></a>
<a id="line_3012"></a>
<a id="line_3013"></a>


<pre>    make ().item
    make []
    make <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="4c680c2d3e3e2d35">[email&#160;protected]</a>
    make [@array]
    make foo().item
    make $(foo())</pre>

<a id="line_3014"></a>
<a id="line_3015"></a>


<p>or use <code>.made.item</code> or a <code>$</code> variable on the receiving end.</p>

<a id="line_3016"></a>
<a id="line_3017"></a>
<a id="line_3018"></a>
<a id="line_3019"></a>


<p>The <code>.ast</code> method is a synonym <code>.made</code> with no differing behavior. It exists both for historical reasons and as a way to indicate to those reading your code a more AST-like use of the <code>made</code>/<code>.make</code> mechanism.</p>

<a id="line_3020"></a>
<a id="line_3021"></a>
<a id="line_3022"></a>
<a id="line_3023"></a>

</li>

<li>You may also capture a subset of the match using the <code>&#60;(...)&#62;</code> construct:
<a id="line_3024"></a>
<a id="line_3025"></a>
<a id="line_3026"></a>


<pre>    &#34;foo123bar&#34; ~~ / foo &#60;( \d+ )&#62; bar /
    say $();    # says 123</pre>

<a id="line_3027"></a>
<a id="line_3028"></a>
<a id="line_3029"></a>
<a id="line_3030"></a>


<p>In this case <code>$()</code> is always a string when doing string matching, and a list of one or more elements when doing list matching. This construct does not set the <code>.made</code> attribute.</p>

<a id="line_3031"></a>
<a id="line_3032"></a>
<a id="line_3033"></a>
<a id="line_3034"></a>
<a id="line_3035"></a>

</li>

<li>When used as an array, a <code>Match</code> object pretends to be an array of all its positional captures. Hence
<a id="line_3036"></a>
<a id="line_3037"></a>


<pre>     ($key, $val) = ms/ (\S+) &#39;=&#62;&#39; (\S+)/;</pre>

<a id="line_3038"></a>
<a id="line_3039"></a>


<p>can also be written:</p>

<a id="line_3040"></a>
<a id="line_3041"></a>
<a id="line_3042"></a>


<pre>     $result = ms/ (\S+) &#39;=&#62;&#39; (\S+)/;
     ($key, $val) = @$result;</pre>

<a id="line_3043"></a>
<a id="line_3044"></a>


<p>To get a single capture into a string, use a subscript:</p>

<a id="line_3045"></a>
<a id="line_3046"></a>


<pre>     $mystring = &#34;{ ms/ (\S+) &#39;=&#62;&#39; (\S+)/[0] }&#34;;</pre>

<a id="line_3047"></a>
<a id="line_3048"></a>


<p>To get all the captures into a string, use a <i>zen</i> slice:</p>

<a id="line_3049"></a>
<a id="line_3050"></a>


<pre>     $mystring = &#34;{ ms/ (\S+) &#39;=&#62;&#39; (\S+)/[] }&#34;;</pre>

<a id="line_3051"></a>
<a id="line_3052"></a>


<p>Or cast it into an array:</p>

<a id="line_3053"></a>
<a id="line_3054"></a>


<pre>     $mystring = &#34;@( ms/ (\S+) &#39;=&#62;&#39; (\S+)/ )&#34;;</pre>

<a id="line_3055"></a>
<a id="line_3056"></a>
<a id="line_3057"></a>
<a id="line_3058"></a>
<a id="line_3059"></a>
<a id="line_3060"></a>


<p>Note that, as a scalar variable, <code>$/</code> doesn&#39;t automatically flatten in list context. Use <code>@()</code> as a shorthand for <code>@($/)</code> to flatten the positional captures under list context. Note that a <code>Match</code> object is allowed to evaluate its match lazily in list context. Use <code>eager @()</code> to force an eager match.</p>

<a id="line_3061"></a>
<a id="line_3062"></a>
<a id="line_3063"></a>
<a id="line_3064"></a>
<a id="line_3065"></a>
<a id="line_3066"></a>
<a id="line_3067"></a>
<a id="line_3068"></a>
<a id="line_3069"></a>

</li>

<li>When used as a hash, a <code>Match</code> object pretends to be a hash of all its named captures. The keys do not include any sigils, so if you capture to variable <code>@&#60;foo&#62;</code> its real name is <code>$/{&#39;foo&#39;}</code> or <code>$/&#60;foo&#62;</code>. However, you may still refer to it as <code>@&#60;foo&#62;</code> anywhere <code>$/</code> is visible. (But it is erroneous to use the same name for two different capture datatypes.)
<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-capture/subrule.t#L17-L119"><code>S05-capture/subrule.t</code> lines <code>17&ndash;119</code></a>
  </p>
</div>
  


<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-match/capturing-contexts.t#L35-L160"><code>S05-match/capturing-contexts.t</code> lines <code>35&ndash;160</code></a>
  </p>
</div>
  


<a id="line_3070"></a>
<a id="line_3071"></a>
<a id="line_3072"></a>
<a id="line_3073"></a>
<a id="line_3074"></a>


<p>Note that, as a scalar variable, <code>$/</code> doesn&#39;t automatically flatten in list context. Use <code>%()</code> as a shorthand for <code>%($/)</code> to flatten as a hash, or bind it to a variable of the appropriate type. As with <code>@()</code>, it&#39;s possible for <code>%()</code> to produce its pairs lazily in list context.</p>

<a id="line_3075"></a>
<a id="line_3076"></a>
<a id="line_3077"></a>
<a id="line_3078"></a>
<a id="line_3079"></a>
<a id="line_3080"></a>

</li>

<li>The numbered captures may be treated as named, so <code>$&#60;0 1 2&#62;</code> is equivalent to <code>$/[0,1,2]</code>. This allows you to write slices of intermixed named and numbered captures.
<a id="line_3081"></a>
<a id="line_3082"></a>
<a id="line_3083"></a>
<a id="line_3084"></a>
<a id="line_3085"></a>

</li>

<li>The <code>.keys</code>, <code>.values</code> and <code>.kv</code> methods act both on the list and hash part, with the list part coming first.
<a id="line_3086"></a>
<a id="line_3087"></a>
<a id="line_3088"></a>


<pre>    &#39;abcd&#39; ~~ /(.)(.)**2 &#60;alpha&#62;/;
    say ~$/.keys;           # 0 1 alpha</pre>

<a id="line_3089"></a>
<a id="line_3090"></a>
<a id="line_3091"></a>
<a id="line_3092"></a>
<a id="line_3093"></a>
<a id="line_3094"></a>
<a id="line_3095"></a>

</li>

<li>In ordinary code, variables <code>$0</code>, <code>$1</code>, etc. are just aliases into <code>$/[0]</code>, <code>$/[1]</code>, etc. Hence they will all be undefined if the last match failed (unless they were explicitly bound in a closure without using the <code>let</code> keyword).
<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S32-scalar/undef.t#L213-L272"><code>S32-scalar/undef.t</code> lines <code>213&ndash;272</code></a>
  </p>
</div>
  


<a id="line_3096"></a>
<a id="line_3097"></a>

</li>
</ul>

<a id="line_3098"></a>
<a id="line_3099"></a>
<a id="line_3100"></a>
<a id="line_3101"></a>
<a id="line_3102"></a>

</li>

<li><code>Match</code> objects have methods that provide additional information about the match. For example:
<a id="line_3103"></a>
<a id="line_3104"></a>
<a id="line_3105"></a>
<a id="line_3106"></a>
<a id="line_3107"></a>


<pre>     if m/ def &#60;ident&#62; &#60;codeblock&#62; / {
         say &#34;Found sub def from index $/.from.bytes &#34;,
             &#34;to index $/.to.bytes&#34;;
     }</pre>

<a id="line_3108"></a>
<a id="line_3109"></a>


<p>The currently defined methods are</p>

<a id="line_3110"></a>
<a id="line_3111"></a>
<a id="line_3112"></a>
<a id="line_3113"></a>
<a id="line_3114"></a>
<a id="line_3115"></a>
<a id="line_3116"></a>
<a id="line_3117"></a>
<a id="line_3118"></a>
<a id="line_3119"></a>
<a id="line_3120"></a>
<a id="line_3121"></a>


<pre>    $/.from      # the initial match position
    $/.to        # the final match position
    $/.chars     # $/.to - $/.from
    $/.orig      # the original match string
    $/.Str       # substr($/.orig, $/.from, $/.chars)
    $/.made      # the abstract result associated with this node (from make)
    $/.ast       # same as $/.made
    $/.caps      # sequential captures</pre>

<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-capture/caps.t#L5-L93"><code>S05-capture/caps.t</code> lines <code>5&ndash;93</code></a>
  </p>
</div>
  


<pre>    $/.chunks    # sequential tokenization
    $/.prematch  # $/.orig.substr(0, $/.from)
    $/.postmatch # $/.orig.substr($/.to)</pre>

<a id="line_3122"></a>
<a id="line_3123"></a>


<p>Within the regex the current match state <code>$&#162;</code> also provides</p>

<a id="line_3124"></a>
<a id="line_3125"></a>


<pre>    .pos        # the current match position</pre>

<a id="line_3126"></a>
<a id="line_3127"></a>
<a id="line_3128"></a>
<a id="line_3129"></a>


<p>This last value may correspond to either <code>$&#162;.from</code> or <code>$&#162;.to</code> depending on whether the match is proceeding in a forward or backward direction (the latter case arising inside an <code>&#60;?after ...&#62;</code> assertion).</p>

<a id="line_3130"></a>
<a id="line_3131"></a>
<a id="line_3132"></a>
<a id="line_3133"></a>
<a id="line_3134"></a>
<a id="line_3135"></a>
<a id="line_3136"></a>
<a id="line_3137"></a>
<a id="line_3138"></a>
<a id="line_3139"></a>
<a id="line_3140"></a>
<a id="line_3141"></a>

</li>

<li>As described above, a <code>Match</code> in list context returns its positional captures. However, sometimes you&#39;d rather get a flat list of tokens in the order they occur in the text. The <code>.caps</code> method returns a list of every capture in order, regardless of how it was otherwise bound into named or numbered captures. (Other than order, there is no new information here; all the elements of the list are the very same <code>Match</code> objects that bound elsewhere.) The bindings are actually returned as key/value pairs where the key is the name or number under which the match object was bound, and the value is the match object itself.
<a id="line_3142"></a>
<a id="line_3143"></a>
<a id="line_3144"></a>
<a id="line_3145"></a>
<a id="line_3146"></a>
<a id="line_3147"></a>
<a id="line_3148"></a>
<a id="line_3149"></a>
<a id="line_3150"></a>


<p>In addition to returning those captured <code>Match</code> objects, the <code>.chunks</code> method also returns all the interleaved &#34;noise&#34; between the captures. As with <code>.caps</code>, the list elements are in the order they were originally in the text. The interleaved bits are also returned as pairs, where the key is &#39;~&#39; and the value is a simple <code>Match</code> object containing only the string, even if unbound subrules such as <code>.ws</code> were called to traverse the text in the first place. Calling <code>.made</code> on such a <code>Match</code> object always returns a <code>Str</code>.</p>

<a id="line_3151"></a>
<a id="line_3152"></a>
<a id="line_3153"></a>
<a id="line_3154"></a>
<a id="line_3155"></a>
<a id="line_3156"></a>


<p>A warning will be issued if either <code>.caps</code> or <code>.chunks</code> discovers that it has overlapping bindings. In the absence of such overlap, <code>.chunks</code> guarantees to map every part of its matched string (between <code>.from</code> and <code>.to</code>) to exactly one element of its returned matches, so coverage is complete.</p>

<a id="line_3157"></a>
<a id="line_3158"></a>
<a id="line_3159"></a>
<a id="line_3160"></a>
<a id="line_3161"></a>


<p>[Conjecture: we could also have <code>.deepcaps</code> and <code>.deepchunks</code> that recursively expand any capture containing submatches. Presumably the keys of such returned chunks would indicate the &#34;pedigree&#34; of bindings in the parse tree.]</p>

<a id="line_3162"></a>
<a id="line_3163"></a>
<a id="line_3164"></a>
<a id="line_3165"></a>
<a id="line_3166"></a>
<a id="line_3167"></a>
<a id="line_3168"></a>

</li>

<li>All match attempts--successful or not--against any regex, subrule, or subpattern (see below) return an object that can be evaluated as a boolean. (This object will be either a <code>Match</code> or a <code>Nil</code>.) That is:
<a id="line_3169"></a>
<a id="line_3170"></a>
<a id="line_3171"></a>


<pre>     $match_obj = $str ~~ /pattern/;
     say &#34;Matched&#34; if $match_obj;</pre>

<a id="line_3172"></a>


<a id="line_3173"></a>
<a id="line_3174"></a>
<a id="line_3175"></a>
<a id="line_3176"></a>
<a id="line_3177"></a>

</li>

<li>This returned object is also automatically bound to the lexical <code>$/</code> variable of the current surroundings regardless of success. That is:
<a id="line_3178"></a>
<a id="line_3179"></a>
<a id="line_3180"></a>


<pre>     $str ~~ /pattern/;
     say &#34;Matched&#34; if $/;</pre>

<a id="line_3181"></a>
<a id="line_3182"></a>
<a id="line_3183"></a>
<a id="line_3184"></a>
<a id="line_3185"></a>
<a id="line_3186"></a>
<a id="line_3187"></a>
<a id="line_3188"></a>
<a id="line_3189"></a>

</li>

<li>Inside a regex, the <code>$&#162;</code> variable holds the current regex&#39;s incomplete <code>Match</code> object, known as a match state (of type <code>Cursor</code>). Generally this should not be modified unless you know how to create and propagate match states. All regexes actually return match states even when you think they&#39;re returning something else, because the match states keep track of the successes and failures of the pattern for you.
<a id="line_3190"></a>
<a id="line_3191"></a>
<a id="line_3192"></a>
<a id="line_3193"></a>
<a id="line_3194"></a>


<p>Fortunately, when you just want to return a different abstract result along with the default concrete <code>Match</code> object, you may associate your return value with the current match state using the <code>make</code> function, which works something like a <code>return</code>, but doesn&#39;t clobber the match state:</p>

<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-match/make.t#L9-L40"><code>S05-match/make.t</code> lines <code>9&ndash;40</code></a>
  </p>
</div>
  


<a id="line_3195"></a>
<a id="line_3196"></a>
<a id="line_3197"></a>
<a id="line_3198"></a>
<a id="line_3199"></a>


<pre>    $str ~~ / foo                 # Match &#39;foo&#39;
               { make &#39;bar&#39; }     # But pretend we matched &#39;bar&#39;
             /;
    say $();                      # says &#39;bar&#39;</pre>

<a id="line_3200"></a>
<a id="line_3201"></a>
<a id="line_3202"></a>
<a id="line_3203"></a>


<p>The value of any <code>Match</code> object (such as an abstract object) is available via the <code>.made</code> method. Hence these abstract objects can be managed independently of the returned cursor objects.</p>

<a id="line_3204"></a>
<a id="line_3205"></a>
<a id="line_3206"></a>
<a id="line_3207"></a>
<a id="line_3208"></a>
<a id="line_3209"></a>
<a id="line_3210"></a>
<a id="line_3211"></a>
<a id="line_3212"></a>


<p>The current cursor object must always be derived from <code>Cursor</code>, or the match will not work. However, within that constraint, the actual type of the current cursor defines which language you are currently parsing. When you enter the top of a grammar, this cursor generally starts out as an object whose type is the name of the grammar you are in, but the current language can be modified by various methods as they mutate the current language by returning cursor objects blessed into a different type, which may or may not be derived from the current grammar.</p>

<a id="line_3213"></a>
<a id="line_3214"></a>

</li>
</ul>

<a id="line_3215"></a>
<a id="line_3216"></a>
<a id="line_3217"></a>
<a id="line_3218"></a>
<a id="line_3219"></a>
<a id="line_3220"></a>
<a id="line_3221"></a>
<a id="line_3222"></a>
<a id="line_3223"></a>


<h2><a class='u' href='#___top' title='click to go to top of document'
name="Subpattern_captures"
>Subpattern captures</a></h2>

<ul>
<li>Any part of a regex that is enclosed in capturing parentheses is called a <i>subpattern</i>. For example:
<a id="line_3224"></a>
<a id="line_3225"></a>
<a id="line_3226"></a>
<a id="line_3227"></a>
<a id="line_3228"></a>
<a id="line_3229"></a>
<a id="line_3230"></a>
<a id="line_3231"></a>


<pre>        #               subpattern
        #  _________________/\___________________
        # |                                      |
        # |       subpattern  subpattern         |
        # |          __/\__    __/\__            |
        # |         |      |  |      |           |
      ms/ (I am the (walrus), ( khoo )**2  kachoo) /;</pre>

<a id="line_3232"></a>


<a id="line_3233"></a>
<a id="line_3234"></a>
<a id="line_3235"></a>
<a id="line_3236"></a>
<a id="line_3237"></a>

</li>

<li>Each subpattern in a regex produces a <code>Match</code> object if it is successfully matched.
<a id="line_3238"></a>
<a id="line_3239"></a>
<a id="line_3240"></a>
<a id="line_3241"></a>
<a id="line_3242"></a>

</li>

<li>Each subpattern is either explicitly assigned to a named destination or implicitly added to an array of matches.
<a id="line_3243"></a>
<a id="line_3244"></a>
<a id="line_3245"></a>
<a id="line_3246"></a>
<a id="line_3247"></a>
<a id="line_3248"></a>
<a id="line_3249"></a>


<p>For each subpattern that is not explicitly given a name, the subpattern&#39;s <code>Match</code> object is pushed onto the array inside the outer <code>Match</code> object belonging to the surrounding scope (known as its <i>parent <code>Match</code> object</i>). The surrounding scope may be either the innermost surrounding subpattern (if the subpattern is nested) or else the entire regex itself.</p>

<a id="line_3250"></a>
<a id="line_3251"></a>
<a id="line_3252"></a>
<a id="line_3253"></a>
<a id="line_3254"></a>

</li>

<li>Like all captures, these assignments to the array are hypothetical, and are undone if the subpattern is backtracked.
<a id="line_3255"></a>
<a id="line_3256"></a>
<a id="line_3257"></a>
<a id="line_3258"></a>

</li>

<li>For example, if the following pattern matched successfully:
<a id="line_3259"></a>
<a id="line_3260"></a>
<a id="line_3261"></a>
<a id="line_3262"></a>
<a id="line_3263"></a>
<a id="line_3264"></a>
<a id="line_3265"></a>
<a id="line_3266"></a>


<pre>        #                subpat-A
        #  _________________/\__________________
        # |                                     |
        # |         subpat-B  subpat-C          |
        # |          __/\__    __/\__           |
        # |         |      |  |      |          |
      ms/ (I am the (walrus), ( khoo )**2 kachoo) /;</pre>

<a id="line_3267"></a>
<a id="line_3268"></a>
<a id="line_3269"></a>
<a id="line_3270"></a>
<a id="line_3271"></a>
<a id="line_3272"></a>


<p>then the <code>Match</code> objects representing the matches made by <i>subpat-B</i> and <i>subpat-C</i> would be successively pushed onto the array inside <i>subpat- A</i>&#39;s <code>Match</code> object. Then <i>subpat-A</i>&#39;s <code>Match</code> object would itself be pushed onto the array inside the <code>Match</code> object for the entire regex (i.e. onto <code>$/</code>&#39;s array).</p>

<a id="line_3273"></a>
<a id="line_3274"></a>
<a id="line_3275"></a>
<a id="line_3276"></a>
<a id="line_3277"></a>

</li>

<li>As a result of these semantics, capturing parentheses in Perl 6 are hierarchical, not linear (see <a href="#Nested_subpattern_captures" class="podlinkpod"
>&#34;Nested subpattern captures&#34;</a>).
<a id="line_3278"></a>
<a id="line_3279"></a>

</li>
</ul>

<a id="line_3280"></a>
<a id="line_3281"></a>
<a id="line_3282"></a>
<a id="line_3283"></a>
<a id="line_3284"></a>
<a id="line_3285"></a>
<a id="line_3286"></a>
<a id="line_3287"></a>
<a id="line_3288"></a>
<a id="line_3289"></a>
<a id="line_3290"></a>


<h2><a class='u' href='#___top' title='click to go to top of document'
name="Accessing_captured_subpatterns"
>Accessing captured subpatterns</a></h2>

<ul>
<li>The array elements of a <code>Match</code> object are referred to using either the standard array access notation (e.g. <code>$/[0]</code>, <code>$/[1]</code>, <code>$/[2]</code>, etc.) or else via the corresponding lexically scoped numeric aliases (i.e. <code>$0</code>, <code>$1</code>, <code>$2</code>, etc.) So:
<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-match/capturing-contexts.t#L25-L34"><code>S05-match/capturing-contexts.t</code> lines <code>25&ndash;34</code></a>
  </p>
</div>
  


<a id="line_3291"></a>
<a id="line_3292"></a>


<pre>     say &#34;$/[1] was found between $/[0] and $/[2]&#34;;</pre>

<a id="line_3293"></a>
<a id="line_3294"></a>


<p>is the same as:</p>

<a id="line_3295"></a>
<a id="line_3296"></a>


<pre>     say &#34;$1 was found between $0 and $2&#34;;</pre>

<a id="line_3297"></a>
<a id="line_3298"></a>
<a id="line_3299"></a>
<a id="line_3300"></a>
<a id="line_3301"></a>

</li>

<li>Note that, in Perl 6, the numeric capture variables start from $0, not $1, with the numbers corresponding to the element&#39;s index inside <code>$/</code>.
<a id="line_3302"></a>
<a id="line_3303"></a>
<a id="line_3304"></a>
<a id="line_3305"></a>
<a id="line_3306"></a>
<a id="line_3307"></a>
<a id="line_3308"></a>
<a id="line_3309"></a>

</li>

<li>The array elements of the regex&#39;s <code>Match</code> object (i.e. <code>$/</code>) store individual <code>Match</code> objects representing the substrings that were matched and captured by the first, second, third, etc. <i>outermost</i> (i.e. unnested) subpatterns. So these elements can be treated like fully fledged match results. For example:
<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-capture/dot.t#L13-L55"><code>S05-capture/dot.t</code> lines <code>13&ndash;55</code></a>
  </p>
</div>
  


<a id="line_3310"></a>
<a id="line_3311"></a>
<a id="line_3312"></a>
<a id="line_3313"></a>
<a id="line_3314"></a>
<a id="line_3315"></a>


<pre>     if m/ (\d\d\d\d)-(\d\d)-(\d\d) (BCE?|AD|CE)?/ {
           ($yr, $mon, $day) = $/[0..2];
           $era = &#34;$3&#34; if $3;                    # stringify/boolify
           @datepos = ( $0.from() .. $2.to() );  # Call Match methods
     }</pre>

<a id="line_3316"></a>


<a id="line_3317"></a>
<a id="line_3318"></a>

</li>
</ul>

<a id="line_3319"></a>
<a id="line_3320"></a>
<a id="line_3321"></a>
<a id="line_3322"></a>
<a id="line_3323"></a>
<a id="line_3324"></a>
<a id="line_3325"></a>
<a id="line_3326"></a>
<a id="line_3327"></a>
<a id="line_3328"></a>


<h2><a class='u' href='#___top' title='click to go to top of document'
name="Nested_subpattern_captures"
>Nested subpattern captures</a></h2>

<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-capture/named.t#L16-L25"><code>S05-capture/named.t</code> lines <code>16&ndash;25</code></a>
  </p>
</div>
  


<ul>
<li>Substrings matched by <i>nested</i> subpatterns (i.e. nested capturing parens) are assigned to the array inside the nested subpattern&#39;s parent <code>Match</code> object, not to the array of <code>$/</code>.
<a id="line_3329"></a>
<a id="line_3330"></a>
<a id="line_3331"></a>
<a id="line_3332"></a>

</li>

<li>This behavior is quite different from Perl 5 semantics:
<a id="line_3333"></a>
<a id="line_3334"></a>
<a id="line_3335"></a>
<a id="line_3336"></a>
<a id="line_3337"></a>
<a id="line_3338"></a>
<a id="line_3339"></a>
<a id="line_3340"></a>


<pre>      # Perl 5...
      #
      # $1---------------------  $4---------  $5------------------
      # |   $2---------------  | |          | | $6----  $7------  |
      # |   |         $3--   | | |          | | |     | |       | |
      # |   |         |   |  | | |          | | |     | |       | |
     m/ ( A (guy|gal|g(\S+)  ) ) (sees|calls) ( (the|a) (gal|guy) ) /x;</pre>

<a id="line_3341"></a>
<a id="line_3342"></a>
<a id="line_3343"></a>
<a id="line_3344"></a>

</li>

<li>In Perl 6, nested parens produce properly nested captures:
<a id="line_3345"></a>
<a id="line_3346"></a>
<a id="line_3347"></a>
<a id="line_3348"></a>
<a id="line_3349"></a>
<a id="line_3350"></a>
<a id="line_3351"></a>
<a id="line_3352"></a>


<pre>      # Perl 6...
      #
      # $0---------------------  $1---------  $2------------------
      # |   $0[0]------------  | |          | | $2[0]-  $2[1]---  |
      # |   |       $0[0][0] | | |          | | |     | |       | |
      # |   |         |   |  | | |          | | |     | |       | |
     m/ ( A (guy|gal|g(\S+)  ) ) (sees|calls) ( (the|a) (gal|guy) ) /;</pre>

<a id="line_3353"></a>


<a id="line_3354"></a>
<a id="line_3355"></a>

</li>
</ul>

<a id="line_3356"></a>
<a id="line_3357"></a>
<a id="line_3358"></a>
<a id="line_3359"></a>
<a id="line_3360"></a>
<a id="line_3361"></a>
<a id="line_3362"></a>
<a id="line_3363"></a>
<a id="line_3364"></a>
<a id="line_3365"></a>
<a id="line_3366"></a>
<a id="line_3367"></a>
<a id="line_3368"></a>
<a id="line_3369"></a>
<a id="line_3370"></a>


<h2><a class='u' href='#___top' title='click to go to top of document'
name="Quantified_subpattern_captures"
>Quantified subpattern captures</a></h2>

<ul>
<li>If a subpattern is directly quantified with <code>?</code>, it either produces a single <code>Match</code> object, or <code>Nil</code>. If a subpattern is directly quantified using any other quantifier, it never produces a single <code>Match</code> object. Instead, it produces a list of <code>Match</code> objects corresponding to the sequence of individual matches made by the repeated subpattern. If we need to distinguish the two categories, <code>?</code> is an <i>item quantifier</i>, while <code>*</code>, <code>+</code>, and <code>**</code> are called <i>list quantifiers</i>.
<a id="line_3371"></a>
<a id="line_3372"></a>
<a id="line_3373"></a>
<a id="line_3374"></a>
<a id="line_3375"></a>
<a id="line_3376"></a>
<a id="line_3377"></a>
<a id="line_3378"></a>
<a id="line_3379"></a>


<p>If 0 values match, the captured value depends on which quantifier is used. If the quantifier is <code>?</code>, a <code>Nil</code> is captured if it matched 0 times. If the quantifier is <code>*</code>, the empty list, <code>()</code>, is captured instead. (Nothing is captured by the <code>+</code> quantifier if it matches 0 times, since it causes backtracking, but the capture variable should return <code>Nil</code> if an attempt is made to use it after an unsuccessful match.) A <code>**</code> quantifier returns () as <code>*</code> does if it the minimum of its range is 0, and backtracks otherwise.</p>

<a id="line_3380"></a>
<a id="line_3381"></a>


<p>Note that <code>** 0..1</code> is always considered a list quantifier, unlike <code>?</code>.</p>

<a id="line_3382"></a>
<a id="line_3383"></a>
<a id="line_3384"></a>
<a id="line_3385"></a>
<a id="line_3386"></a>
<a id="line_3387"></a>
<a id="line_3388"></a>


<p>The rationale for treating <code>?</code> as an item quantifier is to make it consistent with how <code>$object.?meth</code> is defined, and to reduce the need for gratuitous <code>.[0]</code> subscripts, which is surprising to most people. Now that <code>Nil</code> is considered undefined rather than a synonym for <code>()</code>, it&#39;s easy to use <code>$0 // &#34;default&#34;</code> or some such to dereference a capture safely.</p>

<a id="line_3389"></a>
<a id="line_3390"></a>
<a id="line_3391"></a>
<a id="line_3392"></a>
<a id="line_3393"></a>
<a id="line_3394"></a>

</li>

<li>Because a list-quantified subpattern returns a list of <code>Match</code> objects, the corresponding array element for the quantified capture will store a (nested) array rather than a single <code>Match</code> object. For example:
<a id="line_3395"></a>
<a id="line_3396"></a>
<a id="line_3397"></a>
<a id="line_3398"></a>
<a id="line_3399"></a>


<pre>     if m/ (\w+) \: (\w+ \s+)* / {
         say &#34;Key:    $0&#34;;         # Unquantified --&#62; single Match
         say &#34;Values: @($1)&#34;;      # Quantified   --&#62; array of Match
     }</pre>

<a id="line_3400"></a>


<a id="line_3401"></a>
<a id="line_3402"></a>

</li>
</ul>

<a id="line_3403"></a>
<a id="line_3404"></a>
<a id="line_3405"></a>
<a id="line_3406"></a>
<a id="line_3407"></a>
<a id="line_3408"></a>
<a id="line_3409"></a>
<a id="line_3410"></a>
<a id="line_3411"></a>


<h2><a class='u' href='#___top' title='click to go to top of document'
name="Indirectly_quantified_subpattern_captures"
>Indirectly quantified subpattern captures</a></h2>

<ul>
<li>A subpattern may sometimes be nested inside a quantified non-capturing structure:
<a id="line_3412"></a>
<a id="line_3413"></a>
<a id="line_3414"></a>
<a id="line_3415"></a>
<a id="line_3416"></a>
<a id="line_3417"></a>
<a id="line_3418"></a>
<a id="line_3419"></a>


<pre>      #       non-capturing       quantifier
      #  __________/\____________  __/\__
      # |                        ||      |
      # |   $0         $1        ||      |
      # |  _^_      ___^___      ||      |
      # | |   |    |       |     ||      |
     m/ [ (\w+) \: (\w+ \h*)* \n ] ** 2..* /</pre>

<a id="line_3420"></a>
<a id="line_3421"></a>
<a id="line_3422"></a>
<a id="line_3423"></a>


<p>Non-capturing brackets <i>don&#39;t</i> create a separate nested lexical scope, so the two subpatterns inside them are actually still in the regex&#39;s top-level scope, hence their top-level designations: <code>$0</code> and <code>$1</code>.</p>

<a id="line_3424"></a>
<a id="line_3425"></a>
<a id="line_3426"></a>
<a id="line_3427"></a>
<a id="line_3428"></a>
<a id="line_3429"></a>
<a id="line_3430"></a>
<a id="line_3431"></a>

</li>

<li>However, because the two subpatterns are inside a quantified structure, <code>$0</code> and <code>$1</code> will each contain an array. The elements of that array will be the submatches returned by the corresponding subpatterns on each iteration of the non-capturing parentheses. For example:
<a id="line_3432"></a>
<a id="line_3433"></a>


<pre>     my $text = &#34;foo:food fool\nbar:bard barb&#34;;</pre>

<a id="line_3434"></a>
<a id="line_3435"></a>
<a id="line_3436"></a>
<a id="line_3437"></a>


<pre>               #   $0--     $1------
               #   |   |    |       |
     $text ~~ m/ [ (\w+) \: (\w+ \h*)* \n ] ** 2..* /;</pre>

<a id="line_3438"></a>
<a id="line_3439"></a>
<a id="line_3440"></a>
<a id="line_3441"></a>
<a id="line_3442"></a>
<a id="line_3443"></a>
<a id="line_3444"></a>
<a id="line_3445"></a>
<a id="line_3446"></a>
<a id="line_3447"></a>
<a id="line_3448"></a>
<a id="line_3449"></a>
<a id="line_3450"></a>


<pre>     # Because they&#39;re in a quantified non-capturing block...
     # $0 contains the equivalent of:
     #
     #       [ Match.new(str=&#62;&#39;foo&#39;), Match.new(str=&#62;&#39;bar&#39;) ]
     #
     # and $1 contains the equivalent of:
     #
     #       [ Match.new(str=&#62;&#39;food &#39;),
     #         Match.new(str=&#62;&#39;fool&#39; ),
     #         Match.new(str=&#62;&#39;bard &#39;),
     #         Match.new(str=&#62;&#39;barb&#39; ),
     #       ]</pre>

<a id="line_3451"></a>


<a id="line_3452"></a>
<a id="line_3453"></a>
<a id="line_3454"></a>
<a id="line_3455"></a>
<a id="line_3456"></a>
<a id="line_3457"></a>
<a id="line_3458"></a>
<a id="line_3459"></a>

</li>

<li>In contrast, if the outer quantified structure is a <i>capturing</i> structure (i.e. a subpattern) then it <i>will</i> introduce a nested lexical scope. That outer quantified structure will then return an array of <code>Match</code> objects representing the captures of the inner parens for <i>every</i> iteration (as described above). That is:
<a id="line_3460"></a>
<a id="line_3461"></a>


<pre>     my $text = &#34;foo:food fool\nbar:bard barb&#34;;</pre>

<a id="line_3462"></a>
<a id="line_3463"></a>
<a id="line_3464"></a>
<a id="line_3465"></a>
<a id="line_3466"></a>
<a id="line_3467"></a>


<pre>               # $0-----------------------
               # |                        |
               # | $0[0]    $0[1]---      |
               # | |   |    |       |     |
     $text ~~ m/ ( (\w+) \: (\w+ \h*)* \n ) ** 2..* /;</pre>

<a id="line_3468"></a>
<a id="line_3469"></a>
<a id="line_3470"></a>
<a id="line_3471"></a>
<a id="line_3472"></a>
<a id="line_3473"></a>
<a id="line_3474"></a>
<a id="line_3475"></a>
<a id="line_3476"></a>
<a id="line_3477"></a>
<a id="line_3478"></a>
<a id="line_3479"></a>
<a id="line_3480"></a>
<a id="line_3481"></a>
<a id="line_3482"></a>
<a id="line_3483"></a>
<a id="line_3484"></a>
<a id="line_3485"></a>
<a id="line_3486"></a>
<a id="line_3487"></a>
<a id="line_3488"></a>
<a id="line_3489"></a>
<a id="line_3490"></a>


<pre>     # Because it&#39;s in a quantified capturing block,
     # $0 contains the equivalent of:
     #
     #       [ Match.new( str=&#62;&#34;foo:food fool\n&#34;,
     #                    arr=&#62;[ Match.new(str=&#62;&#39;foo&#39;),
     #                           [
     #                               Match.new(str=&#62;&#39;food &#39;),
     #                               Match.new(str=&#62;&#39;fool&#39;),
     #                           ]
     #                         ],
     #                  ),
     #         Match.new( str=&#62;&#39;bar:bard barb&#39;,
     #                    arr=&#62;[ Match.new(str=&#62;&#39;bar&#39;),
     #                           [
     #                               Match.new(str=&#62;&#39;bard &#39;),
     #                               Match.new(str=&#62;&#39;barb&#39;),
     #                           ]
     #                         ],
     #                  ),
     #       ]
     #
     # and there is no $1</pre>

<a id="line_3491"></a>
<a id="line_3492"></a>
<a id="line_3493"></a>
<a id="line_3494"></a>
<a id="line_3495"></a>
<a id="line_3496"></a>

</li>

<li>In other words, quantified non-capturing parens collect their components into handy flattened lists, whereas quantified capturing parens collect their components in a handy hierarchical structure.
<a id="line_3497"></a>
<a id="line_3498"></a>
<a id="line_3499"></a>
<a id="line_3500"></a>


<p>Additionally, the sublists are kept &#34;in sync&#34; with each other, as each empty match, in the case of <code>$0[1]</code> in our example if a <code>:</code> is followed by a newline character, will have a corresponding Nil in the given list.</p>

<a id="line_3501"></a>
<a id="line_3502"></a>

</li>
</ul>

<a id="line_3503"></a>
<a id="line_3504"></a>
<a id="line_3505"></a>
<a id="line_3506"></a>
<a id="line_3507"></a>
<a id="line_3508"></a>
<a id="line_3509"></a>
<a id="line_3510"></a>
<a id="line_3511"></a>
<a id="line_3512"></a>
<a id="line_3513"></a>


<h2><a class='u' href='#___top' title='click to go to top of document'
name="Subpattern_numbering"
>Subpattern numbering</a></h2>

<ul>
<li>The index of a given subpattern can always be statically determined, but is not necessarily unique nor always monotonic. The numbering of subpatterns restarts in each lexical scope (either a regex, a subpattern, or the branch of an alternation).
<a id="line_3514"></a>
<a id="line_3515"></a>
<a id="line_3516"></a>
<a id="line_3517"></a>
<a id="line_3518"></a>

</li>

<li>In particular, the index of capturing parentheses restarts after each <code>|</code> or <code>||</code> (but not after each <code>&#38;</code> or <code>&#38;&#38;</code>). Hence:
<a id="line_3519"></a>
<a id="line_3520"></a>
<a id="line_3521"></a>
<a id="line_3522"></a>
<a id="line_3523"></a>
<a id="line_3524"></a>


<pre>                  # $0      $1    $2   $3    $4           $5
     $tune_up = rx/ (&#34;don&#39;t&#34;) (ray) (me) (for) (solar tea), (&#34;d&#39;oh!&#34;)
                  # $0      $1      $2    $3        $4
                  | (every) (green) (BEM) (devours) (faces)
                  /;</pre>

<a id="line_3525"></a>
<a id="line_3526"></a>
<a id="line_3527"></a>
<a id="line_3528"></a>
<a id="line_3529"></a>


<p>This means that if the second alternation matches, the list value of the match will contain <code>(&#39;every&#39;, &#39;green&#39;, &#39;BEM&#39;, &#39;devours&#39;, &#39;faces&#39;)</code> rather than Perl 5&#39;s <code>(undef, undef, undef, undef, undef, undef, &#39;every&#39;, &#39;green&#39;, &#39;BEM&#39;, &#39;devours&#39;, &#39;faces&#39;)</code>.</p>

<a id="line_3530"></a>
<a id="line_3531"></a>
<a id="line_3532"></a>
<a id="line_3533"></a>
<a id="line_3534"></a>

</li>

<li>Note that it is still possible to mimic the monotonic Perl 5 capture indexing semantics. See <a href="#Numbered_scalar_aliasing" class="podlinkpod"
>&#34;Numbered scalar aliasing&#34;</a> below for details.
<a id="line_3535"></a>


<a id="line_3536"></a>
<a id="line_3537"></a>

</li>
</ul>

<a id="line_3538"></a>
<a id="line_3539"></a>
<a id="line_3540"></a>
<a id="line_3541"></a>
<a id="line_3542"></a>
<a id="line_3543"></a>
<a id="line_3544"></a>
<a id="line_3545"></a>
<a id="line_3546"></a>
<a id="line_3547"></a>


<h2><a class='u' href='#___top' title='click to go to top of document'
name="Subrule_captures"
>Subrule captures</a></h2>

<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-capture/named.t#L36-L73"><code>S05-capture/named.t</code> lines <code>36&ndash;73</code></a>
  </p>
</div>
  


<ul>
<li>Any call to a named <code>&#60;regex&#62;</code> within a pattern is known as a <i>subrule</i>, whether that regex is actually defined as a <code>regex</code> or <code>token</code> or <code>rule</code> or even an ordinary <code>method</code> or <code>multi</code>.
<a id="line_3548"></a>
<a id="line_3549"></a>
<a id="line_3550"></a>
<a id="line_3551"></a>
<a id="line_3552"></a>

</li>

<li>Any bracketed construct that is aliased (see <a href="#Aliasing" class="podlinkpod"
>&#34;Aliasing&#34;</a> below) to a named variable is also a subrule.
<a id="line_3553"></a>
<a id="line_3554"></a>
<a id="line_3555"></a>
<a id="line_3556"></a>

</li>

<li>For example, this regex contains three subrules:
<a id="line_3557"></a>
<a id="line_3558"></a>
<a id="line_3559"></a>
<a id="line_3560"></a>
<a id="line_3561"></a>


<pre>      # subrule       subrule     subrule
      #  __^__    _______^_____    __^__
      # |     |  |             |  |     |
     m/ &#60;ident&#62;  $&#60;spaces&#62;=(\s*)  &#60;digit&#62;+ /</pre>

<a id="line_3562"></a>
<a id="line_3563"></a>
<a id="line_3564"></a>
<a id="line_3565"></a>
<a id="line_3566"></a>
<a id="line_3567"></a>
<a id="line_3568"></a>
<a id="line_3569"></a>

</li>

<li>Just like subpatterns, each successfully matched subrule within a regex produces a <code>Match</code> object. But, unlike subpatterns, that <code>Match</code> object is not assigned to the array inside its parent <code>Match</code> object. Instead, it is assigned to an entry of the hash inside its parent <code>Match</code> object. For example:
<a id="line_3570"></a>
<a id="line_3571"></a>
<a id="line_3572"></a>
<a id="line_3573"></a>
<a id="line_3574"></a>
<a id="line_3575"></a>
<a id="line_3576"></a>
<a id="line_3577"></a>
<a id="line_3578"></a>


<pre>      #  .... $/ .....................................
      # :                                             :
      # :              .... $/[0] ..................  :
      # :             :                             : :
      # : $/&#60;ident&#62;   :        $/[0]&#60;ident&#62;         : :
      # :   __^__     :           __^__             : :
      # :  |     |    :          |     |            : :
      ms/  &#60;ident&#62; \: ( known as &#60;ident&#62; previously ) /</pre>

<a id="line_3579"></a>


<a id="line_3580"></a>
<a id="line_3581"></a>

</li>
</ul>

<a id="line_3582"></a>
<a id="line_3583"></a>
<a id="line_3584"></a>
<a id="line_3585"></a>
<a id="line_3586"></a>
<a id="line_3587"></a>
<a id="line_3588"></a>
<a id="line_3589"></a>
<a id="line_3590"></a>
<a id="line_3591"></a>
<a id="line_3592"></a>


<h2><a class='u' href='#___top' title='click to go to top of document'
name="Accessing_captured_subrules"
>Accessing captured subrules</a></h2>

<ul>
<li>The hash entries of a <code>Match</code> object can be referred to using any of the standard hash access notations (<code>$/{&#39;foo&#39;}</code>, <code>$/&#60;bar&#62;</code>, <code>$/&#171;baz&#187;</code>, etc.), or else via corresponding lexically scoped aliases (<code>$&#60;foo&#62;</code>, <code>$&#171;bar&#187;</code>, <code>$&#60;baz&#62;</code>, etc.) So the previous example also implies:
<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-capture/dot.t#L66-L91"><code>S05-capture/dot.t</code> lines <code>66&ndash;91</code></a>
  </p>
</div>
  


<a id="line_3593"></a>
<a id="line_3594"></a>
<a id="line_3595"></a>
<a id="line_3596"></a>
<a id="line_3597"></a>


<pre>      #    $&#60;ident&#62;             $0&#60;ident&#62;
      #     __^__                 __^__
      #    |     |               |     |
      ms/  &#60;ident&#62; \: ( known as &#60;ident&#62; previously ) /</pre>

<a id="line_3598"></a>
<a id="line_3599"></a>
<a id="line_3600"></a>
<a id="line_3601"></a>
<a id="line_3602"></a>
<a id="line_3603"></a>

</li>

<li>Note that it makes no difference whether a subrule is angle-bracketed (<code>&#60;ident&#62;</code>) or aliased internally (<code>&#60;ident=.name&#62;</code>) or aliased externally (<code>$&#60;ident&#62;=(&#60;.alpha&#62;\w*)</code>). The name&#39;s the thing.
<a id="line_3604"></a>


<a id="line_3605"></a>
<a id="line_3606"></a>

</li>
</ul>

<a id="line_3607"></a>
<a id="line_3608"></a>
<a id="line_3609"></a>
<a id="line_3610"></a>
<a id="line_3611"></a>
<a id="line_3612"></a>
<a id="line_3613"></a>
<a id="line_3614"></a>
<a id="line_3615"></a>
<a id="line_3616"></a>
<a id="line_3617"></a>
<a id="line_3618"></a>
<a id="line_3619"></a>


<h2><a class='u' href='#___top' title='click to go to top of document'
name="Repeated_captures_of_the_same_subrule"
>Repeated captures of the same subrule</a></h2>

<ul>
<li>If a subrule appears two (or more) times in any branch of a lexical scope (i.e. twice within the same subpattern and alternation), or if the subrule is list-quantified anywhere within a given scope (that is, by any quantifier other than <code>?</code>), then its corresponding hash entry is always assigned an array of <code>Match</code> objects rather than a single <code>Match</code> object.
<a id="line_3620"></a>
<a id="line_3621"></a>
<a id="line_3622"></a>
<a id="line_3623"></a>
<a id="line_3624"></a>
<a id="line_3625"></a>

</li>

<li>Successive matches of the same subrule (whether from separate calls, or from a single quantified repetition) append their individual <code>Match</code> objects to this array. For example:
<a id="line_3626"></a>
<a id="line_3627"></a>
<a id="line_3628"></a>
<a id="line_3629"></a>
<a id="line_3630"></a>


<pre>     if ms/ mv &#60;file&#62; &#60;file&#62; / {
         $from = $&#60;file&#62;[0];
         $to   = $&#60;file&#62;[1];
     }</pre>

<a id="line_3631"></a>
<a id="line_3632"></a>
<a id="line_3633"></a>
<a id="line_3634"></a>
<a id="line_3635"></a>


<p>(Note, for clarity we are ignoring whitespace subtleties here--the normal sigspace rules would require space only between alphanumeric characters, which is wrong. Assume that our file subrule deals with whitespace on its own.)</p>

<a id="line_3636"></a>
<a id="line_3637"></a>


<p>Likewise, with a quantified subrule:</p>

<a id="line_3638"></a>
<a id="line_3639"></a>
<a id="line_3640"></a>
<a id="line_3641"></a>
<a id="line_3642"></a>


<pre>     if ms/ mv &#60;file&#62; ** 2 / {
         $from = $&#60;file&#62;[0];
         $to   = $&#60;file&#62;[1];
     }</pre>

<a id="line_3643"></a>
<a id="line_3644"></a>


<p>And with a mixture of both:</p>

<a id="line_3645"></a>
<a id="line_3646"></a>
<a id="line_3647"></a>
<a id="line_3648"></a>
<a id="line_3649"></a>


<pre>     if ms/ mv &#60;file&#62;+ &#60;file&#62; / {
         $to   = pop @($&#60;file&#62;);
         @from = @($&#60;file&#62;);
     }</pre>

<a id="line_3650"></a>
<a id="line_3651"></a>
<a id="line_3652"></a>
<a id="line_3653"></a>
<a id="line_3654"></a>

</li>

<li>To avoid name collisions, you may suppress the original name by use of a leading dot, and then use an alias to give the capture a different name:
<a id="line_3655"></a>
<a id="line_3656"></a>
<a id="line_3657"></a>
<a id="line_3658"></a>
<a id="line_3659"></a>


<pre>     if ms/ mv &#60;file&#62; &#60;dir=.file&#62; / {
         $from = $&#60;file&#62;;  # Only one subrule named &#60;file&#62;, so scalar
         $to   = $&#60;dir&#62;;   # The Capture Formerly Known As &#60;file&#62;
     }</pre>

<a id="line_3660"></a>


<a id="line_3661"></a>
<a id="line_3662"></a>
<a id="line_3663"></a>
<a id="line_3664"></a>


<p>Likewise, neither of the following constructions causes <code>&#60;file&#62;</code> to produce an array of <code>Match</code> objects, since none of them has two or more <code>&#60;file&#62;</code> subrules in the same lexical scope:</p>

<a id="line_3665"></a>
<a id="line_3666"></a>
<a id="line_3667"></a>
<a id="line_3668"></a>
<a id="line_3669"></a>
<a id="line_3670"></a>
<a id="line_3671"></a>
<a id="line_3672"></a>


<pre>     if ms/ (keep) &#60;file&#62; | (toss) &#60;file&#62; / {
         # Each &#60;file&#62; is in a separate alternation, therefore &#60;file&#62;
         # is not repeated in any one scope, hence $&#60;file&#62; is
         # not an Array object...
         $action = $0;
         $target = $&#60;file&#62;;
     }</pre>

<a id="line_3673"></a>
<a id="line_3674"></a>
<a id="line_3675"></a>
<a id="line_3676"></a>
<a id="line_3677"></a>
<a id="line_3678"></a>
<a id="line_3679"></a>


<pre>     if ms/ &#60;file&#62; \: (&#60;file&#62;|none) / {
         # Second &#60;file&#62; nested in subpattern which confers a
         # different scope...
         $actual  = $/&#60;file&#62;;
         $virtual = $/[0]&#60;file&#62; if $/[0]&#60;file&#62;;
     }</pre>

<a id="line_3680"></a>
<a id="line_3681"></a>
<a id="line_3682"></a>
<a id="line_3683"></a>
<a id="line_3684"></a>

</li>

<li>On the other hand, unaliased square brackets don&#39;t confer a separate scope (because they don&#39;t have an associated <code>Match</code> object). So:
<a id="line_3685"></a>
<a id="line_3686"></a>
<a id="line_3687"></a>
<a id="line_3688"></a>
<a id="line_3689"></a>


<pre>     if ms/ &#60;file&#62; \: [&#60;file&#62;|none] / { # Two &#60;file&#62;s in same scope
         $actual  = $/&#60;file&#62;[0];
         $virtual = $/&#60;file&#62;[1] if $/&#60;file&#62;[1];
     }</pre>

<a id="line_3690"></a>


<a id="line_3691"></a>
<a id="line_3692"></a>

</li>
</ul>

<a id="line_3693"></a>
<a id="line_3694"></a>
<a id="line_3695"></a>
<a id="line_3696"></a>
<a id="line_3697"></a>
<a id="line_3698"></a>
<a id="line_3699"></a>


<h2><a class='u' href='#___top' title='click to go to top of document'
name="Aliasing"
>Aliasing</a></h2>

<p>Aliases can be named or numbered. They can be scalar-, array-, or hash-like. And they can be applied to either capturing or non-capturing constructs. The following sections highlight special features of the semantics of some of those combinations.</p>

<a id="line_3700"></a>


<a id="line_3701"></a>
<a id="line_3702"></a>
<a id="line_3703"></a>
<a id="line_3704"></a>
<a id="line_3705"></a>
<a id="line_3706"></a>
<a id="line_3707"></a>
<a id="line_3708"></a>


<h3><a class='u' href='#___top' title='click to go to top of document'
name="Named_scalar_aliasing_to_subpatterns"
>Named scalar aliasing to subpatterns</a></h3>

<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-capture/named.t#L26-L35"><code>S05-capture/named.t</code> lines <code>26&ndash;35</code></a>
  </p>
</div>
  


<ul>
<li>If a named scalar alias is applied to a set of <i>capturing</i> parens:
<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-capture/alias.t#L17-L26"><code>S05-capture/alias.t</code> lines <code>17&ndash;26</code></a>
  </p>
</div>
  


<a id="line_3709"></a>
<a id="line_3710"></a>
<a id="line_3711"></a>
<a id="line_3712"></a>
<a id="line_3713"></a>


<pre>        #         _____/capturing parens\_____
        #        |                            |
        #        |                            |
      ms/ $&#60;key&#62;=( (&#60;[A..E]&#62;) (\d**3..6) (X?) ) /;</pre>

<a id="line_3714"></a>
<a id="line_3715"></a>
<a id="line_3716"></a>
<a id="line_3717"></a>
<a id="line_3718"></a>


<p>then the outer capturing parens no longer capture into the array of <code>$/</code> as unaliased parens would. Instead the aliased parens capture into the hash of <code>$/</code>; specifically into the hash element whose key is the alias name.</p>

<a id="line_3719"></a>
<a id="line_3720"></a>
<a id="line_3721"></a>
<a id="line_3722"></a>
<a id="line_3723"></a>

</li>

<li>So, in the above example, a successful match sets <code>$&#60;key&#62;</code> (i.e. <code>$/&#60;key&#62;</code>), but <i>not</i> <code>$0</code> (i.e. not <code>$/[0]</code>).
<a id="line_3724"></a>
<a id="line_3725"></a>
<a id="line_3726"></a>
<a id="line_3727"></a>

</li>

<li>More specifically:
<a id="line_3728"></a>
<a id="line_3729"></a>
<a id="line_3730"></a>
<a id="line_3731"></a>
<a id="line_3732"></a>
<a id="line_3733"></a>
<a id="line_3734"></a>


<ul>
<li><code>$/&#60;key&#62;</code> will contain the <code>Match</code> object that would previously have been placed in <code>$/[0]</code>.
<a id="line_3735"></a>
<a id="line_3736"></a>
<a id="line_3737"></a>
<a id="line_3738"></a>

</li>

<li><code>$/&#60;key&#62;[0]</code> will contain the A-E letter,
<a id="line_3739"></a>
<a id="line_3740"></a>
<a id="line_3741"></a>
<a id="line_3742"></a>

</li>

<li><code>$/&#60;key&#62;[1]</code> will contain the digits,
<a id="line_3743"></a>
<a id="line_3744"></a>
<a id="line_3745"></a>
<a id="line_3746"></a>

</li>

<li><code>$/&#60;key&#62;[2]</code> will contain the optional X.
<a id="line_3747"></a>
<a id="line_3748"></a>

</li>
</ul>

<a id="line_3749"></a>
<a id="line_3750"></a>
<a id="line_3751"></a>
<a id="line_3752"></a>
<a id="line_3753"></a>
<a id="line_3754"></a>
<a id="line_3755"></a>

</li>

<li>Another way to think about this behavior is that aliased parens create a kind of lexically scoped named subrule; that the contents of the parentheses are treated as if they were part of a separate subrule whose name is the alias.
<a id="line_3756"></a>


<a id="line_3757"></a>
<a id="line_3758"></a>

</li>
</ul>

<a id="line_3759"></a>
<a id="line_3760"></a>
<a id="line_3761"></a>
<a id="line_3762"></a>
<a id="line_3763"></a>
<a id="line_3764"></a>
<a id="line_3765"></a>
<a id="line_3766"></a>


<h3><a class='u' href='#___top' title='click to go to top of document'
name="Named_scalar_aliases_applied_to_non-capturing_brackets"
>Named scalar aliases applied to non-capturing brackets</a></h3>

<ul>
<li>If a named scalar alias is applied to a set of <i>non-capturing</i> brackets:
<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-capture/alias.t#L33-L76"><code>S05-capture/alias.t</code> lines <code>33&ndash;76</code></a>
  </p>
</div>
  


<a id="line_3767"></a>
<a id="line_3768"></a>
<a id="line_3769"></a>
<a id="line_3770"></a>
<a id="line_3771"></a>


<pre>        #         __/non-capturing brackets\__
        #        |                            |
        #        |                            |
      ms/ $&#60;key&#62;=[ (&#60;[A..E]&#62;) (\d**3..6) (X?) ] /;</pre>

<a id="line_3772"></a>
<a id="line_3773"></a>
<a id="line_3774"></a>


<p>then the corresponding <code>$/&#60;key&#62;</code> <code>Match</code> object contains only the string matched by the non-capturing brackets.</p>

<a id="line_3775"></a>
<a id="line_3776"></a>
<a id="line_3777"></a>
<a id="line_3778"></a>
<a id="line_3779"></a>
<a id="line_3780"></a>
<a id="line_3781"></a>

</li>

<li>In particular, the array of the <code>$/&#60;key&#62;</code> entry is empty. That&#39;s because square brackets do not create a nested lexical scope, so the subpatterns are unnested and hence correspond to $0, $1, and $2, and <i>not</i> to <code>$/&#60;key&#62;[0]</code>, <code>$/&#60;key&#62;[1]</code>, and <code>$/&#60;key&#62;[2]</code>.
<a id="line_3782"></a>
<a id="line_3783"></a>
<a id="line_3784"></a>
<a id="line_3785"></a>

</li>

<li>In other words:
<a id="line_3786"></a>
<a id="line_3787"></a>
<a id="line_3788"></a>
<a id="line_3789"></a>
<a id="line_3790"></a>
<a id="line_3791"></a>
<a id="line_3792"></a>


<ul>
<li><code>$/&#60;key&#62;</code> will contain the complete substring matched by the square brackets (in a <code>Match</code> object, as described above),
<a id="line_3793"></a>
<a id="line_3794"></a>
<a id="line_3795"></a>
<a id="line_3796"></a>

</li>

<li><code>$0</code> will contain the A-E letter,
<a id="line_3797"></a>
<a id="line_3798"></a>
<a id="line_3799"></a>
<a id="line_3800"></a>

</li>

<li><code>$1</code> will contain the digits,
<a id="line_3801"></a>
<a id="line_3802"></a>
<a id="line_3803"></a>
<a id="line_3804"></a>

</li>

<li><code>$2</code> will contain the optional X.
<a id="line_3805"></a>
<a id="line_3806"></a>

</li>
</ul>

<a id="line_3807"></a>


<a id="line_3808"></a>
<a id="line_3809"></a>

</li>
</ul>

<a id="line_3810"></a>
<a id="line_3811"></a>
<a id="line_3812"></a>
<a id="line_3813"></a>
<a id="line_3814"></a>
<a id="line_3815"></a>
<a id="line_3816"></a>
<a id="line_3817"></a>
<a id="line_3818"></a>


<h3><a class='u' href='#___top' title='click to go to top of document'
name="Named_scalar_aliasing_to_subrules"
>Named scalar aliasing to subrules</a></h3>

<ul>
<li>If a subrule is aliased, it assigns its <code>Match</code> object to the hash entry whose key is the name of the alias, as well as to the original name.
<a id="line_3819"></a>
<a id="line_3820"></a>
<a id="line_3821"></a>
<a id="line_3822"></a>


<pre>     if m/ ID\: &#60;id=ident&#62; / {
         say &#34;Identified as $/&#60;id&#62; and $/&#60;ident&#62;&#34;;    # both names defined
     }</pre>

<a id="line_3823"></a>
<a id="line_3824"></a>


<p>To suppress the original name, use the dot form:</p>

<a id="line_3825"></a>
<a id="line_3826"></a>
<a id="line_3827"></a>
<a id="line_3828"></a>


<pre>     if m/ ID\: &#60;id=.ident&#62; / {
         say &#34;Identified as $/&#60;id&#62;&#34;;    # $/&#60;ident&#62; is undefined
     }</pre>

<a id="line_3829"></a>
<a id="line_3830"></a>
<a id="line_3831"></a>
<a id="line_3832"></a>
<a id="line_3833"></a>
<a id="line_3834"></a>

</li>

<li>Hence aliasing a dotted subrule <i>changes</i> the destination of the subrule&#39;s <code>Match</code> object. This is particularly useful for differentiating two or more calls to the same subrule in the same scope. For example:
<a id="line_3835"></a>
<a id="line_3836"></a>
<a id="line_3837"></a>
<a id="line_3838"></a>
<a id="line_3839"></a>


<pre>     if ms/ mv &#60;file&#62;+ &#60;dir=.file&#62; / {
         @from = @($&#60;file&#62;);
         $to   = $&#60;dir&#62;;
     }</pre>

<a id="line_3840"></a>
<a id="line_3841"></a>

</li>
</ul>

<a id="line_3842"></a>
<a id="line_3843"></a>
<a id="line_3844"></a>
<a id="line_3845"></a>
<a id="line_3846"></a>
<a id="line_3847"></a>
<a id="line_3848"></a>
<a id="line_3849"></a>


<h3><a class='u' href='#___top' title='click to go to top of document'
name="Numbered_scalar_aliasing"
>Numbered scalar aliasing</a></h3>

<ul>
<li>If a numbered alias is used instead of a named alias:
<a id="line_3850"></a>
<a id="line_3851"></a>
<a id="line_3852"></a>


<pre>     m/ $1=(&#60;-[:]&#62;*) \:  $0=&#60;ident&#62; /   # captures $&#60;ident&#62; too
     m/ $1=(&#60;-[:]&#62;*) \:  $0=&#60;.ident&#62; /  # doesn&#39;t capture $&#60;ident&#62;</pre>

<a id="line_3853"></a>
<a id="line_3854"></a>
<a id="line_3855"></a>
<a id="line_3856"></a>
<a id="line_3857"></a>


<p>the behavior is exactly the same as for a named alias (i.e. the various cases described above), except that the resulting <code>Match</code> object is assigned to the corresponding element of the appropriate array rather than to an element of the hash.</p>

<a id="line_3858"></a>
<a id="line_3859"></a>
<a id="line_3860"></a>
<a id="line_3861"></a>
<a id="line_3862"></a>
<a id="line_3863"></a>
<a id="line_3864"></a>

</li>

<li>If any numbered alias is used, the numbering of subsequent unaliased subpatterns in the same scope automatically increments from that alias number (much like enum values increment from the last explicit value). That is:
<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-capture/alias.t#L27-L32"><code>S05-capture/alias.t</code> lines <code>27&ndash;32</code></a>
  </p>
</div>
  


<a id="line_3865"></a>
<a id="line_3866"></a>
<a id="line_3867"></a>
<a id="line_3868"></a>


<pre>      #  --$1---    -$2-    --$6---    -$7-
      # |       |  |    |  |       |  |    |
     m/ $1=(food)  (bard)  $6=(bazd)  (quxd) /;</pre>

<a id="line_3869"></a>
<a id="line_3870"></a>
<a id="line_3871"></a>
<a id="line_3872"></a>
<a id="line_3873"></a>

</li>

<li>This <i>follow-on</i> behavior is particularly useful for reinstituting Perl 5 semantics for consecutive subpattern numbering in alternations:
<a id="line_3874"></a>
<a id="line_3875"></a>
<a id="line_3876"></a>
<a id="line_3877"></a>
<a id="line_3878"></a>


<pre>     $tune_up = rx/ (&#34;don&#39;t&#34;) (ray) (me) (for) (solar tea), (&#34;d&#39;oh!&#34;)
                  | $6 = (every) (green) (BEM) (devours) (faces)
                  #              $7      $8    $9        $10
                  /;</pre>

<a id="line_3879"></a>
<a id="line_3880"></a>
<a id="line_3881"></a>
<a id="line_3882"></a>
<a id="line_3883"></a>

</li>

<li>It also provides an easy way in Perl 6 to reinstitute the unnested numbering semantics of nested Perl 5 subpatterns:
<a id="line_3884"></a>
<a id="line_3885"></a>
<a id="line_3886"></a>
<a id="line_3887"></a>
<a id="line_3888"></a>
<a id="line_3889"></a>
<a id="line_3890"></a>
<a id="line_3891"></a>


<pre>      # Perl 5...
      #               $1
      #  _____________/\___________
      # |    $2        $3      $4  |
      # |  __/\___   __/\___   /\  |
      # | |       | |       | |  | |
     m/ ( ( [A-E] ) (\d{3,6}) (X?) ) /x;</pre>

<a id="line_3892"></a>


<a id="line_3893"></a>
<a id="line_3894"></a>
<a id="line_3895"></a>
<a id="line_3896"></a>
<a id="line_3897"></a>
<a id="line_3898"></a>
<a id="line_3899"></a>
<a id="line_3900"></a>


<pre>      # Perl 6...
      #                $0
      #  ______________/\______________
      # |   $0[0]       $0[1]    $0[2] |
      # |  ___/\___   ____/\____   /\  |
      # | |        | |          | |  | |
     m/ ( (&#60;[A..E]&#62;) (\d ** 3..6) (X?) ) /;</pre>

<a id="line_3901"></a>


<a id="line_3902"></a>
<a id="line_3903"></a>
<a id="line_3904"></a>
<a id="line_3905"></a>
<a id="line_3906"></a>
<a id="line_3907"></a>
<a id="line_3908"></a>
<a id="line_3909"></a>


<pre>      # Perl 6 simulating Perl 5...
      #                 $1
      #  _______________/\________________
      # |        $2          $3       $4  |
      # |     ___/\___   ____/\____   /\  |
      # |    |        | |          | |  | |
     m/ $1=[ (&#60;[A..E]&#62;) (\d ** 3..6) (X?) ] /;</pre>

<a id="line_3910"></a>
<a id="line_3911"></a>
<a id="line_3912"></a>
<a id="line_3913"></a>
<a id="line_3914"></a>


<p>The non-capturing brackets don&#39;t introduce a scope, so the subpatterns within them are at regex scope, and hence numbered at the top level. Aliasing the square brackets to <code>$1</code> means that the next subpattern at the same level (i.e. the <code>(&#60;[A..E]&#62;)</code>) is numbered sequentially (i.e. <code>$2</code>), etc.</p>

<a id="line_3915"></a>


<a id="line_3916"></a>
<a id="line_3917"></a>

</li>
</ul>

<a id="line_3918"></a>
<a id="line_3919"></a>
<a id="line_3920"></a>
<a id="line_3921"></a>
<a id="line_3922"></a>
<a id="line_3923"></a>
<a id="line_3924"></a>
<a id="line_3925"></a>
<a id="line_3926"></a>


<h3><a class='u' href='#___top' title='click to go to top of document'
name="Scalar_aliases_applied_to_quantified_constructs"
>Scalar aliases applied to quantified constructs</a></h3>

<ul>
<li>All of the above semantics apply equally to aliases which are bound to quantified structures.
<a id="line_3927"></a>
<a id="line_3928"></a>
<a id="line_3929"></a>
<a id="line_3930"></a>
<a id="line_3931"></a>
<a id="line_3932"></a>
<a id="line_3933"></a>
<a id="line_3934"></a>
<a id="line_3935"></a>

</li>

<li>The only difference is that, if the aliased construct is a subrule or subpattern, that quantified subrule or subpattern will have returned a list of <code>Match</code> objects (as described in <a href="#Quantified_subpattern_captures" class="podlinkpod"
>&#34;Quantified subpattern captures&#34;</a> and <a href="#Repeated_captures_of_the_same_subrule" class="podlinkpod"
>&#34;Repeated captures of the same subrule&#34;</a>). So the corresponding array element or hash entry for the alias will contain an array, instead of a single <code>Match</code> object.
<a id="line_3936"></a>
<a id="line_3937"></a>
<a id="line_3938"></a>
<a id="line_3939"></a>
<a id="line_3940"></a>

</li>

<li>In other words, aliasing and quantification are completely orthogonal. For example:
<a id="line_3941"></a>
<a id="line_3942"></a>
<a id="line_3943"></a>
<a id="line_3944"></a>
<a id="line_3945"></a>


<pre>     if ms/ mv $0=&#60;.file&#62;+ / {
         # &#60;file&#62;+ returns a list of Match objects,
         # so $0 contains an array of Match objects,
         # one for each successful call to &#60;file&#62;</pre>

<a id="line_3946"></a>
<a id="line_3947"></a>
<a id="line_3948"></a>


<pre>         # $/&#60;file&#62; does not exist (it&#39;s suppressed by the dot)
     }</pre>

<a id="line_3949"></a>


<a id="line_3950"></a>
<a id="line_3951"></a>
<a id="line_3952"></a>
<a id="line_3953"></a>
<a id="line_3954"></a>


<pre>     if m/ mv \s+ $&#60;from&#62;=(\S+ \s+)* / {
         # Quantified subpattern returns a list of Match objects,
         # so $/&#60;from&#62; contains an array of Match
         # objects, one for each successful match of the subpattern</pre>

<a id="line_3955"></a>
<a id="line_3956"></a>
<a id="line_3957"></a>


<pre>         # $0 does not exist (it&#39;s pre-empted by the alias)
     }</pre>

<a id="line_3958"></a>
<a id="line_3959"></a>
<a id="line_3960"></a>
<a id="line_3961"></a>
<a id="line_3962"></a>
<a id="line_3963"></a>
<a id="line_3964"></a>
<a id="line_3965"></a>

</li>

<li>Note, however, that a set of quantified <i>non-capturing</i> brackets always returns a single <code>Match</code> object which contains only the complete substring that was matched by the full set of repetitions of the brackets (as described in <a href="#Named_scalar_aliases_applied_to_non-capturing_brackets" class="podlinkpod"
>&#34;Named scalar aliases applied to non-capturing brackets&#34;</a>). For example:
<a id="line_3966"></a>
<a id="line_3967"></a>


<pre>     &#34;coffee fifo fumble&#34; ~~ m/ $&#60;effs&#62;=[f &#60;-[f]&#62; ** 1..2 \s*]+ /;</pre>

<a id="line_3968"></a>
<a id="line_3969"></a>


<pre>     say $&#60;effs&#62;;    # prints &#34;fee fifo fum&#34;</pre>

<a id="line_3970"></a>


<a id="line_3971"></a>
<a id="line_3972"></a>

</li>
</ul>

<a id="line_3973"></a>
<a id="line_3974"></a>
<a id="line_3975"></a>
<a id="line_3976"></a>
<a id="line_3977"></a>
<a id="line_3978"></a>
<a id="line_3979"></a>
<a id="line_3980"></a>
<a id="line_3981"></a>


<h3><a class='u' href='#___top' title='click to go to top of document'
name="Array_aliasing"
>Array aliasing</a></h3>

<ul>
<li>An alias can also be specified using an array as the alias instead of a scalar. For example:
<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-capture/array-alias.t#L13-L107"><code>S05-capture/array-alias.t</code> lines <code>13&ndash;107</code></a>
  </p>
</div>
  


<a id="line_3982"></a>
<a id="line_3983"></a>


<pre>     m/ mv \s+ @&#60;from&#62;=[(\S+) \s+]* &#60;dir&#62; /;</pre>

<a id="line_3984"></a>
<a id="line_3985"></a>
<a id="line_3986"></a>
<a id="line_3987"></a>
<a id="line_3988"></a>
<a id="line_3989"></a>
<a id="line_3990"></a>
<a id="line_3991"></a>
<a id="line_3992"></a>
<a id="line_3993"></a>

</li>

<li>Using the <code>@alias=</code> notation instead of a <code>$alias=</code> mandates that the corresponding hash entry or array element <i>always</i> receives an array of <code>Match</code> objects, even if the construct being aliased would normally return a single <code>Match</code> object. This is useful for creating consistent capture semantics across structurally different alternations (by enforcing array captures in all branches):
<a id="line_3994"></a>
<a id="line_3995"></a>
<a id="line_3996"></a>
<a id="line_3997"></a>


<pre>     ms/ Mr?s? @&#60;names&#62;=&#60;ident&#62; W\. @&#60;names&#62;=&#60;ident&#62;
        | Mr?s? @&#60;names&#62;=&#60;ident&#62;
        /;</pre>

<a id="line_3998"></a>
<a id="line_3999"></a>
<a id="line_4000"></a>


<pre>     # Aliasing to @names means $/&#60;names&#62; is always
     # an Array object, so...</pre>

<a id="line_4001"></a>
<a id="line_4002"></a>


<pre>     say @($/&#60;names&#62;);</pre>

<a id="line_4003"></a>
<a id="line_4004"></a>
<a id="line_4005"></a>
<a id="line_4006"></a>
<a id="line_4007"></a>

</li>

<li>For convenience and consistency, <code>@&#60;key&#62;</code> can also be used outside a regex, as a shorthand for <code>@( $/&#60;key&#62; )</code>. That is:
<a id="line_4008"></a>
<a id="line_4009"></a>
<a id="line_4010"></a>
<a id="line_4011"></a>


<pre>     ms/ Mr?s? @&#60;names&#62;=&#60;ident&#62; W\. @&#60;names&#62;=&#60;ident&#62;
        | Mr?s? @&#60;names&#62;=&#60;ident&#62;
        /;</pre>

<a id="line_4012"></a>
<a id="line_4013"></a>


<pre>     say @&#60;names&#62;;</pre>

<a id="line_4014"></a>
<a id="line_4015"></a>
<a id="line_4016"></a>
<a id="line_4017"></a>
<a id="line_4018"></a>
<a id="line_4019"></a>

</li>

<li>If an array alias is applied to a quantified pair of non-capturing brackets, it captures the substrings matched by each repetition of the brackets into separate elements of the corresponding array. That is:
<a id="line_4020"></a>
<a id="line_4021"></a>
<a id="line_4022"></a>
<a id="line_4023"></a>
<a id="line_4024"></a>
<a id="line_4025"></a>


<pre>     ms/ mv $&#60;files&#62;=[ f.. \s* ]* /; # $/&#60;files&#62; assigned a single
                                     # Match object containing the
                                     # complete substring matched by
                                     # the full set of repetitions
                                     # of the non-capturing brackets</pre>

<a id="line_4026"></a>
<a id="line_4027"></a>
<a id="line_4028"></a>
<a id="line_4029"></a>
<a id="line_4030"></a>
<a id="line_4031"></a>
<a id="line_4032"></a>


<pre>     ms/ mv @&#60;files&#62;=[ f.. \s* ]* /; # $/&#60;files&#62; assigned an array,
                                     # each element of which is a
                                     # Match object containing
                                     # the substring matched by Nth
                                     # repetition of the non-
                                     # capturing bracket match</pre>

<a id="line_4033"></a>
<a id="line_4034"></a>
<a id="line_4035"></a>
<a id="line_4036"></a>
<a id="line_4037"></a>
<a id="line_4038"></a>
<a id="line_4039"></a>
<a id="line_4040"></a>
<a id="line_4041"></a>

</li>

<li>If an array alias is applied to a quantified pair of capturing parens (i.e. to a subpattern), then the corresponding hash or array element is assigned a list constructed by concatenating the array values of each <code>Match</code> object returned by one repetition of the subpattern. That is, an array alias on a subpattern flattens and collects all nested subpattern captures within the aliased subpattern. For example:
<a id="line_4042"></a>
<a id="line_4043"></a>
<a id="line_4044"></a>
<a id="line_4045"></a>
<a id="line_4046"></a>


<pre>     if ms/ $&#60;pairs&#62;=( (\w+) \: (\N+) )+ / {
         # Scalar alias, so $/&#60;pairs&#62; is assigned an array
         # of Match objects, each of which has its own array
         # of two subcaptures...</pre>

<a id="line_4047"></a>
<a id="line_4048"></a>
<a id="line_4049"></a>
<a id="line_4050"></a>
<a id="line_4051"></a>
<a id="line_4052"></a>


<pre>         for @($&#60;pairs&#62;) -&#62; $pair {
             say &#34;Key: $pair[0]&#34;;
             say &#34;Val: $pair[1]&#34;;
         }
     }</pre>

<a id="line_4053"></a>


<a id="line_4054"></a>
<a id="line_4055"></a>
<a id="line_4056"></a>
<a id="line_4057"></a>
<a id="line_4058"></a>


<pre>     if ms/ @&#60;pairs&#62;=( (\w+) \: (\N+) )+ / {
         # Array alias, so $/&#60;pairs&#62; is assigned an array
         # of Match objects, each of which is flattened out of
         # the two subcaptures within the subpattern</pre>

<a id="line_4059"></a>
<a id="line_4060"></a>
<a id="line_4061"></a>
<a id="line_4062"></a>
<a id="line_4063"></a>
<a id="line_4064"></a>


<pre>         for @($&#60;pairs&#62;) -&#62; $key, $val {
             say &#34;Key: $key&#34;;
             say &#34;Val: $val&#34;;
         }
     }</pre>

<a id="line_4065"></a>
<a id="line_4066"></a>
<a id="line_4067"></a>
<a id="line_4068"></a>
<a id="line_4069"></a>
<a id="line_4070"></a>
<a id="line_4071"></a>

</li>

<li>Likewise, if an array alias is applied to a quantified subrule, then the hash or array element corresponding to the alias is assigned a list containing the array values of each <code>Match</code> object returned by each repetition of the subrule, all flattened into a single array:
<a id="line_4072"></a>
<a id="line_4073"></a>


<pre>     rule pair { (\w+) \: (\N+) \n }</pre>

<a id="line_4074"></a>
<a id="line_4075"></a>
<a id="line_4076"></a>
<a id="line_4077"></a>
<a id="line_4078"></a>


<pre>     if ms/ $&#60;pairs&#62;=&#60;pair&#62;+ / {
         # Scalar alias, so $/&#60;pairs&#62; contains an array of
         # Match objects, each of which is the result of the
         # &#60;pair&#62; subrule call...</pre>

<a id="line_4079"></a>
<a id="line_4080"></a>
<a id="line_4081"></a>
<a id="line_4082"></a>
<a id="line_4083"></a>
<a id="line_4084"></a>


<pre>         for @($&#60;pairs&#62;) -&#62; $pair {
             say &#34;Key: $pair[0]&#34;;
             say &#34;Val: $pair[1]&#34;;
         }
     }</pre>

<a id="line_4085"></a>


<a id="line_4086"></a>
<a id="line_4087"></a>
<a id="line_4088"></a>
<a id="line_4089"></a>
<a id="line_4090"></a>
<a id="line_4091"></a>


<pre>     if ms/ mv @&#60;pairs&#62;=&#60;pair&#62;+ / {
         # Array alias, so $/&#60;pairs&#62; contains an array of
         # Match objects, all flattened down from the
         # nested arrays inside the Match objects returned
         # by each match of the &#60;pair&#62; subrule...</pre>

<a id="line_4092"></a>
<a id="line_4093"></a>
<a id="line_4094"></a>
<a id="line_4095"></a>
<a id="line_4096"></a>
<a id="line_4097"></a>


<pre>         for @($&#60;pairs&#62;) -&#62; $key, $val {
             say &#34;Key: $key&#34;;
             say &#34;Val: $val&#34;;
         }
     }</pre>

<a id="line_4098"></a>
<a id="line_4099"></a>
<a id="line_4100"></a>
<a id="line_4101"></a>
<a id="line_4102"></a>
<a id="line_4103"></a>
<a id="line_4104"></a>

</li>

<li>In other words, an array alias is useful to flatten into a single array any nested captures that might occur within a quantified subpattern or subrule. Whereas a scalar alias is useful to preserve within a top-level array the internal structure of each repetition.
<a id="line_4105"></a>
<a id="line_4106"></a>
<a id="line_4107"></a>
<a id="line_4108"></a>
<a id="line_4109"></a>
<a id="line_4110"></a>
<a id="line_4111"></a>
<a id="line_4112"></a>

</li>

<li>It is also possible to use a numbered variable as an array alias. The semantics are exactly as described above, with the sole difference being that the resulting array of <code>Match</code> objects is assigned into the appropriate element of the regex&#39;s match array rather than to a key of its match hash. For example:
<a id="line_4113"></a>
<a id="line_4114"></a>
<a id="line_4115"></a>
<a id="line_4116"></a>
<a id="line_4117"></a>
<a id="line_4118"></a>
<a id="line_4119"></a>
<a id="line_4120"></a>
<a id="line_4121"></a>
<a id="line_4122"></a>
<a id="line_4123"></a>


<pre>     if m/ mv  \s+  @0=((\w+) \s+)+  $1=((\W+) (\s*))* / {
         #          |                |
         #          |                |
         #          |                 \_ Scalar alias, so $1 gets an
         #          |                    array, with each element
         #          |                    a Match object containing
         #          |                    the two nested captures
         #          |
         #           \___ Array alias, so $0 gets a flattened array of
         #                just the (\w+) captures from each repetition</pre>

<a id="line_4124"></a>
<a id="line_4125"></a>


<pre>         @from     = @($0);      # Flattened list</pre>

<a id="line_4126"></a>
<a id="line_4127"></a>
<a id="line_4128"></a>
<a id="line_4129"></a>


<pre>         $to_str   = $1[0][0];   # Nested elems of
         $to_gap   = $1[0][1];   #    unflattened list
     }</pre>

<a id="line_4130"></a>
<a id="line_4131"></a>
<a id="line_4132"></a>
<a id="line_4133"></a>
<a id="line_4134"></a>

</li>

<li>Note again that, outside a regex, <code>@0</code> is simply a shorthand for <code>@($0)</code>, so the first assignment above could also have been written:
<a id="line_4135"></a>
<a id="line_4136"></a>


<pre>     @from = @0;</pre>

<a id="line_4137"></a>


<a id="line_4138"></a>
<a id="line_4139"></a>

</li>
</ul>

<a id="line_4140"></a>
<a id="line_4141"></a>
<a id="line_4142"></a>
<a id="line_4143"></a>
<a id="line_4144"></a>
<a id="line_4145"></a>
<a id="line_4146"></a>
<a id="line_4147"></a>
<a id="line_4148"></a>


<h3><a class='u' href='#___top' title='click to go to top of document'
name="Hash_aliasing"
>Hash aliasing</a></h3>

<ul>
<li>An alias can also be specified using a hash as the alias variable, instead of a scalar or an array. For example:
<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-capture/hash.t#L13-L159"><code>S05-capture/hash.t</code> lines <code>13&ndash;159</code></a>
  </p>
</div>
  


<a id="line_4149"></a>
<a id="line_4150"></a>


<pre>     m/ mv %&#60;location&#62;=( (&#60;ident&#62;) \: (\N+) )+ /;</pre>

<a id="line_4151"></a>
<a id="line_4152"></a>
<a id="line_4153"></a>
<a id="line_4154"></a>
<a id="line_4155"></a>
<a id="line_4156"></a>

</li>

<li>A hash alias causes the corresponding hash or array element in the current scope&#39;s <code>Match</code> object to be assigned a (nested) Hash object (rather than an <code>Array</code> object or a single <code>Match</code> object).
<a id="line_4157"></a>
<a id="line_4158"></a>
<a id="line_4159"></a>
<a id="line_4160"></a>
<a id="line_4161"></a>
<a id="line_4162"></a>

</li>

<li>If a hash alias is applied to a subrule or subpattern then the first nested numeric capture becomes the key of each hash entry and any remaining numeric captures become the values (in an array if there is more than one).
<a id="line_4163"></a>
<a id="line_4164"></a>
<a id="line_4165"></a>
<a id="line_4166"></a>
<a id="line_4167"></a>
<a id="line_4168"></a>

</li>

<li>As with array aliases it is also possible to use a numbered variable as a hash alias. Once again, the only difference is where the resulting <code>Match</code> object is stored:
<a id="line_4169"></a>
<a id="line_4170"></a>


<pre>     rule one_to_many {  (\w+) \: (\S+) (\S+) (\S+) }</pre>

<a id="line_4171"></a>
<a id="line_4172"></a>
<a id="line_4173"></a>
<a id="line_4174"></a>
<a id="line_4175"></a>
<a id="line_4176"></a>


<pre>     if ms/ %0=&#60;one_to_many&#62;+ / {
         # $/[0] contains a hash, in which each key is provided by
         # the first subcapture within C&#60;one_to_many&#62;, and each
         # value is an array containing the
         # subrule&#39;s second, third, fourth, etc. subcaptures...</pre>

<a id="line_4177"></a>
<a id="line_4178"></a>
<a id="line_4179"></a>
<a id="line_4180"></a>
<a id="line_4181"></a>
<a id="line_4182"></a>


<pre>         for %($/[0]) -&#62; $pair {
             say &#34;One:  $pair.key()&#34;;
             say &#34;Many: { @($pair.value) }&#34;;
         }
     }</pre>

<a id="line_4183"></a>
<a id="line_4184"></a>
<a id="line_4185"></a>
<a id="line_4186"></a>

</li>

<li>Outside the regex, <code>%0</code> is a shortcut for <code>%($0)</code>:
<a id="line_4187"></a>
<a id="line_4188"></a>
<a id="line_4189"></a>
<a id="line_4190"></a>
<a id="line_4191"></a>


<pre>         for %0 -&#62; $pair {
             say &#34;One:  $pair.key()&#34;;
             say &#34;Many: @($pair.value)&#34;;
         }</pre>

<a id="line_4192"></a>


<a id="line_4193"></a>
<a id="line_4194"></a>

</li>
</ul>

<a id="line_4195"></a>
<a id="line_4196"></a>
<a id="line_4197"></a>
<a id="line_4198"></a>
<a id="line_4199"></a>
<a id="line_4200"></a>
<a id="line_4201"></a>
<a id="line_4202"></a>


<h3><a class='u' href='#___top' title='click to go to top of document'
name="External_aliasing"
>External aliasing</a></h3>

<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-capture/external-aliasing.t#L6-L38"><code>S05-capture/external-aliasing.t</code> lines <code>6&ndash;38</code></a>
  </p>
</div>
  


<ul>
<li>Instead of using internal aliases like:
<a id="line_4203"></a>
<a id="line_4204"></a>


<pre>     m/ mv  @&#60;files&#62;=&#60;ident&#62;+  $&#60;dir&#62;=&#60;ident&#62; /</pre>

<a id="line_4205"></a>
<a id="line_4206"></a>


<p>the name of an ordinary variable can be used as an <i>external</i> alias, like so:</p>

<a id="line_4207"></a>
<a id="line_4208"></a>


<pre>     m/ mv  @OUTER::files=&#60;ident&#62;+  $OUTER::dir=&#60;ident&#62; /</pre>

<a id="line_4209"></a>
<a id="line_4210"></a>
<a id="line_4211"></a>
<a id="line_4212"></a>
<a id="line_4213"></a>
<a id="line_4214"></a>
<a id="line_4215"></a>

</li>

<li>In this case, the behavior of each alias is exactly as described in the previous sections, except that any resulting capture is bound directly (but still hypothetically) to the variable of the specified name that must already exist in the scope in which the regex is declared.
<a id="line_4216"></a>


<a id="line_4217"></a>
<a id="line_4218"></a>

</li>
</ul>

<a id="line_4219"></a>
<a id="line_4220"></a>
<a id="line_4221"></a>
<a id="line_4222"></a>
<a id="line_4223"></a>
<a id="line_4224"></a>
<a id="line_4225"></a>
<a id="line_4226"></a>
<a id="line_4227"></a>
<a id="line_4228"></a>
<a id="line_4229"></a>


<h2><a class='u' href='#___top' title='click to go to top of document'
name="Capturing_from_repeated_matches"
>Capturing from repeated matches</a></h2>

<ul>
<li>When an entire regex is successfully matched with repetitions (specified via the <code>:x</code> or <code>:g</code> flag) or overlaps (specified via the <code>:ov</code> or <code>:ex</code> flag), it will usually produce a sequence of distinct matches.
<a id="line_4230"></a>
<a id="line_4231"></a>
<a id="line_4232"></a>
<a id="line_4233"></a>
<a id="line_4234"></a>
<a id="line_4235"></a>
<a id="line_4236"></a>

</li>

<li>A successful match under any of these flags still returns a single <code>Match</code> object in <code>$/</code>. However, this object may represent a partial evaluation of the regex. Moreover, the values of this match object are slightly different from those provided by a non-repeated match:
<a id="line_4237"></a>
<a id="line_4238"></a>
<a id="line_4239"></a>
<a id="line_4240"></a>
<a id="line_4241"></a>
<a id="line_4242"></a>
<a id="line_4243"></a>


<ul>
<li>The boolean value of <code>$/</code> after such matches is true or false, depending on whether the pattern matched.
<a id="line_4244"></a>
<a id="line_4245"></a>
<a id="line_4246"></a>
<a id="line_4247"></a>
<a id="line_4248"></a>
<a id="line_4249"></a>

</li>

<li>The string value is the substring from the start of the first match to the end of the last match (<i>including</i> any intervening parts of the string that the regex skipped over in order to find later matches).
<a id="line_4250"></a>
<a id="line_4251"></a>
<a id="line_4252"></a>
<a id="line_4253"></a>
<a id="line_4254"></a>
<a id="line_4255"></a>
<a id="line_4256"></a>
<a id="line_4257"></a>
<a id="line_4258"></a>

</li>

<li>Subcaptures are returned as a multidimensional list, which the user can choose to process in either of two ways. If you refer to <code>@().flat</code> (or just use <code>@()</code> in a flat list context), the multidimensionality is ignored and all the matches are returned flattened (but still lazily). If you refer to <code>lol()</code>, you can get each individual sublist as a <code>List</code> object. As with any multidimensional list, each sublist can be lazy separately.
<a id="line_4259"></a>
<a id="line_4260"></a>

</li>
</ul>

<a id="line_4261"></a>
<a id="line_4262"></a>


<p>For example:</p>

<a id="line_4263"></a>
<a id="line_4264"></a>
<a id="line_4265"></a>
<a id="line_4266"></a>


<pre>     if $text ~~ ms:g/ (\S+:) &#60;rocks&#62; / {
         say &#34;Full match context is: [$/]&#34;;
     }</pre>

<a id="line_4267"></a>
<a id="line_4268"></a>
<a id="line_4269"></a>


<p>But the list of individual match objects corresponding to each separate match is also available:</p>

<a id="line_4270"></a>
<a id="line_4271"></a>
<a id="line_4272"></a>


<pre>     if $text ~~ ms:g/ (\S+:) &#60;rocks&#62; / {
         say &#34;Matched { +lol() } times&#34;;    # Note: forced eager here by +</pre>

<a id="line_4273"></a>
<a id="line_4274"></a>
<a id="line_4275"></a>
<a id="line_4276"></a>
<a id="line_4277"></a>
<a id="line_4278"></a>
<a id="line_4279"></a>


<pre>         for lol() -&#62; $m {
             say &#34;Match between $m.from() and $m.to()&#34;;
             say &#39;Right on, dude!&#39; if $m[0] eq &#39;Perl&#39;;
             say &#34;Rocks like $m&#60;rocks&#62;&#34;;
         }
     }</pre>

<a id="line_4280"></a>
<a id="line_4281"></a>

</li>
</ul>

<a id="line_4282"></a>
<a id="line_4283"></a>
<a id="line_4284"></a>
<a id="line_4285"></a>
<a id="line_4286"></a>
<a id="line_4287"></a>
<a id="line_4288"></a>
<a id="line_4289"></a>
<a id="line_4290"></a>


<h1><a class='u' href='#___top' title='click to go to top of document'
name="Grammars"
>Grammars</a></h1>

<ul>
<li>Your private <code>ident</code> rule shouldn&#39;t clobber someone else&#39;s <code>ident</code> rule. So some mechanism is needed to confine rules to a namespace.
<a id="line_4291"></a>
<a id="line_4292"></a>
<a id="line_4293"></a>
<a id="line_4294"></a>
<a id="line_4295"></a>
<a id="line_4296"></a>

</li>

<li>If subs are the model for rules, then modules/classes are the obvious model for aggregating them. Such collections of rules are generally known as <i>grammars</i>.
<a id="line_4297"></a>
<a id="line_4298"></a>
<a id="line_4299"></a>
<a id="line_4300"></a>

</li>

<li>Just as a class can collect named actions together:
<a id="line_4301"></a>
<a id="line_4302"></a>
<a id="line_4303"></a>
<a id="line_4304"></a>
<a id="line_4305"></a>


<pre>     class Identity {
         method name { &#34;Name = $!name&#34; }
         method age  { &#34;Age  = $!age&#34;  }
         method addr { &#34;Addr = $!addr&#34; }</pre>

<a id="line_4306"></a>
<a id="line_4307"></a>
<a id="line_4308"></a>
<a id="line_4309"></a>
<a id="line_4310"></a>
<a id="line_4311"></a>


<pre>         method desc {
             print &#38;.name(), &#34;\n&#34;,
                   &#38;.age(),  &#34;\n&#34;,
                   &#38;.addr(), &#34;\n&#34;;
         }</pre>

<a id="line_4312"></a>
<a id="line_4313"></a>
<a id="line_4314"></a>


<pre>         # etc.
     }</pre>

<a id="line_4315"></a>
<a id="line_4316"></a>


<p>so too a grammar can collect a set of named rules together:</p>

<a id="line_4317"></a>
<a id="line_4318"></a>
<a id="line_4319"></a>
<a id="line_4320"></a>
<a id="line_4321"></a>
<a id="line_4322"></a>
<a id="line_4323"></a>
<a id="line_4324"></a>
<a id="line_4325"></a>
<a id="line_4326"></a>


<pre>     grammar Identity {
         rule name { Name &#39;=&#39; (\N+) }
         rule age  { Age  &#39;=&#39; (\d+) }
         rule addr { Addr &#39;=&#39; (\N+) }
         rule desc {
             &#60;name&#62; \n
             &#60;age&#62;  \n
             &#60;addr&#62; \n
         }</pre>

<a id="line_4327"></a>
<a id="line_4328"></a>
<a id="line_4329"></a>


<pre>         # etc.
     }</pre>

<a id="line_4330"></a>
<a id="line_4331"></a>
<a id="line_4332"></a>
<a id="line_4333"></a>

</li>

<li>Like classes, grammars can inherit:
<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-grammar/inheritance.t#L6-L85"><code>S05-grammar/inheritance.t</code> lines <code>6&ndash;85</code></a>
  </p>
</div>
  


<a id="line_4334"></a>


<a id="line_4335"></a>
<a id="line_4336"></a>
<a id="line_4337"></a>


<pre>     grammar Letter {
         rule text     { &#60;greet&#62; $&#60;body&#62;=&#60;line&#62;+? &#60;close&#62; }</pre>

<a id="line_4338"></a>
<a id="line_4339"></a>


<pre>         rule greet    { [Hi|Hey|Yo] $&#60;to&#62;=\S+? &#39;,&#39; }</pre>

<a id="line_4340"></a>
<a id="line_4341"></a>


<pre>         rule close    { Later dude &#39;,&#39; $&#60;from&#62;=.+ }</pre>

<a id="line_4342"></a>
<a id="line_4343"></a>
<a id="line_4344"></a>


<pre>         token line    { \N* \n}
     }</pre>

<a id="line_4345"></a>
<a id="line_4346"></a>


<pre>     grammar FormalLetter is Letter {</pre>

<a id="line_4347"></a>
<a id="line_4348"></a>


<pre>         rule greet { Dear $&#60;to&#62;=\S+? &#39;,&#39; }</pre>

<a id="line_4349"></a>
<a id="line_4350"></a>


<pre>         rule close { Yours sincerely &#39;,&#39; $&#60;from&#62;=.+ }</pre>

<a id="line_4351"></a>
<a id="line_4352"></a>


<pre>     }</pre>

<a id="line_4353"></a>
<a id="line_4354"></a>
<a id="line_4355"></a>
<a id="line_4356"></a>
<a id="line_4357"></a>
<a id="line_4358"></a>

</li>

<li>Just like the methods of a class, the rule definitions of a grammar are inherited (and polymorphic!). So there&#39;s no need to respecify <code>text</code>, <code>line</code>, etc.
<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-capture/dot.t#L92-L120"><code>S05-capture/dot.t</code> lines <code>92&ndash;120</code></a>
  </p>
</div>
  


<a id="line_4359"></a>
<a id="line_4360"></a>
<a id="line_4361"></a>
<a id="line_4362"></a>

</li>

<li>Perl 6 will come with at least one grammar predefined:
<a id="line_4363"></a>
<a id="line_4364"></a>


<pre>     grammar STD {    # Perl&#39;s own standard grammar</pre>

<a id="line_4365"></a>
<a id="line_4366"></a>


<pre>         rule prog { &#60;statement&#62;* }</pre>

<a id="line_4367"></a>
<a id="line_4368"></a>
<a id="line_4369"></a>
<a id="line_4370"></a>
<a id="line_4371"></a>
<a id="line_4372"></a>


<pre>         rule statement {
                   | &#60;decl&#62;
                   | &#60;loop&#62;
                   | &#60;label&#62; [&#60;cond&#62;|&#60;sideff&#62;|&#39;;&#39;]
         }</pre>

<a id="line_4373"></a>
<a id="line_4374"></a>


<pre>         rule decl { &#60;sub&#62; | &#60;class&#62; | &#60;use&#62; }</pre>

<a id="line_4375"></a>
<a id="line_4376"></a>
<a id="line_4377"></a>


<pre>         # etc. etc. etc.
     }</pre>

<a id="line_4378"></a>
<a id="line_4379"></a>
<a id="line_4380"></a>
<a id="line_4381"></a>

</li>

<li>Hence:
<a id="line_4382"></a>
<a id="line_4383"></a>


<pre>     $parsetree = STD.parse($source_code)</pre>

<a id="line_4384"></a>
<a id="line_4385"></a>
<a id="line_4386"></a>
<a id="line_4387"></a>
<a id="line_4388"></a>

</li>

<li>To switch to a different grammar in the middle of a regex, you may use the <code>:lang</code> adverb. For example, to match an expression &#60;expr&#62; from $funnylang that is embedded in curlies, say:
<a id="line_4389"></a>
<a id="line_4390"></a>


<pre>    token funnylang { &#39;{&#39; [ :lang($funnylang.unbalanced(&#39;}&#39;)) &#60;expr&#62; ] &#39;}&#39; }</pre>

<a id="line_4391"></a>
<a id="line_4392"></a>
<a id="line_4393"></a>
<a id="line_4394"></a>
<a id="line_4395"></a>
<a id="line_4396"></a>

</li>

<li>A string can be matched against a grammar by calling <code>.parse</code> or <code>.parsefile</code> on the grammar, and optionally pass an <i>actions</i> object to that grammar:
<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-grammar/action-stubs.t#L7-L39"><code>S05-grammar/action-stubs.t</code> lines <code>7&ndash;39</code></a>
  </p>
</div>
  


<a id="line_4397"></a>
<a id="line_4398"></a>
<a id="line_4399"></a>


<pre>    MyGrammar.parse($string, :actions($action-object))
    MyGrammar.parsefile($filename, :actions($action-object))</pre>

<a id="line_4400"></a>
<a id="line_4401"></a>
<a id="line_4402"></a>
<a id="line_4403"></a>
<a id="line_4404"></a>
<a id="line_4405"></a>
<a id="line_4406"></a>
<a id="line_4407"></a>
<a id="line_4408"></a>
<a id="line_4409"></a>


<p>This creates a <code>Grammar</code> object, whose type denotes the current language being parsed, and from which other grammars may be derived as extended languages. All grammar objects are derived from <code>Cursor</code>, so every grammar object&#39;s value embodies the current state of the current match. This new grammar object is then passed as the invocant to the <code>TOP</code> method (regex, token, or rule) of <code>MyGrammar</code>. The default rule name to call can be overridden with the <code>:rule</code> named argument of the <code>parse</code> method. This is useful for unit testing the rules of a grammar. As methods, rules can have arguments, so the <code>:args</code> named argument is used to pass such arguments as a list if necessary.</p>

<a id="line_4410"></a>
<a id="line_4411"></a>
<a id="line_4412"></a>
<a id="line_4413"></a>
<a id="line_4414"></a>
<a id="line_4415"></a>
<a id="line_4416"></a>
<a id="line_4417"></a>
<a id="line_4418"></a>
<a id="line_4419"></a>


<p>Grammar objects are considered immutable, so every match returns a different match state, and multiple match states may exist simultaneously. Each such match state is considered a hypothesis on how the pattern will eventually match. A backtrackable choice in pattern matching may be easily represented in Perl 6 as a lazy list of match state cursors; backtracking consists of merely throwing away the front value of the list and continuing to match with the next value. Hence, the management of these match cursors controls how backtracking works, and falls naturally out of the lazy list paradigm.</p>

<a id="line_4420"></a>
<a id="line_4421"></a>
<a id="line_4422"></a>
<a id="line_4423"></a>


<p>The <code>.parse</code> and <code>.parsefile</code> methods anchor to the beginning and ending of the text, and fail if the end of text is not reached. (The <code>TOP</code> rule can check against <code>$</code> itself if it wishes to produce its own error message.)</p>

<a id="line_4424"></a>
<a id="line_4425"></a>
<a id="line_4426"></a>
<a id="line_4427"></a>
<a id="line_4428"></a>


<p>If you wish to parse a portion of a text, then use the <code>.subparse</code> method instead. You may pass a <code>:pos</code> argument to start parsing at some position other than 0. You may pass a <code>:rule</code> argument to specify which subrule you&#39;re wanting to call. The final position can be determined by examining the returned <code>Match</code> object.</p>

<a id="line_4429"></a>
<a id="line_4430"></a>

</li>
</ul>

<a id="line_4431"></a>
<a id="line_4432"></a>
<a id="line_4433"></a>
<a id="line_4434"></a>
<a id="line_4435"></a>
<a id="line_4436"></a>
<a id="line_4437"></a>
<a id="line_4438"></a>
<a id="line_4439"></a>
<a id="line_4440"></a>
<a id="line_4441"></a>
<a id="line_4442"></a>
<a id="line_4443"></a>


<h1><a class='u' href='#___top' title='click to go to top of document'
name="Action_objects"
>Action objects</a></h1>

<p>Action objects (provided via the <code>:actions</code> named argument in <code>Grammar.parse</code>) are objects whose methods correspond to the rules in a grammar. When a rule in a grammar matches, any method in the actions object with the same name (if there is one) is used to build the AST for the <code>Match</code> the grammar is building. Action methods should have a single parameter (by convention, <code>$/</code>) that contains the <code>Match</code> object for the rule. Action methods are invoked as soon as the corresponding rule has a successful match, regardless of if the match occurs in a zero-width match or in a backtracking branch that may eventually fail, so state should be tracked via the AST and side effects may cause unexpected behavior.</p>

<a id="line_4444"></a>
<a id="line_4445"></a>
<a id="line_4446"></a>


<p>Action methods are called within the call frame for the rule, so dynamic variables set in the rule are passed along to the action method.</p>

<a id="line_4447"></a>
<a id="line_4448"></a>
<a id="line_4449"></a>
<a id="line_4450"></a>
<a id="line_4451"></a>
<a id="line_4452"></a>


<h1><a class='u' href='#___top' title='click to go to top of document'
name="Syntactic_categories"
>Syntactic categories</a></h1>

<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-syntactic-categories/new-symbols.t#L7-L36"><code>S05-syntactic-categories/new-symbols.t</code> lines <code>7&ndash;36</code></a>
  </p>
</div>
  


<p>For writing your own backslash and assertion subrules, you may augment (your copy of) the Regex sublanguage, using the following syntactic categories:</p>

<a id="line_4453"></a>
<a id="line_4454"></a>
<a id="line_4455"></a>
<a id="line_4456"></a>
<a id="line_4457"></a>


<pre>    augment slang Regex {
        token backslash:sym&#60;y&#62; { ... }   # define your own \y and \Y
        token assertion:sym&#60;*&#62; { ... }   # define your own &#60;*stuff&#62;
        token metachar:sym&#60;,&#62; { ... }    # define a new metacharacter</pre>

<a id="line_4458"></a>
<a id="line_4459"></a>
<a id="line_4460"></a>


<pre>        multi method tweak (:$x) {...}   # define your own :x modifier
    }</pre>

<a id="line_4461"></a>
<a id="line_4462"></a>
<a id="line_4463"></a>
<a id="line_4464"></a>
<a id="line_4465"></a>
<a id="line_4466"></a>


<h1><a class='u' href='#___top' title='click to go to top of document'
name="Pragmas"
>Pragmas</a></h1>

<p>Various pragmas may be used to control various aspects of regex compilation and usage not otherwise provided for. These are tied to the particular declarator in question:</p>

<a id="line_4467"></a>
<a id="line_4468"></a>
<a id="line_4469"></a>
<a id="line_4470"></a>
<a id="line_4471"></a>
<a id="line_4472"></a>
<a id="line_4473"></a>


<pre>    use s :foo;         # control s defaults
    use m :foo;         # control m defaults
    use rx :foo;        # control rx defaults
    use regex :foo;     # control regex defaults
    use token :foo;     # control token defaults
    use rule :foo;      # control rule defaults</pre>

<a id="line_4474"></a>
<a id="line_4475"></a>
<a id="line_4476"></a>
<a id="line_4477"></a>
<a id="line_4478"></a>
<a id="line_4479"></a>


<p>(It is a general policy in Perl 6 that any pragma designed to influence the surface behavior of a keyword is identical to the keyword itself, unless there is good reason to do otherwise. On the other hand, pragmas designed to influence deep semantics should not be named identically, though of course some similarity is good.)</p>

<a id="line_4480"></a>
<a id="line_4481"></a>
<a id="line_4482"></a>
<a id="line_4483"></a>
<a id="line_4484"></a>
<a id="line_4485"></a>
<a id="line_4486"></a>
<a id="line_4487"></a>
<a id="line_4488"></a>
<a id="line_4489"></a>


<h1><a class='u' href='#___top' title='click to go to top of document'
name="Transliteration"
>Transliteration</a></h1>

<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-transliteration/trans.t#L12-L285"><code>S05-transliteration/trans.t</code> lines <code>12&ndash;285</code></a>
  </p>
</div>
  


<ul>
<li>The <code>tr///</code> quote-like operator now also has a method form called <code>trans()</code>. Its argument is a list of pairs. You can use anything that produces a pair list:
<a id="line_4490"></a>
<a id="line_4491"></a>


<pre>     $str.trans( %mapping.pairs );</pre>

<a id="line_4492"></a>
<a id="line_4493"></a>


<p>Use the <code>.=</code> form to do a translation in place:</p>

<a id="line_4494"></a>
<a id="line_4495"></a>


<pre>     $str.=trans( %mapping.pairs );</pre>

<a id="line_4496"></a>
<a id="line_4497"></a>
<a id="line_4498"></a>


<p>(Perl 6 does not support the <code>y///</code> form, which was only in <code>sed</code> because they were running out of single letters.)</p>

<a id="line_4499"></a>
<a id="line_4500"></a>
<a id="line_4501"></a>
<a id="line_4502"></a>

</li>

<li>The two sides of any pair can be strings interpreted as <code>tr///</code> would:
<a id="line_4503"></a>
<a id="line_4504"></a>


<pre>     $str.=trans( &#39;A..C&#39; =&#62; &#39;a..c&#39;, &#39;XYZ&#39; =&#62; &#39;xyz&#39; );</pre>

<a id="line_4505"></a>
<a id="line_4506"></a>


<p>As a degenerate case, each side can be individual characters:</p>

<a id="line_4507"></a>
<a id="line_4508"></a>


<pre>     $str.=trans( &#39;A&#39;=&#62;&#39;a&#39;, &#39;B&#39;=&#62;&#39;b&#39;, &#39;C&#39;=&#62;&#39;c&#39; );</pre>

<a id="line_4509"></a>
<a id="line_4510"></a>
<a id="line_4511"></a>
<a id="line_4512"></a>
<a id="line_4513"></a>
<a id="line_4514"></a>
<a id="line_4515"></a>
<a id="line_4516"></a>


<p>Whitespace characters are taken literally as characters to be translated from or to. The <code>..</code> range sequence is the only metasyntax recognized within a string, though you may of course use backslash interpolations in double quotes. If the right side is too short, the final character is replicated out to the length of the left string. If there is no final character because the right side is the null string, the result is deletion instead.</p>

<a id="line_4517"></a>
<a id="line_4518"></a>
<a id="line_4519"></a>
<a id="line_4520"></a>

</li>

<li>Either or both sides of the pair may also be Array objects:
<a id="line_4521"></a>
<a id="line_4522"></a>


<pre>     $str.=trans( [&#39;A&#39;..&#39;C&#39;] =&#62; [&#39;a&#39;..&#39;c&#39;], &#60;X Y Z&#62; =&#62; &#60;x y z&#62; );</pre>

<a id="line_4523"></a>
<a id="line_4524"></a>
<a id="line_4525"></a>
<a id="line_4526"></a>
<a id="line_4527"></a>


<p>The array version is the underlying primitive form: the semantics of the string form is exactly equivalent to first doing <code>..</code> expansion and then splitting the string into individual characters and then using that as an array.</p>

<a id="line_4528"></a>
<a id="line_4529"></a>
<a id="line_4530"></a>
<a id="line_4531"></a>
<a id="line_4532"></a>

</li>

<li>The array version can map one-or-more characters to one-or-more characters:
<a id="line_4533"></a>
<a id="line_4534"></a>
<a id="line_4535"></a>


<pre>     $str.=trans( [&#39; &#39;,      &#39;&#60;&#39;,    &#39;&#62;&#39;,    &#39;&#38;&#39;    ] =&#62;
                  [&#39;&#38;nbsp;&#39;, &#39;&#38;lt;&#39;, &#39;&#38;gt;&#39;, &#39;&#38;amp;&#39; ]);</pre>

<a id="line_4536"></a>
<a id="line_4537"></a>
<a id="line_4538"></a>
<a id="line_4539"></a>


<p>In the case that more than one sequence of input characters matches, the longest one wins. In the case of two identical sequences the first in order wins.</p>

<a id="line_4540"></a>
<a id="line_4541"></a>
<a id="line_4542"></a>


<p>As with the string form, missing righthand elements replicate the final element, and a null array results in deletion instead.</p>

<a id="line_4543"></a>
<a id="line_4544"></a>
<a id="line_4545"></a>
<a id="line_4546"></a>
<a id="line_4547"></a>
<a id="line_4548"></a>
<a id="line_4549"></a>

</li>

<li>The recognition done by the string and array forms is very basic. To achieve greater power, any recognition element of the left side may be specified by a regex that can do character classes, lookahead, etc.
<a id="line_4550"></a>


<a id="line_4551"></a>
<a id="line_4552"></a>
<a id="line_4553"></a>


<pre>    $str.=trans( [/ \h /,   &#39;&#60;&#39;,    &#39;&#62;&#39;,    &#39;&#38;&#39;    ] =&#62;
                 [&#39;&#38;nbsp;&#39;, &#39;&#38;lt;&#39;, &#39;&#38;gt;&#39;, &#39;&#38;amp;&#39; ]);</pre>

<a id="line_4554"></a>
<a id="line_4555"></a>
<a id="line_4556"></a>


<pre>    $str.=trans( / \s+ / =&#62; &#39; &#39; );  # squash all whitespace to one space
    $str.=trans( / &#60;-alpha&#62; / =&#62; &#39;&#39; );  # delete all non-alpha</pre>

<a id="line_4557"></a>
<a id="line_4558"></a>
<a id="line_4559"></a>
<a id="line_4560"></a>
<a id="line_4561"></a>
<a id="line_4562"></a>
<a id="line_4563"></a>


<p>These submatches are mixed into the overall match in exactly the same way that they are mixed into parallel alternation in ordinary regex processing, so longest token rules apply across all the possible matches specified to the transliteration operator. Once a match is made and transliterated, the parallel matching resumes at the new position following the end of the previous match, even if it matched multiple characters.</p>

<a id="line_4564"></a>
<a id="line_4565"></a>
<a id="line_4566"></a>
<a id="line_4567"></a>
<a id="line_4568"></a>
<a id="line_4569"></a>

</li>

<li>If the right side of the arrow is a closure, it is evaluated to determine the replacement value. If the left side was matched by a regex, the resulting match object is available within the closure.
<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-transliteration/with-closure.t#L5-L57"><code>S05-transliteration/with-closure.t</code> lines <code>5&ndash;57</code></a>
  </p>
</div>
  


<a id="line_4570"></a>
<a id="line_4571"></a>

</li>
</ul>

<a id="line_4572"></a>
<a id="line_4573"></a>
<a id="line_4574"></a>
<a id="line_4575"></a>


<h1><a class='u' href='#___top' title='click to go to top of document'
name="Substitution"
>Substitution</a></h1>

<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-substitution/subst.t#L8-L208"><code>S05-substitution/subst.t</code> lines <code>8&ndash;208</code></a>
  </p>
</div>
  


<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-substitution/match.t#L7-L51"><code>S05-substitution/match.t</code> lines <code>7&ndash;51</code></a>
  </p>
</div>
  


<p>There are also method forms of <code>m//</code> and <code>s///</code>:</p>

<a id="line_4576"></a>
<a id="line_4577"></a>
<a id="line_4578"></a>
<a id="line_4579"></a>
<a id="line_4580"></a>
<a id="line_4581"></a>


<pre>     $str.match(/pat/);
     $str.subst(/pat/, &#34;replacement&#34;);
     $str.subst(/pat/, {&#34;replacement&#34;});
     $str.=subst(/pat/, &#34;replacement&#34;);
     $str.=subst(/pat/, {&#34;replacement&#34;});</pre>

<a id="line_4582"></a>
<a id="line_4583"></a>
<a id="line_4584"></a>


<p>The <code>.match</code> and <code>.subst</code> methods support the adverbs of <code>m//</code> and <code>s///</code> as named arguments, so you can write</p>

<a id="line_4585"></a>
<a id="line_4586"></a>


<pre>    $str.match(/pat/, :g)</pre>

<a id="line_4587"></a>
<a id="line_4588"></a>


<p>as an equivalent to</p>

<a id="line_4589"></a>
<a id="line_4590"></a>


<pre>    $str.comb(/pat/, :match)</pre>

<a id="line_4591"></a>
<a id="line_4592"></a>
<a id="line_4593"></a>
<a id="line_4594"></a>
<a id="line_4595"></a>


<p>There is no syntactic sugar here, so in order to get deferred evaluation of the replacement you must put it into a closure. The syntactic sugar is provided only by the quotelike forms. First there is the standard &#34;triple quote&#34; form:</p>

<a id="line_4596"></a>
<a id="line_4597"></a>


<pre>    s/pattern/replacement/</pre>

<a id="line_4598"></a>
<a id="line_4599"></a>
<a id="line_4600"></a>
<a id="line_4601"></a>


<p>Only non-bracket characters may be used for the &#34;triple quote&#34;. The right side is always evaluated as if it were a double-quoted string regardless of the quote chosen.</p>

<a id="line_4602"></a>
<a id="line_4603"></a>
<a id="line_4604"></a>
<a id="line_4605"></a>
<a id="line_4606"></a>
<a id="line_4607"></a>


<p>As with Perl 5, a bracketing form is also supported, but unlike Perl 5, Perl 6 uses the brackets <i>only</i> around the pattern. The replacement is then specified as if it were an ordinary item assignment, with ordinary quoting rules. To pick your own quotes on the right just use one of the <code>q</code> forms. The substitution above is equivalent to:</p>

<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-substitution/subst.t#L265-L367"><code>S05-substitution/subst.t</code> lines <code>265&ndash;367</code></a>
  </p>
</div>
  


<a id="line_4608"></a>
<a id="line_4609"></a>


<pre>    s[pattern] = &#34;replacement&#34;</pre>

<a id="line_4610"></a>
<a id="line_4611"></a>


<p>or</p>

<a id="line_4612"></a>
<a id="line_4613"></a>


<pre>    s[pattern] = qq[replacement]</pre>

<a id="line_4614"></a>
<a id="line_4615"></a>
<a id="line_4616"></a>
<a id="line_4617"></a>
<a id="line_4618"></a>
<a id="line_4619"></a>
<a id="line_4620"></a>


<p>This is not a normal assignment, since the right side is evaluated each time the substitution matches (much like the pseudo-assignment to declarators can happen at strange times). It is therefore treated as a &#34;thunk&#34;, that is, it will be called as a chunk of code that creates a dynamic scope but not a lexical scope. (You can also think of a thunk as a closure that uses the current lexical scope parasitically.) In fact, it makes no sense at all to say</p>

<a id="line_4621"></a>
<a id="line_4622"></a>


<pre>    s[pattern] = { doit }</pre>

<a id="line_4623"></a>
<a id="line_4624"></a>


<p>because that would try to substitute a closure into the string.</p>

<a id="line_4625"></a>
<a id="line_4626"></a>
<a id="line_4627"></a>


<p>Any scalar assignment operator may be used; the substitution macro knows how to turn</p>

<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-substitution/subst.t#L368-L674"><code>S05-substitution/subst.t</code> lines <code>368&ndash;674</code></a>
  </p>
</div>
  


<a id="line_4628"></a>
<a id="line_4629"></a>


<pre>    $target ~~ s:g[pattern] op= expr</pre>

<a id="line_4630"></a>
<a id="line_4631"></a>


<p>into something like:</p>

<a id="line_4632"></a>
<a id="line_4633"></a>


<pre>    $target.=subst(rx[pattern], { $() op expr }, :g)</pre>

<a id="line_4634"></a>
<a id="line_4635"></a>
<a id="line_4636"></a>


<p>(The actual implementation of <code>s///</code> must return a <code>Match</code> to make smartmatch work right. The rewrite above merely returns the changed string.)</p>

<a id="line_4637"></a>
<a id="line_4638"></a>


<p>So, for example, you can multiply every dollar amount by 2 with:</p>

<a id="line_4639"></a>
<a id="line_4640"></a>


<pre>    s:g[\$ &#60;( \d+ )&#62;] *= 2</pre>

<a id="line_4641"></a>
<a id="line_4642"></a>
<a id="line_4643"></a>


<p>(Of course, the optimizer is free to do something faster than an actual method call.)</p>

<a id="line_4644"></a>
<a id="line_4645"></a>
<a id="line_4646"></a>
<a id="line_4647"></a>
<a id="line_4648"></a>
<a id="line_4649"></a>


<p>You&#39;ll note from the last example that substitutions only happen on the &#34;official&#34; string result of the match, that is, the portion of the string between the <code>$/.from</code> and <code>$/.to</code> positions. (Here we set those explicitly using the <code>&#60;(...)&#62;</code> pair; otherwise we would have had to use lookbehind to match the <code>$</code>.)</p>

<a id="line_4650"></a>
<a id="line_4651"></a>
<a id="line_4652"></a>
<a id="line_4653"></a>
<a id="line_4654"></a>
<a id="line_4655"></a>


<p>Please note that the <code>:ii</code>/<code>:samecase</code> and <code>:mm</code>/<code>:samemark</code> switches are really two different modifiers in one, and when the compiler desugars the quote-like forms it distributes semantics to both the pattern and the replacement. That is, <code>:ii</code> on the replacement implies a <code>:i</code> on the pattern, and <code>:mm</code> implies <code>:m</code>. The proper method equivalents to:</p>

<a id="line_4656"></a>
<a id="line_4657"></a>
<a id="line_4658"></a>


<pre>    s:ii/foo/bar/
    s:mm/boo/far/</pre>

<a id="line_4659"></a>
<a id="line_4660"></a>


<p>are not:</p>

<a id="line_4661"></a>
<a id="line_4662"></a>
<a id="line_4663"></a>


<pre>    .subst(/foo/, &#39;bar&#39;, :ii)   # WRONG
    .subst(/boo/, &#39;far&#39;, :mm)   # WRONG</pre>

<a id="line_4664"></a>
<a id="line_4665"></a>


<p>but rather:</p>

<a id="line_4666"></a>
<a id="line_4667"></a>
<a id="line_4668"></a>


<pre>    .subst(rx:i/foo/, &#39;bar&#39;, :ii)   # okay
    .subst(rx:m/boo/, &#39;far&#39;, :mm)   # okay</pre>

<a id="line_4669"></a>
<a id="line_4670"></a>
<a id="line_4671"></a>
<a id="line_4672"></a>
<a id="line_4673"></a>
<a id="line_4674"></a>


<p>It is specifically <i>not</i> required of an implementation that it treat the regexes as generic with respect to case and mark. Retroactive recompilation is considered harmful. If an implementation does do lazy generic case and mark semantics, it is erroneous and non-portable for a program to depend on it.</p>

<a id="line_4675"></a>
<a id="line_4676"></a>
<a id="line_4677"></a>
<a id="line_4678"></a>
<a id="line_4679"></a>
<a id="line_4680"></a>


<p>One other difference between the <code>s///</code> and <code>.subst</code> forms is that, while <code>.subst</code> returns the modified string (and cannot, therefore, be used as a smart matcher), the <code>s///</code> form always returns either a <code>Match</code> object to indicate to smartmatch that it was successful, or a <code>Nil</code> value to indicate that it was not.</p>

<a id="line_4681"></a>
<a id="line_4682"></a>
<a id="line_4683"></a>
<a id="line_4684"></a>
<a id="line_4685"></a>
<a id="line_4686"></a>
<a id="line_4687"></a>
<a id="line_4688"></a>


<p>Likewise, for both <code>m:g</code> matches and <code>s:g</code> substitutions, there may be multiple matches found. These constructs must still continue to work under smartmatching while returning a list of matches. Fortunately, <code>List</code> is one of the distinguished types that a matcher may return to indicate success or failure. So these construct simply return the list of successful matches, which will be empty (and hence false) if no matches occurred.</p>

<a id="line_4689"></a>
<a id="line_4690"></a>
<a id="line_4691"></a>
<a id="line_4692"></a>
<a id="line_4693"></a>
<a id="line_4694"></a>
<a id="line_4695"></a>
<a id="line_4696"></a>
<a id="line_4697"></a>
<a id="line_4698"></a>
<a id="line_4699"></a>


<h1><a class='u' href='#___top' title='click to go to top of document'
name="Positional_matching,_fixed_width_types"
>Positional matching, fixed width types</a></h1>

<ul>
<li>To anchor to a particular position in the general case you can use the <code>&#60;at($pos)&#62;</code> assertion to say that the current position is the same as the position object you supply. You may set the current match position via the <code>:c</code> and <code>:p</code> modifiers.
<a id="line_4700"></a>
<a id="line_4701"></a>
<a id="line_4702"></a>
<a id="line_4703"></a>
<a id="line_4704"></a>
<a id="line_4705"></a>
<a id="line_4706"></a>
<a id="line_4707"></a>
<a id="line_4708"></a>


<p>However, please remember that in Perl 6 string positions are generally <i>not</i> integers, but objects that point to a particular place in the string regardless of whether you count by bytes or codepoints or graphemes. If used with an integer, the <code>at</code> assertion will assume you mean the current lexically scoped Unicode level, on the assumption that this integer was somehow generated in this same lexical scope. If this is outside the current string&#39;s allowed Unicode abstraction levels, an exception is thrown. See S02 for more discussion of string positions.</p>

<a id="line_4709"></a>
<a id="line_4710"></a>
<a id="line_4711"></a>
<a id="line_4712"></a>
<a id="line_4713"></a>
<a id="line_4714"></a>
<a id="line_4715"></a>
<a id="line_4716"></a>
<a id="line_4717"></a>
<a id="line_4718"></a>
<a id="line_4719"></a>
<a id="line_4720"></a>
<a id="line_4721"></a>
<a id="line_4722"></a>
<a id="line_4723"></a>

</li>

<li><code>Buf</code> types are based on fixed-width cells and can therefore handle integer positions just fine, and treat them as array indices. In particular, <code>buf8</code> (also known as <code>buf</code>) is just an old-school byte string. Matches against <code>Buf</code> types are restricted to ASCII semantics in the absence of an <i>explicit</i> modifier asking for the array&#39;s values to be treated as some particular encoding such as UTF-32. (This is also true for those compact arrays that are considered isomorphic to <code>Buf</code> types.) Positions within <code>Buf</code> types are always integers, counting one per unit cell of the underlying array. Be aware that &#34;from&#34; and &#34;to&#34; positions are reported as being between elements. If matching against a compact array <code>@foo</code>, a final position of 42 indicates that <code>@foo[42]</code> was the first element <i>not</i> included.
<a id="line_4724"></a>
<a id="line_4725"></a>

</li>
</ul>

<a id="line_4726"></a>
<a id="line_4727"></a>
<a id="line_4728"></a>
<a id="line_4729"></a>
<a id="line_4730"></a>
<a id="line_4731"></a>
<a id="line_4732"></a>
<a id="line_4733"></a>
<a id="line_4734"></a>


<h1><a class='u' href='#___top' title='click to go to top of document'
name="Matching_against_non-strings"
>Matching against non-strings</a></h1>

<div class="smartlink">
  <p class="smartlink-file"><a href="https://github.com/perl6/roast/blob/master/S05-nonstrings/basic.t#L7-L46"><code>S05-nonstrings/basic.t</code> lines <code>7&ndash;46</code></a>
  </p>
</div>
  


<ul>
<li>Anything that can be tied to a string can be matched against a regex. This feature is particularly useful with input streams:
<a id="line_4735"></a>
<a id="line_4736"></a>


<pre>     my $stream := cat $fh.lines;       # tie scalar to filehandle</pre>

<a id="line_4737"></a>
<a id="line_4738"></a>


<pre>     # and later...</pre>

<a id="line_4739"></a>
<a id="line_4740"></a>


<pre>     $stream ~~ m/pattern/;         # match from stream</pre>

<a id="line_4741"></a>
<a id="line_4742"></a>
<a id="line_4743"></a>
<a id="line_4744"></a>
<a id="line_4745"></a>
<a id="line_4746"></a>
<a id="line_4747"></a>

</li>

<li>Any non-compact array of mixed strings or objects can be matched against a regex as long as you present them as an object with the <code>Str</code> interface, which does not preclude the object having other interfaces such as <code>Array</code>. Normally you&#39;d use <code>cat</code> to generate such an object:
<a id="line_4748"></a>
<a id="line_4749"></a>


<pre>    @array.cat ~~ / foo &#60;,&#62; bar &#60;elem&#62;* /;</pre>

<a id="line_4750"></a>
<a id="line_4751"></a>
<a id="line_4752"></a>
<a id="line_4753"></a>


<p>The special <code>&#60;,&#62;</code> subrule matches the boundary between elements. The <code>&#60;elem&#62;</code> assertion matches any individual array element. It is the equivalent of the &#34;dot&#34; metacharacter for the whole element.</p>

<a id="line_4754"></a>
<a id="line_4755"></a>
<a id="line_4756"></a>
<a id="line_4757"></a>
<a id="line_4758"></a>
<a id="line_4759"></a>
<a id="line_4760"></a>
<a id="line_4761"></a>


<p>If the array elements are strings, they are concatenated virtually into a single logical string. If the array elements are tokens or other such objects, the objects must provide appropriate methods for the kinds of subrules to match against. It is an assertion failure to match a string-matching assertion against an object that doesn&#39;t provide a stringified view. However, pure object lists can be parsed as long as the match (including any subrules) restricts itself to assertions like:</p>

<a id="line_4762"></a>
<a id="line_4763"></a>
<a id="line_4764"></a>
<a id="line_4765"></a>


<pre>     &#60;.isa(Dog)&#62;
     &#60;.does(Bark)&#62;
     &#60;.can(&#39;scratch&#39;)&#62;</pre>

<a id="line_4766"></a>
<a id="line_4767"></a>
<a id="line_4768"></a>
<a id="line_4769"></a>
<a id="line_4770"></a>
<a id="line_4771"></a>


<p>It is permissible to mix objects and strings in an array as long as they&#39;re in different elements. You may not embed objects in strings, however. Any object may, of course, pretend to be a string element if it likes, and so a <code>Cat</code> object may be used as a substring with the same restrictions as in the main string.</p>

<a id="line_4772"></a>
<a id="line_4773"></a>
<a id="line_4774"></a>
<a id="line_4775"></a>
<a id="line_4776"></a>
<a id="line_4777"></a>
<a id="line_4778"></a>
<a id="line_4779"></a>


<p>Please be aware that the warnings on <code>.from</code> and <code>.to</code> returning opaque objects goes double for matching against an array, where a particular position reflects both a position within the array and (potentially) a position within a string of that array. Do not expect to do math with such values. Nor should you expect to be able to extract a substr that crosses element boundaries. [Conjecture: Or should you?]</p>

<a id="line_4780"></a>
<a id="line_4781"></a>
<a id="line_4782"></a>
<a id="line_4783"></a>

</li>

<li>To match against every element of an array, use a hyper operator:
<a id="line_4784"></a>
<a id="line_4785"></a>


<pre>     @array&#187;.match($regex);</pre>

<a id="line_4786"></a>
<a id="line_4787"></a>
<a id="line_4788"></a>
<a id="line_4789"></a>
<a id="line_4790"></a>

</li>

<li>To match against any element of the array, it suffices to use ordinary smartmatching:
<a id="line_4791"></a>
<a id="line_4792"></a>


<pre>    @array ~~ $regex;</pre>

<a id="line_4793"></a>
<a id="line_4794"></a>

</li>
</ul>

<a id="line_4795"></a>
<a id="line_4796"></a>
<a id="line_4797"></a>
<a id="line_4798"></a>
<a id="line_4799"></a>
<a id="line_4800"></a>
<a id="line_4801"></a>
<a id="line_4802"></a>
<a id="line_4803"></a>
<a id="line_4804"></a>
<a id="line_4805"></a>
<a id="line_4806"></a>
<a id="line_4807"></a>
<a id="line_4808"></a>
<a id="line_4809"></a>
<a id="line_4810"></a>


<h1><a class='u' href='#___top' title='click to go to top of document'
name="When_$/_is_valid"
>When <code>$/</code> is valid</a></h1>

<p>To provide implementational freedom, the <code>$/</code> variable is not guaranteed to be defined until the pattern reaches a sequence point that requires it (such as completing the match, or calling an embedded closure, or even evaluating a submatch that requires a Perl expression for its argument). Within regex code, <code>$/</code> is officially undefined, and references to <code>$0</code> or other capture variables may be compiled to produce the current value without reference to <code>$/</code>. Likewise a reference to <code>$&#60;foo&#62;</code> does not necessarily mean <code>$/&#60;foo&#62;</code> within the regex proper. During the execution of a match, the current match state is actually stored in a <code>$&#162;</code> variable lexically scoped to an appropriate portion of the match, but that is not guaranteed to behave the same as the <code>$/</code> object, because <code>$/</code> is of type <code>Match</code>, while the match state is of a type derived from <code>Cursor</code>.</p>

<a id="line_4811"></a>
<a id="line_4812"></a>
<a id="line_4813"></a>
<a id="line_4814"></a>
<a id="line_4815"></a>
<a id="line_4816"></a>
<a id="line_4817"></a>
<a id="line_4818"></a>


<p>In any case this is all transparent to the user for simple matches; and outside of regex code (and inside closures within the regex) the <code>$/</code> variable is guaranteed to represent the state of the match at that point. That is, normal Perl code can always depend on <code>$&#60;foo&#62;</code> meaning <code>$/&#60;foo&#62;</code>, and <code>$0</code> meaning <code>$/[0]</code>, whether that code is embedded in a closure within the regex or outside the regex after the match completes.</p>

<a id="line_4819"></a>
<a id="line_4820"></a>
<a id="line_4821"></a>
<a id="line_4822"></a>
<a id="line_4823"></a>
<a id="line_4824"></a>
<a id="line_4825"></a>
<a id="line_4826"></a>
<a id="line_4827"></a>


<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHORS"
>AUTHORS</a></h1>

<pre>    Damian Conway &#60;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="0662676b6f67684665696871677f28697461">[email&#160;protected]</a>&#62;
    Allison Randal &#60;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="05646945766d64616a7260612b6b6071">[email&#160;protected]</a>&#62;
    Patrick Michaud &#60;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="d6a6bbbfb5beb7a3b296a6b9b4b9aef8b5b9bb">[email&#160;protected]</a>&#62;
    Larry Wall &#60;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="4824293a3a31083f29242466273a2f">[email&#160;protected]</a>&#62;
    Moritz Lenz &#60;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="335e5c415a4749735552465a0158001d5c4154">[email&#160;protected]</a>&#62;
    Tobias Leich &#60;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="27424a464e4b67415548404054094342">[email&#160;protected]</a>&#62;</pre>



<!-- end doc -->


        [ <a href="#__top">Top</a> ] &nbsp;
        [ <a href="http://design.perl6.org/">Index of Synopses</a> ]
        <script data-cfasync="false" src="/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script></body></html>

